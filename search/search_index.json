{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KevinbotLib","text":"<p>This library consists of classes to operate Kevinbot v3.</p> <p>Development</p> <p>This project is in the early stage of development. There are many missing functions that will be supported in the future.</p>"},{"location":"architecture/","title":"Architecture","text":"<pre><code>flowchart TD\n subgraph s1[\"KevinbotLib Server\"]\n        n5[\"KevinbotLib&lt;br&gt;Direct Serial\"]\n        n9[\"XBee Interface\"]\n  end\n    n3[\"MQTT API Mode\"] &lt;--&gt; n4[\"MQTT Broker\"]\n    n4 &lt;--&gt; s1\n    n5 --&gt; n6[\"Kevinbot&lt;br&gt;Hardware\"]\n    n2[\"Direct Serial\"] --&gt; n6\n    n9 &lt;--&gt; n5\n    n9 --&gt; n4\n    n10[\"OR\"] --&gt; n11[\"Direct Serial Mode&lt;br&gt;\"] &amp; n12[\"MQTT Mode\"]\n    n1[\"KevinbotLib\"] --&gt; n10\n    n11 --&gt; n2\n    n12 --&gt; n3\n    n3@{ shape: rect}\n    n4@{ shape: rect}\n    n6@{ shape: rect}\n    n2@{ shape: rect}\n    n10@{ shape: diam}\n    n11@{ shape: text}\n    n1@{ shape: rect}\n    n12@{ shape: text}</code></pre>"},{"location":"cli_listener/","title":"MQTT Listener","text":"<p>The MQTT Listener command line tool provides an easy way to subscribe to MQTT topics.  It subscribes to an MQTT topic, and logs messages to the terminal.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot listen [OPTIONS] TOPIC\n</code></pre>"},{"location":"cli_listener/#options","title":"Options","text":"Argument Type Description <code>--qos</code> INT MQTT Quality-of-Service"},{"location":"examples/","title":"Examples","text":""},{"location":"reference/","title":"Reference","text":"<p>Configuration manager for KevinbotLib</p> <p>KevinbotLib Robot Server Allow accessing KevinbotLib APIs over MQTT and XBee API Mode</p>"},{"location":"reference/#kevinbotlib.core.BaseKevinbotSubsystem","title":"<code>BaseKevinbotSubsystem</code>","text":"<p>The base subsystem class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class BaseKevinbotSubsystem:\n    \"\"\"The base subsystem class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self, robot: \"SerialKevinbot\") -&gt; None:\n        self.robot = robot\n        self.robot._register_component(self)  # noqa: SLF001\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot","title":"<code>BaseKevinbot</code>","text":"<p>The base robot class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class BaseKevinbot:\n    \"\"\"The base robot class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._state = KevinbotState()\n        self._subsystems: list[BaseKevinbotSubsystem] = []\n\n        self._auto_disconnect = True\n        atexit.register(self.disconnect)\n\n    def get_state(self) -&gt; KevinbotState:\n        \"\"\"Gets the current state of the robot\n\n        Returns:\n            KevinbotState: State class\n        \"\"\"\n        return self._state\n\n    def disconnect(self):\n        \"\"\"Basic robot disconnect\"\"\"\n        self._state.connected = False\n        self.send(\"core.link.unlink\")\n\n    @property\n    def auto_disconnect(self) -&gt; bool:\n        \"\"\"Getter for auto disconnect state.\n\n        Returns:\n            bool: Whether to disconnect on application exit\n        \"\"\"\n        return self._auto_disconnect\n\n    @auto_disconnect.setter\n    def auto_disconnect(self, value: bool):\n        \"\"\"Setter for auto disconnect.\n\n        Args:\n            value (bool): Whether to disconnect on application exit\n        \"\"\"\n        self._auto_disconnect = value\n        if value:\n            atexit.register(self.disconnect)\n        else:\n            atexit.unregister(self.disconnect)\n\n    def send(self, data: str):\n        \"\"\"Null implementation of the send method\n\n        Args:\n            data (str): Data to send nowhere\n\n        Raises:\n            NotImplementedError: Always raised\n        \"\"\"\n        msg = f\"Function not implemented, attempting to send {data}\"\n        raise NotImplementedError(msg)\n\n    def request_enable(self) -&gt; int:\n        \"\"\"Request the core to enable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.send(\"kevinbot.tryenable=1\")\n        return 1\n\n    def request_disable(self) -&gt; int:\n        \"\"\"Request the core to disable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.send(\"kevinbot.tryenable=0\")\n        return 1\n\n    def e_stop(self):\n        \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n        self.send(\"system.estop\")\n\n    def _register_component(self, component: BaseKevinbotSubsystem):\n        self._subsystems.append(component)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.auto_disconnect","title":"<code>auto_disconnect: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for auto disconnect state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to disconnect on application exit</p>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.get_state","title":"<code>get_state()</code>","text":"<p>Gets the current state of the robot</p> <p>Returns:</p> Name Type Description <code>KevinbotState</code> <code>KevinbotState</code> <p>State class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_state(self) -&gt; KevinbotState:\n    \"\"\"Gets the current state of the robot\n\n    Returns:\n        KevinbotState: State class\n    \"\"\"\n    return self._state\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Basic robot disconnect</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Basic robot disconnect\"\"\"\n    self._state.connected = False\n    self.send(\"core.link.unlink\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.send","title":"<code>send(data)</code>","text":"<p>Null implementation of the send method</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send nowhere</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Null implementation of the send method\n\n    Args:\n        data (str): Data to send nowhere\n\n    Raises:\n        NotImplementedError: Always raised\n    \"\"\"\n    msg = f\"Function not implemented, attempting to send {data}\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.request_enable","title":"<code>request_enable()</code>","text":"<p>Request the core to enable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_enable(self) -&gt; int:\n    \"\"\"Request the core to enable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.send(\"kevinbot.tryenable=1\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.request_disable","title":"<code>request_disable()</code>","text":"<p>Request the core to disable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_disable(self) -&gt; int:\n    \"\"\"Request the core to disable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.send(\"kevinbot.tryenable=0\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.e_stop","title":"<code>e_stop()</code>","text":"<p>Attempt to send and E-Stop signal to the Core</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def e_stop(self):\n    \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n    self.send(\"system.estop\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot","title":"<code>SerialKevinbot</code>","text":"<p>               Bases: <code>BaseKevinbot</code></p> <p>The main serial robot class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class SerialKevinbot(BaseKevinbot):\n    \"\"\"The main serial robot class\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n        self.serial: Serial | None = None\n        self.rx_thread: Thread | None = None\n\n    def connect(\n        self,\n        port: str,\n        baud: int,\n        timeout: float,\n        tick_interval: float,\n        ser_timeout: float = 0.5,\n        *,\n        tick_thread: bool = True,\n    ):\n        \"\"\"Start a connection with Kevinbot Core\n\n        Args:\n            port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n            baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n            timeout (float): Timeout for handshake\n            tick_interval (float): How often a heartbeat should be produced\n            ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n            tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n        Raises:\n            HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n        \"\"\"\n        serial = self._setup_serial(port, baud, ser_timeout)\n\n        start_time = time.monotonic()\n        while True:\n            serial.write(b\"connection.isready=0\\n\")\n\n            line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n            if line == \"ready\":\n                serial.write(b\"connection.start\\n\")\n                serial.write(b\"core.errors.clear\\n\")\n                serial.write(b\"connection.ok\\n\")\n                break\n\n            if time.monotonic() - start_time &gt; timeout:\n                msg = \"Handshake timed out\"\n                raise HandshakeTimeoutException(msg)\n\n            time.sleep(0.1)  # Avoid spamming the connection\n\n        # Data rx thread\n        self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n        self.rx_thread.name = \"KevinbotLib.Rx\"\n        self.rx_thread.start()\n\n        if tick_thread:\n            thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n            thread.start()\n            thread.name = \"KevinbotLib.Tick\"\n\n        self._state.connected = True\n\n    def disconnect(self):\n        \"\"\"Disconnect core gracefully\"\"\"\n        super().disconnect()\n        if self.serial and self.serial.is_open:\n            self.serial.flush()\n            self.serial.close()\n        else:\n            logger.warning(\"Already disconnected\")\n\n    def tick_loop(self, interval: float = 1):\n        \"\"\"Send ticks indefinetely\n\n        Args:\n            interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n        \"\"\"\n        while True:\n            self._tick()\n            time.sleep(interval)\n\n    def send(self, data: str):\n        \"\"\"Send a string through serial.\n\n        Automatically adds a newline.\n\n        Args:\n            data (str): Data to send\n        \"\"\"\n        self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n\n    def raw_tx(self, data: bytes):\n        \"\"\"Send raw bytes over serial.\n\n        Args:\n            data (bytes): Raw data\n        \"\"\"\n        if self.serial:\n            self.serial.write(data)\n        else:\n            logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n\n    def _rx_loop(self, serial: Serial, delimeter: str = \"=\"):\n        while True:\n            try:\n                raw: bytes = serial.readline()\n            except TypeError:\n                # serial has been stopped\n                return\n\n            cmd: str = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[0]\n\n            val: str | None = None\n            if len(raw.decode(\"utf-8\").split(delimeter)) &gt; 1:\n                val = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[1].strip(\"\\r\\n\")\n\n            match cmd:\n                case \"ready\\n\":\n                    pass\n                case \"core.enabled\":\n                    if not val:\n                        logger.warning(\"No value recieved for 'core.enabled'\")\n                        continue\n                    if val.lower() in [\"true\", \"t\", \"1\"]:\n                        self._state.enabled = True\n                    else:\n                        self._state.enabled = False\n                case \"core.uptime\":\n                    if val:\n                        self._state.uptime = int(val)\n                case \"core.uptime_ms\":\n                    if val:\n                        self._state.uptime_ms = int(val)\n                case \"motors.amps\":\n                    if val:\n                        self._state.motion.amps = list(map(float, val.split(\",\")))\n                case \"motors.watts\":\n                    if val:\n                        self._state.motion.watts = list(map(float, val.split(\",\")))\n                case \"motors.status\":\n                    if val:\n                        self._state.motion.status = [MotorDriveStatus(int(x)) for x in val.split(\",\")]\n                case \"bms.voltages\":\n                    if val:\n                        self._state.battery.voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.raw_voltages\":\n                    if val:\n                        self._state.battery.raw_voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.status\":\n                    if val:\n                        self._state.battery.states = [BmsBatteryState(int(x)) for x in val.split(\",\")]\n                case \"sensors.gyro\":\n                    if val:\n                        self._state.imu.gyro = [int(x) for x in val.split(\",\")]\n                case \"sensors.accel\":\n                    if val:\n                        self._state.imu.accel = [int(x) for x in val.split(\",\")]\n                case \"sensors.temps\":\n                    if val:\n                        temps = val.split(\",\")\n                        valid = True\n                        for temp in temps:\n                            if not re.match(\"^[-+]?[0-9]+$\", temp):\n                                logger.error(f\"Found non-integer value in temps, {temps}\")\n                                valid = False\n                                break\n                        if valid:\n                            self._state.thermal.left_motor = Temperature(int(temps[0]) / 100)\n                            self._state.thermal.right_motor = Temperature(int(temps[1]) / 100)\n                            self._state.thermal.internal = Temperature(int(temps[2]) / 100)\n                case \"sensors.bme\":\n                    if val:\n                        vals = val.split(\",\")\n                        for value in vals:\n                            if not re.match(\"^[-+]?[0-9]+$\", value):\n                                logger.error(f\"Found non-integer value in bme values, {temps}\")\n                                continue\n\n                        self._state.enviro.temperature = Temperature(int(vals[0]))\n                        self._state.enviro.humidity = int(vals[2])\n                        self._state.enviro.pressure = int(vals[3])\n                case _:\n                    logger.warning(f\"Got a command that isn't supported yet: {cmd} with value {val}\")\n\n    def _setup_serial(self, port: str, baud: int, timeout: float = 1):\n        self.serial = Serial(port, baud, timeout=timeout)\n        return self.serial\n\n    def _tick(self):\n        if self.serial and self.serial.is_open:\n            self.serial.write(b\"core.tick\\n\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.connect","title":"<code>connect(port, baud, timeout, tick_interval, ser_timeout=0.5, *, tick_thread=True)</code>","text":"<p>Start a connection with Kevinbot Core</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port to use (<code>/dev/ttyAMA2</code> is standard with the typical Kevinbot Hardware)</p> required <code>baud</code> <code>int</code> <p>Baud rate to use (<code>921600</code> is typical for the defualt Core configs)</p> required <code>timeout</code> <code>float</code> <p>Timeout for handshake</p> required <code>tick_interval</code> <code>float</code> <p>How often a heartbeat should be produced</p> required <code>ser_timeout</code> <code>float</code> <p>Readline timeout, should be lower than <code>timeout</code>. Defaults to 0.5.</p> <code>0.5</code> <code>tick_thread</code> <code>bool</code> <p>Whether a tick thread should be started. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>HandshakeTimeoutException</code> <p>Core didn't respond to the connection handshake before the timeout</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def connect(\n    self,\n    port: str,\n    baud: int,\n    timeout: float,\n    tick_interval: float,\n    ser_timeout: float = 0.5,\n    *,\n    tick_thread: bool = True,\n):\n    \"\"\"Start a connection with Kevinbot Core\n\n    Args:\n        port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n        baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n        timeout (float): Timeout for handshake\n        tick_interval (float): How often a heartbeat should be produced\n        ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n        tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n    Raises:\n        HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n    \"\"\"\n    serial = self._setup_serial(port, baud, ser_timeout)\n\n    start_time = time.monotonic()\n    while True:\n        serial.write(b\"connection.isready=0\\n\")\n\n        line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n        if line == \"ready\":\n            serial.write(b\"connection.start\\n\")\n            serial.write(b\"core.errors.clear\\n\")\n            serial.write(b\"connection.ok\\n\")\n            break\n\n        if time.monotonic() - start_time &gt; timeout:\n            msg = \"Handshake timed out\"\n            raise HandshakeTimeoutException(msg)\n\n        time.sleep(0.1)  # Avoid spamming the connection\n\n    # Data rx thread\n    self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n    self.rx_thread.name = \"KevinbotLib.Rx\"\n    self.rx_thread.start()\n\n    if tick_thread:\n        thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n        thread.start()\n        thread.name = \"KevinbotLib.Tick\"\n\n    self._state.connected = True\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect core gracefully</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect core gracefully\"\"\"\n    super().disconnect()\n    if self.serial and self.serial.is_open:\n        self.serial.flush()\n        self.serial.close()\n    else:\n        logger.warning(\"Already disconnected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.tick_loop","title":"<code>tick_loop(interval=1)</code>","text":"<p>Send ticks indefinetely</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>Interval between ticks in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def tick_loop(self, interval: float = 1):\n    \"\"\"Send ticks indefinetely\n\n    Args:\n        interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n    \"\"\"\n    while True:\n        self._tick()\n        time.sleep(interval)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.send","title":"<code>send(data)</code>","text":"<p>Send a string through serial.</p> <p>Automatically adds a newline.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Send a string through serial.\n\n    Automatically adds a newline.\n\n    Args:\n        data (str): Data to send\n    \"\"\"\n    self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.raw_tx","title":"<code>raw_tx(data)</code>","text":"<p>Send raw bytes over serial.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw data</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def raw_tx(self, data: bytes):\n    \"\"\"Send raw bytes over serial.\n\n    Args:\n        data (bytes): Raw data\n    \"\"\"\n    if self.serial:\n        self.serial.write(data)\n    else:\n        logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot","title":"<code>MqttKevinbot</code>","text":"<p>               Bases: <code>BaseKevinbot</code></p> <p>KevinbotLib interface over MQTT</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class MqttKevinbot(BaseKevinbot):\n    \"\"\"KevinbotLib interface over MQTT\"\"\"\n\n    def __init__(self, cid: str | None = None) -&gt; None:\n        \"\"\"Instansiate a new KevinbotLib interface over MQTT\n\n        Args:\n            cid (str | None, optional): MQTT Client id. Defaults to an auto-generated uuid.\n        \"\"\"\n        super().__init__()\n\n        self.root_topic = \"kevinbot\"\n        self.host = \"localhost\"\n        self.port = 1883\n        self.keepalive = 60\n\n        self.cid = cid if cid else f\"kevinbotlib-{shortuuid.random()}\"\n        self.client = Client(CallbackAPIVersion.VERSION2, self.cid)\n        self.client.loop_start()\n\n    def connect(\n        self, root_topic: str = \"kevinbot\", host: str = \"localhost\", port: int = 1883, keepalive: int = 60\n    ) -&gt; MQTTErrorCode:\n        \"\"\"Connect to MQTT Broker\n\n        Args:\n            root_topic (str, optional): Root communication topic. Defaults to \"kevinbot\".\n            host (str, optional): KevinbotLib server host. Defaults to \"localhost\".\n            port (int, optional): Kevinbot MQTT Broker port. Defaults to 1883.\n            keepalive (int, optional): Maximum period in seconds between communications with the broker. Defaults to 60.\n\n        Returns:\n            MQTTErrorCode: Connection error\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.keepalive = keepalive\n        self.root_topic = root_topic\n\n        return self.client.connect(self.host, self.port, self.keepalive)\n\n\n    def send(self, data: str):\n        \"\"\"Determine topic and publish data. Compatible with send of `SerialKevinbot`\n\n        Args:\n            data (str): Data to parse and publish\n        \"\"\"\n        cmd, val = data.split(\"=\", 2)\n\n        match cmd:\n            case \"kevinbot.tryenable\": qos = 1\n            case \"system.estop\": qos = 1\n            case _: qos = 0\n\n        self.client.publish(f\"{self.root_topic}/{cmd.replace('.', '/')}/cmd\", val, qos)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.__init__","title":"<code>__init__(cid=None)</code>","text":"<p>Instansiate a new KevinbotLib interface over MQTT</p> <p>Parameters:</p> Name Type Description Default <code>cid</code> <code>str | None</code> <p>MQTT Client id. Defaults to an auto-generated uuid.</p> <code>None</code> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def __init__(self, cid: str | None = None) -&gt; None:\n    \"\"\"Instansiate a new KevinbotLib interface over MQTT\n\n    Args:\n        cid (str | None, optional): MQTT Client id. Defaults to an auto-generated uuid.\n    \"\"\"\n    super().__init__()\n\n    self.root_topic = \"kevinbot\"\n    self.host = \"localhost\"\n    self.port = 1883\n    self.keepalive = 60\n\n    self.cid = cid if cid else f\"kevinbotlib-{shortuuid.random()}\"\n    self.client = Client(CallbackAPIVersion.VERSION2, self.cid)\n    self.client.loop_start()\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.connect","title":"<code>connect(root_topic='kevinbot', host='localhost', port=1883, keepalive=60)</code>","text":"<p>Connect to MQTT Broker</p> <p>Parameters:</p> Name Type Description Default <code>root_topic</code> <code>str</code> <p>Root communication topic. Defaults to \"kevinbot\".</p> <code>'kevinbot'</code> <code>host</code> <code>str</code> <p>KevinbotLib server host. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Kevinbot MQTT Broker port. Defaults to 1883.</p> <code>1883</code> <code>keepalive</code> <code>int</code> <p>Maximum period in seconds between communications with the broker. Defaults to 60.</p> <code>60</code> <p>Returns:</p> Name Type Description <code>MQTTErrorCode</code> <code>MQTTErrorCode</code> <p>Connection error</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def connect(\n    self, root_topic: str = \"kevinbot\", host: str = \"localhost\", port: int = 1883, keepalive: int = 60\n) -&gt; MQTTErrorCode:\n    \"\"\"Connect to MQTT Broker\n\n    Args:\n        root_topic (str, optional): Root communication topic. Defaults to \"kevinbot\".\n        host (str, optional): KevinbotLib server host. Defaults to \"localhost\".\n        port (int, optional): Kevinbot MQTT Broker port. Defaults to 1883.\n        keepalive (int, optional): Maximum period in seconds between communications with the broker. Defaults to 60.\n\n    Returns:\n        MQTTErrorCode: Connection error\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.keepalive = keepalive\n    self.root_topic = root_topic\n\n    return self.client.connect(self.host, self.port, self.keepalive)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.send","title":"<code>send(data)</code>","text":"<p>Determine topic and publish data. Compatible with send of <code>SerialKevinbot</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to parse and publish</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Determine topic and publish data. Compatible with send of `SerialKevinbot`\n\n    Args:\n        data (str): Data to parse and publish\n    \"\"\"\n    cmd, val = data.split(\"=\", 2)\n\n    match cmd:\n        case \"kevinbot.tryenable\": qos = 1\n        case \"system.estop\": qos = 1\n        case _: qos = 0\n\n    self.client.publish(f\"{self.root_topic}/{cmd.replace('.', '/')}/cmd\", val, qos)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase","title":"<code>Drivebase</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Drivebase subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Drivebase(BaseKevinbotSubsystem):\n    \"\"\"Drivebase subsystem for Kevinbot\"\"\"\n\n    def get_amps(self) -&gt; list[float]:\n        \"\"\"Get the amps being used by the drivebase\n\n        Returns:\n            list[float]: Amps\n        \"\"\"\n        return self.robot.get_state().motion.amps\n\n    def get_watts(self) -&gt; list[float]:\n        \"\"\"Get the watts being used by the drivebase\n\n        Returns:\n            list[float]: Watts\n        \"\"\"\n        return self.robot.get_state().motion.watts\n\n    def get_powers(self) -&gt; tuple[int, int]:\n        \"\"\"Get the currently set wheel speeds in percent\n\n        Returns:\n            tuple[int, int]: Percent values from 0 to 100\n        \"\"\"\n        return self.robot.get_state().motion.left_power, self.robot.get_state().motion.right_power\n\n    def get_states(self) -&gt; list[MotorDriveStatus]:\n        \"\"\"Get the wheels states\n\n        Returns:\n            list[MotorDriveStatus]: States\n        \"\"\"\n        return self.robot.get_state().motion.status\n\n    def drive_at_power(self, left: float, right: float):\n        \"\"\"Set the drive power for wheels. 0 to 1\n\n        Args:\n            left (float): Left motor power\n            right (float): Right motor power\n        \"\"\"\n        self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n\n    def stop(self):\n        \"\"\"Set all wheel powers to 0\"\"\"\n        self.robot.send(\"drive.stop\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_amps","title":"<code>get_amps()</code>","text":"<p>Get the amps being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Amps</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_amps(self) -&gt; list[float]:\n    \"\"\"Get the amps being used by the drivebase\n\n    Returns:\n        list[float]: Amps\n    \"\"\"\n    return self.robot.get_state().motion.amps\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_watts","title":"<code>get_watts()</code>","text":"<p>Get the watts being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Watts</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_watts(self) -&gt; list[float]:\n    \"\"\"Get the watts being used by the drivebase\n\n    Returns:\n        list[float]: Watts\n    \"\"\"\n    return self.robot.get_state().motion.watts\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_powers","title":"<code>get_powers()</code>","text":"<p>Get the currently set wheel speeds in percent</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: Percent values from 0 to 100</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_powers(self) -&gt; tuple[int, int]:\n    \"\"\"Get the currently set wheel speeds in percent\n\n    Returns:\n        tuple[int, int]: Percent values from 0 to 100\n    \"\"\"\n    return self.robot.get_state().motion.left_power, self.robot.get_state().motion.right_power\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_states","title":"<code>get_states()</code>","text":"<p>Get the wheels states</p> <p>Returns:</p> Type Description <code>list[MotorDriveStatus]</code> <p>list[MotorDriveStatus]: States</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_states(self) -&gt; list[MotorDriveStatus]:\n    \"\"\"Get the wheels states\n\n    Returns:\n        list[MotorDriveStatus]: States\n    \"\"\"\n    return self.robot.get_state().motion.status\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.drive_at_power","title":"<code>drive_at_power(left, right)</code>","text":"<p>Set the drive power for wheels. 0 to 1</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>float</code> <p>Left motor power</p> required <code>right</code> <code>float</code> <p>Right motor power</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def drive_at_power(self, left: float, right: float):\n    \"\"\"Set the drive power for wheels. 0 to 1\n\n    Args:\n        left (float): Left motor power\n        right (float): Right motor power\n    \"\"\"\n    self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.stop","title":"<code>stop()</code>","text":"<p>Set all wheel powers to 0</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def stop(self):\n    \"\"\"Set all wheel powers to 0\"\"\"\n    self.robot.send(\"drive.stop\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servo","title":"<code>Servo</code>","text":"<p>Individually controllable servo</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Servo:\n    \"\"\"Individually controllable servo\"\"\"\n\n    def __init__(self, robot: SerialKevinbot, index: int) -&gt; None:\n        self.robot = robot\n        self.index = index\n\n    @property\n    def bank(self) -&gt; int:\n        \"\"\"Get the bank the servo is in\n\n        Returns:\n            int: Bank number\n        \"\"\"\n        return self.index // 16\n\n    @property\n    def angle(self) -&gt; int:\n        \"\"\"Get the optimistic current servo angle\n\n        Returns:\n            int: Angle in degrees\n        \"\"\"\n        return self.robot.get_state().servos.angles[self.index]\n\n    @angle.setter\n    def angle(self, angle: int):\n        \"\"\"Set the optimistic servo angle\n\n        Args:\n            angle (int): Angle in degrees\n        \"\"\"\n        self.robot.send(f\"s={self.index},{angle}\")\n        self.robot.get_state().servos.angles[self.index] = angle\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servo.bank","title":"<code>bank: int</code>  <code>property</code>","text":"<p>Get the bank the servo is in</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Bank number</p>"},{"location":"reference/#kevinbotlib.core.Servo.angle","title":"<code>angle: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the optimistic current servo angle</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Angle in degrees</p>"},{"location":"reference/#kevinbotlib.core.Servos","title":"<code>Servos</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Servo subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Servos(BaseKevinbotSubsystem):\n    \"\"\"Servo subsystem for Kevinbot\"\"\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"Length will always be 32 since the P2 Kevinbot Board can only control 32\n\n        Returns:\n            int: Number of servos in the subsystem\n        \"\"\"\n        return 32\n\n    def __iter__(self):\n        for i in range(self.__len__()):\n            yield Servo(self.robot, i)\n\n    def __getitem__(self, index: int):\n        if index &gt; self.__len__():\n            msg = f\"Servo index {index} &gt; {self.__len__()}\"\n            raise IndexError(msg)\n        if index &lt; 0:\n            msg = f\"Servo index {index} &lt; 0\"\n            raise IndexError(msg)\n        return Servo(self.robot, index)\n\n    def get_servo(self, channel: int) -&gt; Servo:\n        \"\"\"Get an individual servo in the subsystem\n\n        Args:\n            channel (int): PWM Port\n\n        Returns:\n            Servo: Individual servo\n        \"\"\"\n        if channel &gt; self.__len__() or channel &lt; 0:\n            msg = f\"Servo channel {channel} is out of bounds.\"\n            raise IndexError(msg)\n        return Servo(self.robot, channel)\n\n    @property\n    def all(self) -&gt; int:\n        if all(i == self.robot.get_state().servos.angles[0] for i in self.robot.get_state().servos.angles):\n            return self.robot.get_state().servos.angles[0]\n        return -1\n\n    @all.setter\n    def all(self, angle: int):\n        self.robot.send(f\"servo.all={angle}\")\n        self.robot.get_state().servos.angles = [angle] * self.__len__()\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servos.__len__","title":"<code>__len__()</code>","text":"<p>Length will always be 32 since the P2 Kevinbot Board can only control 32</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of servos in the subsystem</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Length will always be 32 since the P2 Kevinbot Board can only control 32\n\n    Returns:\n        int: Number of servos in the subsystem\n    \"\"\"\n    return 32\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servos.get_servo","title":"<code>get_servo(channel)</code>","text":"<p>Get an individual servo in the subsystem</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>PWM Port</p> required <p>Returns:</p> Name Type Description <code>Servo</code> <code>Servo</code> <p>Individual servo</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_servo(self, channel: int) -&gt; Servo:\n    \"\"\"Get an individual servo in the subsystem\n\n    Args:\n        channel (int): PWM Port\n\n    Returns:\n        Servo: Individual servo\n    \"\"\"\n    if channel &gt; self.__len__() or channel &lt; 0:\n        msg = f\"Servo channel {channel} is out of bounds.\"\n        raise IndexError(msg)\n    return Servo(self.robot, channel)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting","title":"<code>Lighting</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Lighting subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Lighting(BaseKevinbotSubsystem):\n    \"\"\"Lighting subsystem for Kevinbot\"\"\"\n\n    class Channel(Enum):\n        \"\"\"Lighting segment identifier\"\"\"\n\n        Head = \"head\"\n        Body = \"body\"\n        Base = \"base\"\n\n    def get_state(self) -&gt; LightingState:\n        \"\"\"Get the state of the robot's light segments\n\n        Returns:\n            LightingState: State\n        \"\"\"\n        return self.robot.get_state().lighting\n\n    def set_cam_brightness(self, brightness: int):\n        \"\"\"Set brightness of camera illumination\n\n        Args:\n            brightness (int): Brightness from 0 to 255\n        \"\"\"\n        self.robot.send(f\"lighting.cam.bright={brightness}\")\n        self.robot.get_state().lighting.camera = brightness\n\n    def set_brightness(self, channel: Channel, brightness: int):\n        \"\"\"Set the brightness of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            brightness (int): Brightness from 0 to 255\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.bright={brightness}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_bright = brightness\n            case self.Channel.Body:\n                self.robot.get_state().lighting.body_bright = brightness\n            case self.Channel.Head:\n                self.robot.get_state().lighting.head_bright = brightness\n\n    def set_color1(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n        \"\"\"Set the Color 1 of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            color (Iterable[int]): RGB Color values. Must have a length of 3\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.color1={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_color1 = color\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_color1 = color\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_color1 = color\n\n    def set_color2(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n        \"\"\"Set the Color 2 of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            color (Iterable[int]): RGB Color values. Must have a length of 3\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.color2={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_color2 = color\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_color2 = color\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_color2 = color\n\n    def set_effect(self, channel: Channel, effect: str):\n        \"\"\"Set the animation of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            effect (str): Animation ID\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.effect={effect}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_effect = effect\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_effect = effect\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_effect = effect\n\n    def set_update(self, channel: Channel, update: int):\n        \"\"\"Set the animation of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            update (int): Update rate (no fixed unit)\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.update={update}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_update = update\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_update = update\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_update = update\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Lighting segment identifier</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Channel(Enum):\n    \"\"\"Lighting segment identifier\"\"\"\n\n    Head = \"head\"\n    Body = \"body\"\n    Base = \"base\"\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.get_state","title":"<code>get_state()</code>","text":"<p>Get the state of the robot's light segments</p> <p>Returns:</p> Name Type Description <code>LightingState</code> <code>LightingState</code> <p>State</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_state(self) -&gt; LightingState:\n    \"\"\"Get the state of the robot's light segments\n\n    Returns:\n        LightingState: State\n    \"\"\"\n    return self.robot.get_state().lighting\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_cam_brightness","title":"<code>set_cam_brightness(brightness)</code>","text":"<p>Set brightness of camera illumination</p> <p>Parameters:</p> Name Type Description Default <code>brightness</code> <code>int</code> <p>Brightness from 0 to 255</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_cam_brightness(self, brightness: int):\n    \"\"\"Set brightness of camera illumination\n\n    Args:\n        brightness (int): Brightness from 0 to 255\n    \"\"\"\n    self.robot.send(f\"lighting.cam.bright={brightness}\")\n    self.robot.get_state().lighting.camera = brightness\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_brightness","title":"<code>set_brightness(channel, brightness)</code>","text":"<p>Set the brightness of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>brightness</code> <code>int</code> <p>Brightness from 0 to 255</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_brightness(self, channel: Channel, brightness: int):\n    \"\"\"Set the brightness of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        brightness (int): Brightness from 0 to 255\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.bright={brightness}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_bright = brightness\n        case self.Channel.Body:\n            self.robot.get_state().lighting.body_bright = brightness\n        case self.Channel.Head:\n            self.robot.get_state().lighting.head_bright = brightness\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_color1","title":"<code>set_color1(channel, color)</code>","text":"<p>Set the Color 1 of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>color</code> <code>Iterable[int]</code> <p>RGB Color values. Must have a length of 3</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_color1(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n    \"\"\"Set the Color 1 of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        color (Iterable[int]): RGB Color values. Must have a length of 3\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.color1={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_color1 = color\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_color1 = color\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_color1 = color\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_color2","title":"<code>set_color2(channel, color)</code>","text":"<p>Set the Color 2 of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>color</code> <code>Iterable[int]</code> <p>RGB Color values. Must have a length of 3</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_color2(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n    \"\"\"Set the Color 2 of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        color (Iterable[int]): RGB Color values. Must have a length of 3\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.color2={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_color2 = color\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_color2 = color\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_color2 = color\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_effect","title":"<code>set_effect(channel, effect)</code>","text":"<p>Set the animation of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>effect</code> <code>str</code> <p>Animation ID</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_effect(self, channel: Channel, effect: str):\n    \"\"\"Set the animation of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        effect (str): Animation ID\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.effect={effect}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_effect = effect\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_effect = effect\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_effect = effect\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_update","title":"<code>set_update(channel, update)</code>","text":"<p>Set the animation of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>update</code> <code>int</code> <p>Update rate (no fixed unit)</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_update(self, channel: Channel, update: int):\n    \"\"\"Set the animation of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        update (int): Update rate (no fixed unit)\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.update={update}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_update = update\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_update = update\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_update = update\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio","title":"<code>WirelessRadio</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>class WirelessRadio(BaseKevinbotSubsystem):\n    def __init__(self, robot: SerialKevinbot, port: str, baud: int, api: int, timeout: float) -&gt; None:\n        \"\"\"Initialize Kevinbot Wireless Radio (XBee)\n\n        Args:\n            robot (Kevinbot): The main robot class\n            port (str): Serial port to connect to `/dev/ttyAMA0` for typical Kevinbot hardware\n            baud (int): Baud rate for serial interface `921600` for typical Kevinbot configs\n            api (int): API mode for xbee interface `2` for typical Kevinbot configs (`0` isn't supported yet)\n            timeout (float): Timeout for serial operations\n        \"\"\"\n        super().__init__(robot)\n\n        if api not in [1, 2]:\n            logger.error(f\"XBee API Mode {api} isn't supported. Assuming API escaped (2)\")\n            api = 2\n\n        self.callback: Callable | None = None\n\n        self.serial = Serial(port, baud, timeout=timeout)\n        self.xbee = xbee.XBee(self.serial, callback=self.callback)\n\n    def get(self) -&gt; dict:\n        \"\"\"Get the latest packet (blocking)\n\n        Returns:\n            dict: Data packet\n        \"\"\"\n        return self.xbee.wait_read_frame()\n\n    def disconnect(self):\n        \"\"\"Disconnect robot radio, and halt processing\"\"\"\n        self.xbee.halt()\n        self.serial.close()\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio.__init__","title":"<code>__init__(robot, port, baud, api, timeout)</code>","text":"<p>Initialize Kevinbot Wireless Radio (XBee)</p> <p>Parameters:</p> Name Type Description Default <code>robot</code> <code>Kevinbot</code> <p>The main robot class</p> required <code>port</code> <code>str</code> <p>Serial port to connect to <code>/dev/ttyAMA0</code> for typical Kevinbot hardware</p> required <code>baud</code> <code>int</code> <p>Baud rate for serial interface <code>921600</code> for typical Kevinbot configs</p> required <code>api</code> <code>int</code> <p>API mode for xbee interface <code>2</code> for typical Kevinbot configs (<code>0</code> isn't supported yet)</p> required <code>timeout</code> <code>float</code> <p>Timeout for serial operations</p> required Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>def __init__(self, robot: SerialKevinbot, port: str, baud: int, api: int, timeout: float) -&gt; None:\n    \"\"\"Initialize Kevinbot Wireless Radio (XBee)\n\n    Args:\n        robot (Kevinbot): The main robot class\n        port (str): Serial port to connect to `/dev/ttyAMA0` for typical Kevinbot hardware\n        baud (int): Baud rate for serial interface `921600` for typical Kevinbot configs\n        api (int): API mode for xbee interface `2` for typical Kevinbot configs (`0` isn't supported yet)\n        timeout (float): Timeout for serial operations\n    \"\"\"\n    super().__init__(robot)\n\n    if api not in [1, 2]:\n        logger.error(f\"XBee API Mode {api} isn't supported. Assuming API escaped (2)\")\n        api = 2\n\n    self.callback: Callable | None = None\n\n    self.serial = Serial(port, baud, timeout=timeout)\n    self.xbee = xbee.XBee(self.serial, callback=self.callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio.get","title":"<code>get()</code>","text":"<p>Get the latest packet (blocking)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Data packet</p> Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>def get(self) -&gt; dict:\n    \"\"\"Get the latest packet (blocking)\n\n    Returns:\n        dict: Data packet\n    \"\"\"\n    return self.xbee.wait_read_frame()\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect robot radio, and halt processing</p> Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect robot radio, and halt processing\"\"\"\n    self.xbee.halt()\n    self.serial.close()\n</code></pre>"},{"location":"reference/#kevinbotlib.states.CoreErrors","title":"<code>CoreErrors</code>","text":"<p>               Bases: <code>Enum</code></p> <p>These are errors from Kevinbot Core</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class CoreErrors(Enum):\n    \"\"\"These are errors from Kevinbot Core\"\"\"\n\n    \"\"\"No errors are present\"\"\"\n    OK = 0\n    \"\"\"Error state unknown\"\"\"\n    UNKNOWN = 1\n    \"\"\"One-Wire bus is shorted\"\"\"\n    OW_SHORT = 2\n    \"\"\"One-Wire bus error\"\"\"\n    OW_ERROR = 3\n    \"\"\"One-Wire device not found\"\"\"\n    OW_DNF = 4\n    \"\"\"LCD Init failed\"\"\"\n    LCD_INIT_FAIL = 5\n    \"\"\"PCA9685 (servos) init fail\"\"\"\n    PCA_INIT_FAIL = 6\n    \"\"\"Failure to recieve core tick\"\"\"\n    TICK_FAIL = 7\n</code></pre>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error state unknown</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire bus is shorted</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OW_SHORT","title":"<code>OW_SHORT = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire bus error</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OW_ERROR","title":"<code>OW_ERROR = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire device not found</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OW_DNF","title":"<code>OW_DNF = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>LCD Init failed</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.LCD_INIT_FAIL","title":"<code>LCD_INIT_FAIL = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PCA9685 (servos) init fail</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.PCA_INIT_FAIL","title":"<code>PCA_INIT_FAIL = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Failure to recieve core tick</p>"},{"location":"reference/#kevinbotlib.states.MotorDriveStatus","title":"<code>MotorDriveStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of each motor in the drivebase</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class MotorDriveStatus(Enum):\n    \"\"\"The status of each motor in the drivebase\"\"\"\n\n    UNKNOWN = 10\n    MOVING = 11\n    HOLDING = 12\n    OFF = 13\n</code></pre>"},{"location":"reference/#kevinbotlib.states.BmsBatteryState","title":"<code>BmsBatteryState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of a single battery attached to the BMS</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class BmsBatteryState(Enum):\n    \"\"\"The status of a single battery attached to the BMS\"\"\"\n\n    UNKNOWN = 0\n    NORMAL = 1\n    UNDER = 2\n    OVER = 3\n    STOPPED = 4  # Stopped state if BMS driver crashed\n</code></pre>"},{"location":"reference/#kevinbotlib.states.DrivebaseState","title":"<code>DrivebaseState</code>  <code>dataclass</code>","text":"<p>The state of the drivebase as a whole</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass DrivebaseState:\n    \"\"\"The state of the drivebase as a whole\"\"\"\n\n    left_power: int = 0\n    right_power: int = 0\n    amps: list[float] = field(default_factory=lambda: [0, 0])\n    watts: list[float] = field(default_factory=lambda: [0, 0])\n    status: list[MotorDriveStatus] = field(default_factory=lambda: [MotorDriveStatus.UNKNOWN, MotorDriveStatus.UNKNOWN])\n</code></pre>"},{"location":"reference/#kevinbotlib.states.ServoState","title":"<code>ServoState</code>  <code>dataclass</code>","text":"<p>The state of the servo subsystem</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass ServoState:\n    \"\"\"The state of the servo subsystem\"\"\"\n\n    angles: list[int] = field(default_factory=lambda: [-1] * 32)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.BMState","title":"<code>BMState</code>  <code>dataclass</code>","text":"<p>The state of the BMS (Battery Management System)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass BMState:\n    \"\"\"The state of the BMS (Battery Management System)\"\"\"\n\n    voltages: list[float] = field(default_factory=lambda: [0.0, 0.0])\n    raw_voltages: list[float] = field(default_factory=lambda: [0.0, 0.0])\n    states: list[BmsBatteryState] = field(default_factory=lambda: [BmsBatteryState.UNKNOWN, BmsBatteryState.UNKNOWN])\n</code></pre>"},{"location":"reference/#kevinbotlib.states.IMUState","title":"<code>IMUState</code>  <code>dataclass</code>","text":"<p>The state of the IMU (Inertial Measurement System)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass IMUState:\n    \"\"\"The state of the IMU (Inertial Measurement System)\"\"\"\n\n    accel: list[int] = field(default_factory=lambda: [-1] * 3)  # X Y Z\n    gyro: list[int] = field(default_factory=lambda: [-1] * 3)  # R P Y\n</code></pre>"},{"location":"reference/#kevinbotlib.states.ThermometerState","title":"<code>ThermometerState</code>  <code>dataclass</code>","text":"<p>The state of the DS18B20 Thermometers (does not include BME280)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass ThermometerState:\n    \"\"\"The state of the DS18B20 Thermometers (does not include BME280)\"\"\"\n\n    left_motor: Temperature = field(default_factory=lambda: Temperature(-1))\n    right_motor: Temperature = field(default_factory=lambda: Temperature(-1))\n    internal: Temperature = field(default_factory=lambda: Temperature(-1))\n</code></pre>"},{"location":"reference/#kevinbotlib.states.EnviroState","title":"<code>EnviroState</code>  <code>dataclass</code>","text":"<p>The state of the BME280 Envoronmental sensor</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass EnviroState:\n    \"\"\"The state of the BME280 Envoronmental sensor\"\"\"\n\n    temperature: Temperature = field(default_factory=lambda: Temperature(-1))\n    humidity: float = 0\n    pressure: int = 0\n</code></pre>"},{"location":"reference/#kevinbotlib.states.LightingState","title":"<code>LightingState</code>  <code>dataclass</code>","text":"<p>The state of Kevinbot's led segments</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass LightingState:\n    \"\"\"The state of Kevinbot's led segments\"\"\"\n\n    camera: int = 0\n    head_effect: str = \"unknown\"\n    head_bright: int = 0\n    head_update: int = -1\n    head_color1: Iterable[int] = (0, 0, 0)\n    head_color2: Iterable[int] = (0, 0, 0)\n    body_effect: str = \"unknown\"\n    body_bright: int = 0\n    body_update: int = -1\n    body_color1: Iterable[int] = (0, 0, 0)\n    body_color2: Iterable[int] = (0, 0, 0)\n    base_effect: str = \"unknown\"\n    base_bright: int = 0\n    base_update: int = -1\n    base_color1: Iterable[int] = (0, 0, 0)\n    base_color2: Iterable[int] = (0, 0, 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.KevinbotState","title":"<code>KevinbotState</code>  <code>dataclass</code>","text":"<p>The state of the robot as a whole</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass KevinbotState:\n    \"\"\"The state of the robot as a whole\"\"\"\n\n    connected: bool = False\n    enabled: bool = False\n    error: CoreErrors = CoreErrors.OK\n    uptime: int = 0\n    uptime_ms: int = 0\n    motion: DrivebaseState = field(default_factory=DrivebaseState)\n    servos: ServoState = field(default_factory=ServoState)\n    battery: BMState = field(default_factory=BMState)\n    imu: IMUState = field(default_factory=IMUState)\n    thermal: ThermometerState = field(default_factory=ThermometerState)\n    enviro: EnviroState = field(default_factory=EnviroState)\n    lighting: LightingState = field(default_factory=LightingState)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.KevinbotServerState","title":"<code>KevinbotServerState</code>  <code>dataclass</code>","text":"<p>The state system used internally in the Kevinbot Server</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass KevinbotServerState:\n    \"\"\"The state system used internally in the Kevinbot Server\"\"\"\n\n    mqtt_connected: bool = False\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.HandshakeTimeoutException","title":"<code>HandshakeTimeoutException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when the connection handshake times out</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class HandshakeTimeoutException(BaseException):\n    \"\"\"Exception that is produced when the connection handshake times out\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.config.ConfigLocation","title":"<code>ConfigLocation</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum to represent the location of the config file</p> Source code in <code>src/kevinbotlib/config.py</code> <pre><code>class ConfigLocation(Enum):\n    \"\"\"Enum to represent the location of the config file\"\"\"\n\n    USER = \"user\"\n    SYSTEM = \"system\"\n    AUTO = \"auto\"\n    NONE = \"none\"\n    MANUAL = \"manual\"\n</code></pre>"},{"location":"reference/#kevinbotlib.config.KevinbotConfig","title":"<code>KevinbotConfig</code>","text":"Source code in <code>src/kevinbotlib/config.py</code> <pre><code>class KevinbotConfig:\n    def __init__(self, location: ConfigLocation = ConfigLocation.AUTO, path: str | Path | None = None):\n        self.config_location = location\n\n        self.user_config_path = Path(user_config_dir(\"kevinbotlib\")) / \"settings.yaml\"\n        self.system_config_path = Path(site_config_dir(\"kevinbotlib\")) / \"settings.yaml\"\n\n        self.manual_path: Path | None = None\n        if path:\n            self.manual_path = Path(path)\n\n        self.config_path = self._get_config_path()\n\n        self.config: dict = {}\n\n        self.mqtt: _MQTT = _MQTT({}, self)\n        self.core: _Core = _Core({}, self)\n        self.xbee: _XBee = _XBee({}, self)\n        self.server: _Server = _Server({}, self)\n\n        self.load()\n\n    def _get_config_path(self) -&gt; Path | None:\n        \"\"\"Get the optimal configuration path\n\n        Returns:\n            Path | None: File location\n        \"\"\"\n        if self.config_location == ConfigLocation.NONE:\n            return None\n        if self.config_location == ConfigLocation.MANUAL:\n            if self.manual_path:\n                return Path(self.manual_path)\n            logger.warning(\"ConfigLocation.MANUAL set without config path, defaulting to ConfigLocation.NONE\")\n            return None  # should never happen\n        if self.config_location == ConfigLocation.USER:\n            return self.user_config_path\n        if self.config_location == ConfigLocation.SYSTEM:\n            return self.system_config_path\n        # AUTO: Prefer user, else system, if none, return user\n        if self.user_config_path.exists():\n            return self.user_config_path\n        if self.system_config_path.exists():\n            return self.system_config_path\n        return self.user_config_path\n\n    def load(self) -&gt; None:\n        if self.config_path and self.config_path.exists():\n            with open(self.config_path) as file:\n                self.config = yaml.safe_load(file) or {}\n\n        self.mqtt = _MQTT(self.config.get(\"mqtt\", {}), self)\n        self.core = _Core(self.config.get(\"core\", {}), self)\n        self.xbee = _XBee(self.config.get(\"xbee\", {}), self)\n        self.server = _Server(self.config.get(\"server\", {}), self)\n\n    def save(self) -&gt; None:\n        if self.config_path:\n            with open(self.config_path, \"w\") as file:\n                yaml.dump(self._get_data(), file, default_flow_style=False)\n        else:\n            logger.error(\"Couldn't save configuration to empty path\")\n\n    def dump(self) -&gt; str:\n        \"\"\"Dump configuration\n\n        Returns:\n            str: YAML\n        \"\"\"\n        return yaml.dump(self._get_data(), default_flow_style=False)\n\n    def _get_data(self):\n        return {\n            \"mqtt\": self.mqtt.data,\n            \"core\": self.core.data,\n            \"xbee\": self.xbee.data,\n            \"server\": self.server.data,\n        }\n\n    def __repr__(self):\n        return f\"{super().__repr__()}\\n\\n{yaml.dump(self._get_data(), default_flow_style=False)}\"\n</code></pre>"},{"location":"reference/#kevinbotlib.config.KevinbotConfig.dump","title":"<code>dump()</code>","text":"<p>Dump configuration</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>YAML</p> Source code in <code>src/kevinbotlib/config.py</code> <pre><code>def dump(self) -&gt; str:\n    \"\"\"Dump configuration\n\n    Returns:\n        str: YAML\n    \"\"\"\n    return yaml.dump(self._get_data(), default_flow_style=False)\n</code></pre>"},{"location":"reference/#kevinbotlib.misc.Temperature","title":"<code>Temperature</code>","text":"<p>               Bases: <code>float</code></p> <p>Extended float class that can convert it's value from Celcius to Farenheit</p> Source code in <code>src/kevinbotlib/misc.py</code> <pre><code>class Temperature(float):\n    \"\"\"Extended float class that can convert it's value from Celcius to Farenheit\"\"\"\n\n    @property\n    def f(self) -&gt; float:\n        \"\"\"Convert value to Farenheit\n\n        Returns:\n            float: Value in F\n        \"\"\"\n        return self.__float__() * 1.8 + 32\n\n    @staticmethod\n    def from_f(f: float) -&gt; \"Temperature\":\n        \"\"\"Convert a Farenheit value to a Temperature object\n\n        Args:\n            f (float): Temp in Farenheit\n\n        Returns:\n            Temperature: Celcius, convertable\n        \"\"\"\n        return Temperature((f - 32) * 5 / 9)\n</code></pre>"},{"location":"reference/#kevinbotlib.misc.Temperature.f","title":"<code>f: float</code>  <code>property</code>","text":"<p>Convert value to Farenheit</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Value in F</p>"},{"location":"reference/#kevinbotlib.misc.Temperature.from_f","title":"<code>from_f(f)</code>  <code>staticmethod</code>","text":"<p>Convert a Farenheit value to a Temperature object</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Temp in Farenheit</p> required <p>Returns:</p> Name Type Description <code>Temperature</code> <code>Temperature</code> <p>Celcius, convertable</p> Source code in <code>src/kevinbotlib/misc.py</code> <pre><code>@staticmethod\ndef from_f(f: float) -&gt; \"Temperature\":\n    \"\"\"Convert a Farenheit value to a Temperature object\n\n    Args:\n        f (float): Temp in Farenheit\n\n    Returns:\n        Temperature: Celcius, convertable\n    \"\"\"\n    return Temperature((f - 32) * 5 / 9)\n</code></pre>"}]}