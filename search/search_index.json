{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KevinbotLib","text":"<p>KevinbotLib is a robot control system for Kevinbot v3 and the Kevinbot Core. You can easily and safely control Kevinbot's drivebase, servos, lighting, and more. It also continuously polls sensor data. It can operate in two modes: Direct Serial, and MQTT with the Kevinbot Server.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Multiple Control Interfaces</p> <ul> <li>Direct Serial mode</li> <li>MQTT networked mode (with KevinbotLib Server)</li> <li>XBee communication (planned)</li> </ul> </li> <li> <p>Comprehensive Subsystem Control</p> <ul> <li>Drivebase with power and state monitoring</li> <li>Servo control</li> <li>Multi-zone lighting system with effects</li> <li>Continuous sensor polling</li> <li>Battery management and monitoring</li> <li>IMU support (gyroscope and accelerometer)</li> </ul> </li> <li> <p>Developer-Friendly Design</p> <ul> <li>Simple MQTT API</li> <li>Extensive configuration options</li> <li>Real-time state tracking</li> <li>Built-in safety features</li> <li>Detailed logging and debugging</li> <li>Python 3.13 support</li> </ul> </li> <li> <p>Robust Architecture</p> <ul> <li>Thread-safe communication</li> <li>Event-based callback system</li> <li>Auto-reconnection handling</li> <li>Multiple client support via MQTT</li> </ul> </li> </ul> <p>Development</p> <p>This project is in the early stage of development. There are many missing functions that will be supported in the future.</p>"},{"location":"architecture/","title":"Architecture","text":"<pre><code>flowchart TD\n subgraph s1[\"KevinbotLib Server\"]\n        n5[\"KevinbotLib&lt;br&gt;Direct Serial\"]\n        n9[\"XBee Interface\"]\n  end\n    n3[\"MQTT API Mode\"] &lt;--&gt; n4[\"MQTT Broker\"]\n    n4 &lt;--&gt; s1\n    n5 --&gt; n6[\"Kevinbot&lt;br&gt;Hardware\"]\n    n2[\"Direct Serial\"] --&gt; n6\n    n9 &lt;--&gt; n5\n    n9 --&gt; n4\n    n10[\"OR\"] --&gt; n11[\"Direct Serial Mode&lt;br&gt;\"] &amp; n12[\"MQTT Mode\"]\n    n1[\"KevinbotLib\"] --&gt; n10\n    n11 --&gt; n2\n    n12 --&gt; n3\n    n3@{ shape: rect}\n    n4@{ shape: rect}\n    n6@{ shape: rect}\n    n2@{ shape: rect}\n    n10@{ shape: diam}\n    n11@{ shape: text}\n    n1@{ shape: rect}\n    n12@{ shape: text}</code></pre> <p>XBee</p> <p>KevinbotLib does not support XBee communication at this moment</p>"},{"location":"architecture/#serial-vs-mqtt","title":"Serial vs. MQTT","text":""},{"location":"architecture/#direct-serial","title":"Direct Serial","text":"<p>Pros</p> <ul> <li>Very low-latency</li> <li>More reliable</li> <li>Simpler</li> </ul> <p>Cons</p> <ul> <li>Single client access</li> <li>Requires wired connection</li> </ul>"},{"location":"architecture/#mqtt","title":"MQTT","text":"<p>Pros</p> <ul> <li>Multiple client access</li> <li>Networked</li> <li>Potentially easier to debug data</li> </ul> <p>Cons</p> <ul> <li>Higher latency</li> <li>More complex/more to go wrong</li> <li>Requires MQTT Broker</li> </ul>"},{"location":"cli_config/","title":"Configuration","text":"<p>The set of configuration commands makes it easier to set and retrieve configuration options.</p>"},{"location":"cli_config/#echo","title":"echo","text":"<p>The <code>echo</code> tool will output the raw configuration data in the original YAML format.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config echo [OPTIONS]\n</code></pre>"},{"location":"cli_config/#example-usage","title":"Example Usage","text":"<ul> <li>Outputing user configuration     <pre><code>kevinbot config echo\n</code></pre></li> <li>Outputing system configuration     <pre><code>kevinbot config echo --system\n</code></pre></li> </ul>"},{"location":"cli_config/#options","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_config/#get","title":"get","text":"<p>The <code>get</code> tool will return a value or group of values for the configurations. Will return a single value or JSON for a group of values.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config get [OPTIONS] KEYS\n</code></pre>"},{"location":"cli_config/#example-usage_1","title":"Example Usage","text":"<ul> <li>Retrieving MQTT Port     <pre><code>kevinbot config get mqtt.port\n</code></pre></li> <li>Retrieving Full MQTT Config (JSON)     <pre><code>kevinbot config get mqtt\n</code></pre></li> <li>Retrieving Entire Config (JSON)     <pre><code>kevinbot config get .\n</code></pre></li> </ul>"},{"location":"cli_config/#options_1","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_config/#set","title":"set","text":"<p>The <code>set</code> tool will set a single config value.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config set [OPTIONS] KEYS VALUE\n</code></pre>"},{"location":"cli_config/#example-usage_2","title":"Example Usage","text":"<ul> <li>Setting MQTT Port     <pre><code>kevinbot config set mqtt.port 2883 --int\n</code></pre></li> <li>Setting MQTT Host     <pre><code>kevinbot config set mqtt.host \"kevinbotv3.local\" --str\n</code></pre></li> </ul>"},{"location":"cli_config/#options_2","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>--int</code> FLAG Set value as an integer <code>--str</code> FLAG Set value as a string (default) <code>--bool</code> FLAG Set value as a boolean <code>--float</code> FLAG Set value as a floating-point <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_config/#path","title":"path","text":"<p>The <code>path</code> tool will retrieve the configuration file path for user or system-level configurations.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config path [OPTIONS]\n</code></pre>"},{"location":"cli_config/#example-usage_3","title":"Example Usage","text":"<ul> <li>Getting default configuration path     <pre><code>kevinbot config path\n</code></pre></li> <li>Getting user configuration path     <pre><code>kevinbot config path --user\n</code></pre></li> <li>Getting system configuration path     <pre><code>kevinbot config path --system\n</code></pre></li> </ul>"},{"location":"cli_config/#options_3","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_config/#save","title":"save","text":"<p>The <code>save</code> tool will create or update a configuration file.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config save [OPTIONS]\n</code></pre>"},{"location":"cli_config/#example-usage_4","title":"Example Usage","text":"<ul> <li>Create/update a user configuration file     <pre><code>kevinbot config save --user\n</code></pre></li> <li>Create/update a user configuration file     <pre><code>kevinbot config save --system\n</code></pre></li> <li>Create/update a custom configuration file     <pre><code>kevinbot config save --config ~/path/to/config.yaml\n</code></pre></li> </ul>"},{"location":"cli_config/#options_4","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_listener/","title":"MQTT Listener","text":"<p>The MQTT Listener command line tool provides an easy way to subscribe to MQTT topics.  It subscribes to an MQTT topic, and logs messages to the terminal.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot listen [OPTIONS] TOPIC\n</code></pre>"},{"location":"cli_listener/#options","title":"Options","text":"Argument Type Description <code>--qos</code> INT MQTT Quality-of-Service <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_pub/","title":"MQTT Publisher","text":"<p>The MQTT Publisher command line tool provides an easy way to publish to MQTT topics.  It can publish messages once, or at a set interval and count.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot pub [OPTIONS] TOPIC MESSAGE\n</code></pre>"},{"location":"cli_pub/#options","title":"Options","text":"Argument Type Description <code>--count</code> INT Number of times to publish message <code>--interval</code> FLOAT Interval between publishing messages (seconds) <code>--qos</code> INT MQTT Quality-of-Service <code>--retain</code> FLAG MQTT Retain Message <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"examples/","title":"Examples","text":"<p>All examples include two variants for serial, and MQTT. Source code can be found here</p> <p>For more information, see Serial vs. MQTT</p>"},{"location":"examples/#core","title":"Core","text":""},{"location":"examples/#robot-connection","title":"Robot Connection","text":"SerialMQTT examples/core/connecting_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nwhile True:\n    time.sleep(1)\n</code></pre> examples/core/connecting.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect(\"kevinbot\", \"localhost\", 1883)\n\nwhile True:\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#robot-enabling-and-disabling","title":"Robot Enabling and Disabling","text":"SerialMQTT examples/core/enable_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nrobot.request_enable()  # Ask the core to enable\nwhile not robot.get_state().enabled:  # Wait until the core is enabled\n    time.sleep(0.01)\n\ntime.sleep(3)\n\nrobot.request_disable()  # Ask the core to disable\nwhile robot.get_state().enabled:  # Wait until the core is disabled\n    time.sleep(0.01)\n\ntime.sleep(3)  # Let the user see that the robot is disabled before disconnecting\n</code></pre> examples/core/enable.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nrobot.request_enable()  # Ask the core to enable\nwhile not robot.get_state().enabled:  # Wait until the core is enabled\n    time.sleep(0.01)\n\ntime.sleep(3)\n\nrobot.request_disable()  # Ask the core to disable\nwhile robot.get_state().enabled:  # Wait until the core is disabled\n    time.sleep(0.01)\n\ntime.sleep(3)  # Let the user see that the robot is disabled before disconnecting\n</code></pre>"},{"location":"examples/#robot-emergency-stop","title":"Robot Emergency Stop","text":"SerialMQTT examples/core/estop_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nrobot.e_stop()\n</code></pre> examples/core/estop.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nrobot.e_stop()\n</code></pre>"},{"location":"examples/#robot-state-retrieval","title":"Robot State Retrieval","text":"SerialMQTT examples/core/state_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nwhile True:\n    print(robot.get_state())  # noqa: T201\n    time.sleep(1)\n</code></pre> examples/core/state.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nwhile True:\n    print(robot.get_state())  # noqa: T201\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#robot-uptime-retrieval","title":"Robot Uptime Retrieval","text":"SerialMQTT examples/core/uptimes_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nwhile True:\n    print(f\"Uptime (s) : {robot.get_state().uptime}\")  # noqa: T201\n    print(f\"Uptime (ms): {robot.get_state().uptime_ms}\")  # noqa: T201\n    time.sleep(1)\n</code></pre> examples/core/uptimes.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nwhile True:\n    print(f\"Uptime (s) : {robot.get_state().uptime}\")  # noqa: T201\n    print(f\"Uptime (ms): {robot.get_state().uptime_ms}\")  # noqa: T201\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#battery","title":"Battery","text":""},{"location":"examples/#robot-battery-readings","title":"Robot Battery Readings","text":"SerialMQTT examples/battery/readings_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\ntime.sleep(3)  # Wait to get data\n\nprint(f\"Voltages: {robot.get_state().battery.voltages}\")  # noqa: T201\nprint(f\"Raw Voltages: {robot.get_state().battery.raw_voltages}\")  # noqa: T201\nprint(f\"States: {robot.get_state().battery.states}\")  # noqa: T201\n</code></pre> examples/battery/readings.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\ntime.sleep(3)  # Wait to get data\n\nprint(f\"Voltages: {robot.get_state().battery.voltages}\")  # noqa: T201\nprint(f\"Raw Voltages: {robot.get_state().battery.raw_voltages}\")  # noqa: T201\nprint(f\"States: {robot.get_state().battery.states}\")  # noqa: T201\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Info</p> <p>KevinbotLib requires Python 3.10 or newer.</p>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"<p>Run the following in a virtual environment. <pre><code>pip install kevinbotlib\n</code></pre></p>"},{"location":"installation/#install-with-pipx","title":"Install with pipx","text":"<p>Tip</p> <p>pipx installation will only install command-line tools and the KevinbotLib Server. Use the regular pip installation if you want any development tools.</p> <ol> <li>Install pipx here</li> <li> <p>Install KevinbotLib</p> <p>Run the follwoing: <pre><code>pipx install kevinbotlib\n</code></pre></p> </li> </ol>"},{"location":"reference/","title":"Reference","text":"<p>Configuration manager for KevinbotLib</p> <p>KevinbotLib Robot Server Allow accessing KevinbotLib APIs over MQTT and XBee API Mode</p>"},{"location":"reference/#kevinbotlib.core.BaseKevinbotSubsystem","title":"<code>BaseKevinbotSubsystem</code>","text":"<p>The base subsystem class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class BaseKevinbotSubsystem:\n    \"\"\"The base subsystem class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self, robot: \"SerialKevinbot | MqttKevinbot\") -&gt; None:\n        self.robot = robot\n        self.robot._register_component(self)  # noqa: SLF001\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot","title":"<code>BaseKevinbot</code>","text":"<p>The base robot class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class BaseKevinbot:\n    \"\"\"The base robot class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._state = KevinbotState()\n        self.type = KevinbotConnectionType.BASE\n        self._subsystems: list[BaseKevinbotSubsystem] = []\n\n        self._auto_disconnect = True\n        self._auto_disable = True\n\n    def get_state(self) -&gt; KevinbotState:\n        \"\"\"Gets the current state of the robot\n\n        Returns:\n            KevinbotState: State class\n        \"\"\"\n        return self._state\n\n    def disconnect(self):\n        \"\"\"Basic robot disconnect\"\"\"\n        self._state.connected = False\n        if self.auto_disable:\n            self.request_disable()\n\n    @property\n    def auto_disconnect(self) -&gt; bool:\n        \"\"\"Getter for auto disconnect state.\n\n        Returns:\n            bool: Whether to disconnect on application exit\n        \"\"\"\n        return self._auto_disconnect\n\n    @auto_disconnect.setter\n    def auto_disconnect(self, value: bool):\n        \"\"\"Setter for auto disconnect.\n\n        Args:\n            value (bool): Whether to disconnect on application exit\n        \"\"\"\n        self._auto_disconnect = value\n        if value:\n            atexit.register(self.disconnect)\n        else:\n            atexit.unregister(self.disconnect)\n\n    @property\n    def auto_disable(self) -&gt; bool:\n        \"\"\"Getter for auto disable state.\n\n        Returns:\n            bool: Whether to disconnect on application exit\n        \"\"\"\n        return self._auto_disable\n\n    @auto_disable.setter\n    def auto_disable(self, value: bool):\n        \"\"\"Setter for auto disable.\n\n        Args:\n            value (bool): Whether to disconnect on application exit\n        \"\"\"\n        self._auto_disable = value\n\n    def send(self, data: str):\n        \"\"\"Null implementation of the send method\n\n        Args:\n            data (str): Data to send nowhere\n\n        Raises:\n            NotImplementedError: Always raised\n        \"\"\"\n        msg = f\"Function not implemented, attempting to send {data}\"\n        raise NotImplementedError(msg)\n\n    def request_enable(self) -&gt; int:\n        \"\"\"Request the core to enable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.send(\"kevinbot.tryenable=1\")\n        return 1\n\n    def request_disable(self) -&gt; int:\n        \"\"\"Request the core to disable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.send(\"kevinbot.tryenable=0\")\n        return 1\n\n    def e_stop(self):\n        \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n        self.send(\"system.estop\")\n        self._state.estop = True\n\n    def _register_component(self, component: BaseKevinbotSubsystem):\n        self._subsystems.append(component)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.auto_disconnect","title":"<code>auto_disconnect: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for auto disconnect state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to disconnect on application exit</p>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.auto_disable","title":"<code>auto_disable: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for auto disable state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to disconnect on application exit</p>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.get_state","title":"<code>get_state()</code>","text":"<p>Gets the current state of the robot</p> <p>Returns:</p> Name Type Description <code>KevinbotState</code> <code>KevinbotState</code> <p>State class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_state(self) -&gt; KevinbotState:\n    \"\"\"Gets the current state of the robot\n\n    Returns:\n        KevinbotState: State class\n    \"\"\"\n    return self._state\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Basic robot disconnect</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Basic robot disconnect\"\"\"\n    self._state.connected = False\n    if self.auto_disable:\n        self.request_disable()\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.send","title":"<code>send(data)</code>","text":"<p>Null implementation of the send method</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send nowhere</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Null implementation of the send method\n\n    Args:\n        data (str): Data to send nowhere\n\n    Raises:\n        NotImplementedError: Always raised\n    \"\"\"\n    msg = f\"Function not implemented, attempting to send {data}\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.request_enable","title":"<code>request_enable()</code>","text":"<p>Request the core to enable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_enable(self) -&gt; int:\n    \"\"\"Request the core to enable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.send(\"kevinbot.tryenable=1\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.request_disable","title":"<code>request_disable()</code>","text":"<p>Request the core to disable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_disable(self) -&gt; int:\n    \"\"\"Request the core to disable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.send(\"kevinbot.tryenable=0\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.e_stop","title":"<code>e_stop()</code>","text":"<p>Attempt to send and E-Stop signal to the Core</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def e_stop(self):\n    \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n    self.send(\"system.estop\")\n    self._state.estop = True\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot","title":"<code>SerialKevinbot</code>","text":"<p>               Bases: <code>BaseKevinbot</code></p> <p>The main serial robot class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class SerialKevinbot(BaseKevinbot):\n    \"\"\"The main serial robot class\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.type = KevinbotConnectionType.SERIAL\n\n        self.serial: Serial | None = None\n        self.rx_thread: Thread | None = None\n\n        self._callback: Callable[[str, str | None], Any] | None = None\n\n        atexit.register(self.disconnect)\n\n    def connect(\n        self,\n        port: str,\n        baud: int,\n        timeout: float,\n        tick_interval: float,\n        ser_timeout: float = 0.5,\n        *,\n        tick_thread: bool = True,\n    ):\n        \"\"\"Start a connection with Kevinbot Core\n\n        Args:\n            port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n            baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n            timeout (float): Timeout for handshake\n            tick_interval (float): How often a heartbeat should be produced\n            ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n            tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n        Raises:\n            HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n        \"\"\"\n        serial = self._setup_serial(port, baud, ser_timeout)\n\n        start_time = time.monotonic()\n        while True:\n            serial.write(b\"connection.isready=0\\n\")\n\n            line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n            if line == \"ready\":\n                serial.write(b\"connection.start\\n\")\n                serial.write(b\"core.errors.clear\\n\")\n                serial.write(b\"connection.ok\\n\")\n                break\n\n            if time.monotonic() - start_time &gt; timeout:\n                msg = \"Handshake timed out\"\n                raise HandshakeTimeoutException(msg)\n\n            time.sleep(0.1)  # Avoid spamming the connection\n\n        # Data rx thread\n        self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n        self.rx_thread.name = \"KevinbotLib.Rx\"\n        self.rx_thread.start()\n\n        if tick_thread:\n            thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n            thread.start()\n            thread.name = \"KevinbotLib.Tick\"\n\n        self._state.connected = True\n\n    def disconnect(self):\n        \"\"\"Disconnect core gracefully\"\"\"\n        super().disconnect()\n        if self.serial and self.serial.is_open:\n            self.send(\"core.link.unlink\")\n            self.serial.flush()\n            self.serial.close()\n        else:\n            logger.warning(\"Already disconnected\")\n\n    @property\n    def callback(self) -&gt; Callable[[str, str | None], Any] | None:\n        return self._callback\n\n    @callback.setter\n    def callback(self, callback: Callable[[str, str | None], Any]) -&gt; None:\n        self._callback = callback\n\n    def tick_loop(self, interval: float = 1):\n        \"\"\"Send ticks indefinetely\n\n        Args:\n            interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n        \"\"\"\n        while True:\n            self._tick()\n            time.sleep(interval)\n\n    def send(self, data: str):\n        \"\"\"Send a string through serial.\n\n        Automatically adds a newline.\n\n        Args:\n            data (str): Data to send\n        \"\"\"\n        self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n\n    def raw_tx(self, data: bytes):\n        \"\"\"Send raw bytes over serial.\n\n        Args:\n            data (bytes): Raw data\n        \"\"\"\n        if self.serial:\n            self.serial.write(data)\n        else:\n            logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n\n    def _rx_loop(self, serial: Serial, delimeter: str = \"=\"):\n        while True:\n            try:\n                raw: bytes = serial.readline()\n            except TypeError:\n                # serial has been stopped\n                return\n\n            cmd: str = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[0].strip()\n            if not cmd:\n                continue\n\n            val: str | None = None\n            if len(raw.decode(\"utf-8\").split(delimeter)) &gt; 1:\n                val = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[1].strip(\"\\r\\n\")\n\n            match cmd:\n                case \"ready\":\n                    pass\n                case \"core.enabled\":\n                    if not val:\n                        logger.warning(\"No value recieved for 'core.enabled'\")\n                        continue\n                    if val.lower() in [\"true\", \"t\", \"1\"]:\n                        self._state.enabled = True\n                    else:\n                        self._state.enabled = False\n                case \"core.uptime\":\n                    if val:\n                        self._state.uptime = int(val)\n                case \"core.uptime_ms\":\n                    if val:\n                        self._state.uptime_ms = int(val)\n                case \"connection.requesthandshake\":\n                    serial.write(b\"connection.start\\n\")\n                    serial.write(b\"core.errors.clear\\n\")\n                    serial.write(b\"connection.ok\\n\")\n                    logger.warning(\"A handshake was re-requested. This could indicate a core power fault or reset\")\n                case \"motors.amps\":\n                    if val:\n                        self._state.motion.amps = list(map(float, val.split(\",\")))\n                case \"motors.watts\":\n                    if val:\n                        self._state.motion.watts = list(map(float, val.split(\",\")))\n                case \"motors.status\":\n                    if val:\n                        self._state.motion.status = [MotorDriveStatus(int(x)) for x in val.split(\",\")]\n                case \"bms.voltages\":\n                    if val:\n                        self._state.battery.voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.raw_voltages\":\n                    if val:\n                        self._state.battery.raw_voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.status\":\n                    if val:\n                        self._state.battery.states = [BmsBatteryState(int(x)) for x in val.split(\",\")]\n                case \"sensors.gyro\":\n                    if val:\n                        self._state.imu.gyro = [int(x) for x in val.split(\",\")]\n                case \"sensors.accel\":\n                    if val:\n                        self._state.imu.accel = [int(x) for x in val.split(\",\")]\n                case \"sensors.temps\":\n                    if val:\n                        temps = val.split(\",\")\n                        valid = True\n                        for temp in temps:\n                            if not re.match(\"^[-+]?[0-9]+$\", temp):\n                                logger.error(f\"Found non-integer value in temps, {temps}\")\n                                valid = False\n                                break\n                        if valid:\n                            self._state.thermal.left_motor = int(temps[0]) / 100\n                            self._state.thermal.right_motor = int(temps[1]) / 100\n                            self._state.thermal.internal = int(temps[2]) / 100\n                case \"sensors.bme\":\n                    if val:\n                        vals = val.split(\",\")\n                        for value in vals:\n                            if not re.match(\"^[-+]?[0-9]+$\", value):\n                                logger.error(f\"Found non-integer value in bme values, {temps}\")\n                                continue\n\n                        self._state.enviro.temperature = int(vals[0])\n                        self._state.enviro.humidity = int(vals[2])\n                        self._state.enviro.pressure = int(vals[3])\n                case _:\n                    logger.warning(f\"Got a command that isn't supported yet: {cmd} with value {val}\")\n\n            if self.callback:\n                self.callback(cmd, val)\n\n    def _setup_serial(self, port: str, baud: int, timeout: float = 1):\n        self.serial = Serial(port, baud, timeout=timeout)\n        return self.serial\n\n    def _tick(self):\n        if self.serial and self.serial.is_open:\n            self.serial.write(b\"core.tick\\n\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.connect","title":"<code>connect(port, baud, timeout, tick_interval, ser_timeout=0.5, *, tick_thread=True)</code>","text":"<p>Start a connection with Kevinbot Core</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port to use (<code>/dev/ttyAMA2</code> is standard with the typical Kevinbot Hardware)</p> required <code>baud</code> <code>int</code> <p>Baud rate to use (<code>921600</code> is typical for the defualt Core configs)</p> required <code>timeout</code> <code>float</code> <p>Timeout for handshake</p> required <code>tick_interval</code> <code>float</code> <p>How often a heartbeat should be produced</p> required <code>ser_timeout</code> <code>float</code> <p>Readline timeout, should be lower than <code>timeout</code>. Defaults to 0.5.</p> <code>0.5</code> <code>tick_thread</code> <code>bool</code> <p>Whether a tick thread should be started. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>HandshakeTimeoutException</code> <p>Core didn't respond to the connection handshake before the timeout</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def connect(\n    self,\n    port: str,\n    baud: int,\n    timeout: float,\n    tick_interval: float,\n    ser_timeout: float = 0.5,\n    *,\n    tick_thread: bool = True,\n):\n    \"\"\"Start a connection with Kevinbot Core\n\n    Args:\n        port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n        baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n        timeout (float): Timeout for handshake\n        tick_interval (float): How often a heartbeat should be produced\n        ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n        tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n    Raises:\n        HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n    \"\"\"\n    serial = self._setup_serial(port, baud, ser_timeout)\n\n    start_time = time.monotonic()\n    while True:\n        serial.write(b\"connection.isready=0\\n\")\n\n        line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n        if line == \"ready\":\n            serial.write(b\"connection.start\\n\")\n            serial.write(b\"core.errors.clear\\n\")\n            serial.write(b\"connection.ok\\n\")\n            break\n\n        if time.monotonic() - start_time &gt; timeout:\n            msg = \"Handshake timed out\"\n            raise HandshakeTimeoutException(msg)\n\n        time.sleep(0.1)  # Avoid spamming the connection\n\n    # Data rx thread\n    self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n    self.rx_thread.name = \"KevinbotLib.Rx\"\n    self.rx_thread.start()\n\n    if tick_thread:\n        thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n        thread.start()\n        thread.name = \"KevinbotLib.Tick\"\n\n    self._state.connected = True\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect core gracefully</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect core gracefully\"\"\"\n    super().disconnect()\n    if self.serial and self.serial.is_open:\n        self.send(\"core.link.unlink\")\n        self.serial.flush()\n        self.serial.close()\n    else:\n        logger.warning(\"Already disconnected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.tick_loop","title":"<code>tick_loop(interval=1)</code>","text":"<p>Send ticks indefinetely</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>Interval between ticks in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def tick_loop(self, interval: float = 1):\n    \"\"\"Send ticks indefinetely\n\n    Args:\n        interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n    \"\"\"\n    while True:\n        self._tick()\n        time.sleep(interval)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.send","title":"<code>send(data)</code>","text":"<p>Send a string through serial.</p> <p>Automatically adds a newline.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Send a string through serial.\n\n    Automatically adds a newline.\n\n    Args:\n        data (str): Data to send\n    \"\"\"\n    self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.raw_tx","title":"<code>raw_tx(data)</code>","text":"<p>Send raw bytes over serial.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw data</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def raw_tx(self, data: bytes):\n    \"\"\"Send raw bytes over serial.\n\n    Args:\n        data (bytes): Raw data\n    \"\"\"\n    if self.serial:\n        self.serial.write(data)\n    else:\n        logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot","title":"<code>MqttKevinbot</code>","text":"<p>               Bases: <code>BaseKevinbot</code></p> <p>KevinbotLib interface over MQTT</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class MqttKevinbot(BaseKevinbot):\n    \"\"\"KevinbotLib interface over MQTT\"\"\"\n\n    def __init__(self, cid: str | None = None) -&gt; None:\n        \"\"\"Instansiate a new KevinbotLib interface over MQTT\n\n        Args:\n            cid (str | None, optional): MQTT Client id. Defaults to an auto-generated uuid.\n        \"\"\"\n        super().__init__()\n        self.type = KevinbotConnectionType.MQTT\n\n        self.root_topic = \"kevinbot\"\n        self.host = \"localhost\"\n        self.port = 1883\n        self.keepalive = 60\n\n        self.cid = cid if cid else f\"kevinbotlib-{shortuuid.random()}\"\n        self.client = Client(CallbackAPIVersion.VERSION2, self.cid)\n        self.client.on_message = self._on_message\n\n        atexit.register(self.disconnect)\n\n    def connect(\n        self, root_topic: str = \"kevinbot\", host: str = \"localhost\", port: int = 1883, keepalive: int = 60\n    ) -&gt; MQTTErrorCode:\n        \"\"\"Connect to MQTT Broker\n\n        Args:\n            root_topic (str, optional): Root communication topic. Defaults to \"kevinbot\".\n            host (str, optional): KevinbotLib server host. Defaults to \"localhost\".\n            port (int, optional): Kevinbot MQTT Broker port. Defaults to 1883.\n            keepalive (int, optional): Maximum period in seconds between communications with the broker. Defaults to 60.\n\n        Returns:\n            MQTTErrorCode: Connection error\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.keepalive = keepalive\n        self.root_topic = root_topic\n        self.connected = False\n\n        rc = self.client.connect(self.host, self.port, self.keepalive)\n        self.client.subscribe(f\"{self.root_topic}/state\", 0)\n        self.client.subscribe(f\"{self.root_topic}/clients/connect/ack\", 0)\n        self.client.publish(f\"{self.root_topic}/clients/connect\", self.cid, 0)\n        self.client.loop_start()\n\n        while not self.connected:\n            time.sleep(0.01)\n\n        return rc\n\n    def send(self, data: str):\n        \"\"\"Determine topic and publish data. Compatible with send of `SerialKevinbot`\n\n        Args:\n            data (str): Data to parse and publish\n        \"\"\"\n        if len(data.split(\"=\", 2)) &gt; 1:\n            cmd, val = data.split(\"=\", 2)\n        else:\n            cmd = data\n            val = None\n\n        self.client.publish(f\"{self.root_topic}/{cmd.replace('.', '/')}\", val, 0)\n\n    def disconnect(self):\n        \"\"\"Disconnect from server\"\"\"\n        super().disconnect()\n        self.client.publish(f\"{self.root_topic}/clients/disconnect\", self.cid, 0).wait_for_publish(1)\n\n    def request_enable(self) -&gt; int:\n        \"\"\"Request the core to enable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.client.publish(f\"{self.root_topic}/main/state_request\", \"enable\", 1)\n        return 1\n\n    def request_disable(self) -&gt; int:\n        \"\"\"Request the core to disable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.client.publish(f\"{self.root_topic}/main/state_request\", \"disable\", 1)\n        return 1\n\n    def e_stop(self):\n        \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n        self.client.publish(f\"{self.root_topic}/main/estop\", 1)\n\n    def _on_message(self, _, __, msg: MQTTMessage):\n        logger.trace(f\"Got MQTT message at: {msg.topic} payload={msg.payload!r} with qos={msg.qos}\")\n\n        if msg.topic[0] == \"/\" or msg.topic[-1] == \"/\":\n            logger.warning(f\"MQTT topic: {msg.topic} has a leading/trailing slash. Removing it.\")\n            topic = msg.topic.strip(\"/\")\n        else:\n            topic = msg.topic\n\n        value = msg.payload.decode(\"utf-8\")\n\n        subtopics = topic.split(\"/\")[1:]\n        match subtopics:\n            case [\"state\"]:\n                self._state = KevinbotState(**json.loads(value))\n            case [\"clients\", \"connect\", \"ack\"]:\n                if value == f\"ack:{self.cid}\":\n                    self.connected = True\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.__init__","title":"<code>__init__(cid=None)</code>","text":"<p>Instansiate a new KevinbotLib interface over MQTT</p> <p>Parameters:</p> Name Type Description Default <code>cid</code> <code>str | None</code> <p>MQTT Client id. Defaults to an auto-generated uuid.</p> <code>None</code> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def __init__(self, cid: str | None = None) -&gt; None:\n    \"\"\"Instansiate a new KevinbotLib interface over MQTT\n\n    Args:\n        cid (str | None, optional): MQTT Client id. Defaults to an auto-generated uuid.\n    \"\"\"\n    super().__init__()\n    self.type = KevinbotConnectionType.MQTT\n\n    self.root_topic = \"kevinbot\"\n    self.host = \"localhost\"\n    self.port = 1883\n    self.keepalive = 60\n\n    self.cid = cid if cid else f\"kevinbotlib-{shortuuid.random()}\"\n    self.client = Client(CallbackAPIVersion.VERSION2, self.cid)\n    self.client.on_message = self._on_message\n\n    atexit.register(self.disconnect)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.connect","title":"<code>connect(root_topic='kevinbot', host='localhost', port=1883, keepalive=60)</code>","text":"<p>Connect to MQTT Broker</p> <p>Parameters:</p> Name Type Description Default <code>root_topic</code> <code>str</code> <p>Root communication topic. Defaults to \"kevinbot\".</p> <code>'kevinbot'</code> <code>host</code> <code>str</code> <p>KevinbotLib server host. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Kevinbot MQTT Broker port. Defaults to 1883.</p> <code>1883</code> <code>keepalive</code> <code>int</code> <p>Maximum period in seconds between communications with the broker. Defaults to 60.</p> <code>60</code> <p>Returns:</p> Name Type Description <code>MQTTErrorCode</code> <code>MQTTErrorCode</code> <p>Connection error</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def connect(\n    self, root_topic: str = \"kevinbot\", host: str = \"localhost\", port: int = 1883, keepalive: int = 60\n) -&gt; MQTTErrorCode:\n    \"\"\"Connect to MQTT Broker\n\n    Args:\n        root_topic (str, optional): Root communication topic. Defaults to \"kevinbot\".\n        host (str, optional): KevinbotLib server host. Defaults to \"localhost\".\n        port (int, optional): Kevinbot MQTT Broker port. Defaults to 1883.\n        keepalive (int, optional): Maximum period in seconds between communications with the broker. Defaults to 60.\n\n    Returns:\n        MQTTErrorCode: Connection error\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.keepalive = keepalive\n    self.root_topic = root_topic\n    self.connected = False\n\n    rc = self.client.connect(self.host, self.port, self.keepalive)\n    self.client.subscribe(f\"{self.root_topic}/state\", 0)\n    self.client.subscribe(f\"{self.root_topic}/clients/connect/ack\", 0)\n    self.client.publish(f\"{self.root_topic}/clients/connect\", self.cid, 0)\n    self.client.loop_start()\n\n    while not self.connected:\n        time.sleep(0.01)\n\n    return rc\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.send","title":"<code>send(data)</code>","text":"<p>Determine topic and publish data. Compatible with send of <code>SerialKevinbot</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to parse and publish</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Determine topic and publish data. Compatible with send of `SerialKevinbot`\n\n    Args:\n        data (str): Data to parse and publish\n    \"\"\"\n    if len(data.split(\"=\", 2)) &gt; 1:\n        cmd, val = data.split(\"=\", 2)\n    else:\n        cmd = data\n        val = None\n\n    self.client.publish(f\"{self.root_topic}/{cmd.replace('.', '/')}\", val, 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from server</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect from server\"\"\"\n    super().disconnect()\n    self.client.publish(f\"{self.root_topic}/clients/disconnect\", self.cid, 0).wait_for_publish(1)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.request_enable","title":"<code>request_enable()</code>","text":"<p>Request the core to enable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_enable(self) -&gt; int:\n    \"\"\"Request the core to enable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.client.publish(f\"{self.root_topic}/main/state_request\", \"enable\", 1)\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.request_disable","title":"<code>request_disable()</code>","text":"<p>Request the core to disable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_disable(self) -&gt; int:\n    \"\"\"Request the core to disable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.client.publish(f\"{self.root_topic}/main/state_request\", \"disable\", 1)\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.e_stop","title":"<code>e_stop()</code>","text":"<p>Attempt to send and E-Stop signal to the Core</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def e_stop(self):\n    \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n    self.client.publish(f\"{self.root_topic}/main/estop\", 1)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase","title":"<code>Drivebase</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Drivebase subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Drivebase(BaseKevinbotSubsystem):\n    \"\"\"Drivebase subsystem for Kevinbot\"\"\"\n\n    def get_amps(self) -&gt; list[float]:\n        \"\"\"Get the amps being used by the drivebase\n\n        Returns:\n            list[float]: Amps\n        \"\"\"\n        return self.robot.get_state().motion.amps\n\n    def get_watts(self) -&gt; list[float]:\n        \"\"\"Get the watts being used by the drivebase\n\n        Returns:\n            list[float]: Watts\n        \"\"\"\n        return self.robot.get_state().motion.watts\n\n    def get_powers(self) -&gt; tuple[int, int]:\n        \"\"\"Get the currently set wheel speeds in percent\n\n        Returns:\n            tuple[int, int]: Percent values from 0 to 100\n        \"\"\"\n        return self.robot.get_state().motion.left_power, self.robot.get_state().motion.right_power\n\n    def get_states(self) -&gt; list[MotorDriveStatus]:\n        \"\"\"Get the wheels states\n\n        Returns:\n            list[MotorDriveStatus]: States\n        \"\"\"\n        return self.robot.get_state().motion.status\n\n    def drive_at_power(self, left: float, right: float):\n        \"\"\"Set the drive power for wheels. 0 to 1\n\n        Args:\n            left (float): Left motor power\n            right (float): Right motor power\n        \"\"\"\n        if isinstance(self.robot, SerialKevinbot):\n            self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n        elif isinstance(self.robot, MqttKevinbot):\n            self.robot.client.publish(f\"{self.robot.root_topic}/drive/power\", f\"{int(left*100)},{int(right*100)},{self.robot.cid}\", 1)\n\n    def stop(self):\n        \"\"\"Set all wheel powers to 0\"\"\"\n        if isinstance(self.robot, SerialKevinbot):\n            self.robot.send(\"drive.power=0,0\")\n        elif isinstance(self.robot, MqttKevinbot):\n            self.robot.client.publish(f\"{self.robot.root_topic}/drive/power\", \"0,0,{self.robot.cid}\", 1)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_amps","title":"<code>get_amps()</code>","text":"<p>Get the amps being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Amps</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_amps(self) -&gt; list[float]:\n    \"\"\"Get the amps being used by the drivebase\n\n    Returns:\n        list[float]: Amps\n    \"\"\"\n    return self.robot.get_state().motion.amps\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_watts","title":"<code>get_watts()</code>","text":"<p>Get the watts being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Watts</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_watts(self) -&gt; list[float]:\n    \"\"\"Get the watts being used by the drivebase\n\n    Returns:\n        list[float]: Watts\n    \"\"\"\n    return self.robot.get_state().motion.watts\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_powers","title":"<code>get_powers()</code>","text":"<p>Get the currently set wheel speeds in percent</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: Percent values from 0 to 100</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_powers(self) -&gt; tuple[int, int]:\n    \"\"\"Get the currently set wheel speeds in percent\n\n    Returns:\n        tuple[int, int]: Percent values from 0 to 100\n    \"\"\"\n    return self.robot.get_state().motion.left_power, self.robot.get_state().motion.right_power\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_states","title":"<code>get_states()</code>","text":"<p>Get the wheels states</p> <p>Returns:</p> Type Description <code>list[MotorDriveStatus]</code> <p>list[MotorDriveStatus]: States</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_states(self) -&gt; list[MotorDriveStatus]:\n    \"\"\"Get the wheels states\n\n    Returns:\n        list[MotorDriveStatus]: States\n    \"\"\"\n    return self.robot.get_state().motion.status\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.drive_at_power","title":"<code>drive_at_power(left, right)</code>","text":"<p>Set the drive power for wheels. 0 to 1</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>float</code> <p>Left motor power</p> required <code>right</code> <code>float</code> <p>Right motor power</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def drive_at_power(self, left: float, right: float):\n    \"\"\"Set the drive power for wheels. 0 to 1\n\n    Args:\n        left (float): Left motor power\n        right (float): Right motor power\n    \"\"\"\n    if isinstance(self.robot, SerialKevinbot):\n        self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n    elif isinstance(self.robot, MqttKevinbot):\n        self.robot.client.publish(f\"{self.robot.root_topic}/drive/power\", f\"{int(left*100)},{int(right*100)},{self.robot.cid}\", 1)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.stop","title":"<code>stop()</code>","text":"<p>Set all wheel powers to 0</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def stop(self):\n    \"\"\"Set all wheel powers to 0\"\"\"\n    if isinstance(self.robot, SerialKevinbot):\n        self.robot.send(\"drive.power=0,0\")\n    elif isinstance(self.robot, MqttKevinbot):\n        self.robot.client.publish(f\"{self.robot.root_topic}/drive/power\", \"0,0,{self.robot.cid}\", 1)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servo","title":"<code>Servo</code>","text":"<p>Individually controllable servo</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Servo:\n    \"\"\"Individually controllable servo\"\"\"\n\n    def __init__(self, robot: SerialKevinbot | MqttKevinbot, index: int) -&gt; None:\n        self.robot = robot\n        self.index = index\n\n    @property\n    def bank(self) -&gt; int:\n        \"\"\"Get the bank the servo is in\n\n        Returns:\n            int: Bank number\n        \"\"\"\n        return self.index // 16\n\n    @property\n    def angle(self) -&gt; int:\n        \"\"\"Get the optimistic current servo angle\n\n        Returns:\n            int: Angle in degrees\n        \"\"\"\n        return self.robot.get_state().servos.angles[self.index]\n\n    @angle.setter\n    def angle(self, angle: int):\n        \"\"\"Set the optimistic servo angle\n\n        Args:\n            angle (int): Angle in degrees\n        \"\"\"\n        if isinstance(self.robot, SerialKevinbot):\n            self.robot.send(f\"s={self.index},{angle}\")\n        elif isinstance(self.robot, MqttKevinbot):\n            self.robot.client.publish(f\"{self.robot.root_topic}/servo/set\", f\"{self.index},{angle}\", 0)\n        else:\n            return\n\n        self.robot.get_state().servos.angles[self.index] = angle\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servo.bank","title":"<code>bank: int</code>  <code>property</code>","text":"<p>Get the bank the servo is in</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Bank number</p>"},{"location":"reference/#kevinbotlib.core.Servo.angle","title":"<code>angle: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the optimistic current servo angle</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Angle in degrees</p>"},{"location":"reference/#kevinbotlib.core.Servos","title":"<code>Servos</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Servo subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Servos(BaseKevinbotSubsystem):\n    \"\"\"Servo subsystem for Kevinbot\"\"\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"Length will always be 32 since the P2 Kevinbot Board can only control 32\n\n        Returns:\n            int: Number of servos in the subsystem\n        \"\"\"\n        return 32\n\n    def __iter__(self):\n        for i in range(self.__len__()):\n            yield Servo(self.robot, i)\n\n    def __getitem__(self, index: int):\n        if index &gt; self.__len__():\n            msg = f\"Servo index {index} &gt; {self.__len__()}\"\n            raise IndexError(msg)\n        if index &lt; 0:\n            msg = f\"Servo index {index} &lt; 0\"\n            raise IndexError(msg)\n        return Servo(self.robot, index)\n\n    def get_servo(self, channel: int) -&gt; Servo:\n        \"\"\"Get an individual servo in the subsystem\n\n        Args:\n            channel (int): PWM Port\n\n        Returns:\n            Servo: Individual servo\n        \"\"\"\n        if channel &gt; self.__len__() or channel &lt; 0:\n            msg = f\"Servo channel {channel} is out of bounds.\"\n            raise IndexError(msg)\n        return Servo(self.robot, channel)\n\n    @property\n    def all(self) -&gt; int:\n        if all(i == self.robot.get_state().servos.angles[0] for i in self.robot.get_state().servos.angles):\n            return self.robot.get_state().servos.angles[0]\n        return -1\n\n    @all.setter\n    def all(self, angle: int):\n        self.robot.send(f\"servo.all={angle}\")\n        self.robot.get_state().servos.angles = [angle] * self.__len__()\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servos.__len__","title":"<code>__len__()</code>","text":"<p>Length will always be 32 since the P2 Kevinbot Board can only control 32</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of servos in the subsystem</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Length will always be 32 since the P2 Kevinbot Board can only control 32\n\n    Returns:\n        int: Number of servos in the subsystem\n    \"\"\"\n    return 32\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servos.get_servo","title":"<code>get_servo(channel)</code>","text":"<p>Get an individual servo in the subsystem</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>PWM Port</p> required <p>Returns:</p> Name Type Description <code>Servo</code> <code>Servo</code> <p>Individual servo</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_servo(self, channel: int) -&gt; Servo:\n    \"\"\"Get an individual servo in the subsystem\n\n    Args:\n        channel (int): PWM Port\n\n    Returns:\n        Servo: Individual servo\n    \"\"\"\n    if channel &gt; self.__len__() or channel &lt; 0:\n        msg = f\"Servo channel {channel} is out of bounds.\"\n        raise IndexError(msg)\n    return Servo(self.robot, channel)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting","title":"<code>Lighting</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Lighting subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Lighting(BaseKevinbotSubsystem):\n    \"\"\"Lighting subsystem for Kevinbot\"\"\"\n\n    class Channel(Enum):\n        \"\"\"Lighting segment identifier\"\"\"\n\n        Head = \"head\"\n        Body = \"body\"\n        Base = \"base\"\n\n    def get_state(self) -&gt; LightingState:\n        \"\"\"Get the state of the robot's light segments\n\n        Returns:\n            LightingState: State\n        \"\"\"\n        return self.robot.get_state().lighting\n\n    def set_cam_brightness(self, brightness: int):\n        \"\"\"Set brightness of camera illumination\n\n        Args:\n            brightness (int): Brightness from 0 to 255\n        \"\"\"\n        self.robot.send(f\"lighting.cam.bright={brightness}\")\n        self.robot.get_state().lighting.camera = brightness\n\n    def set_brightness(self, channel: Channel, brightness: int):\n        \"\"\"Set the brightness of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            brightness (int): Brightness from 0 to 255\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.bright={brightness}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_bright = brightness\n            case self.Channel.Body:\n                self.robot.get_state().lighting.body_bright = brightness\n            case self.Channel.Head:\n                self.robot.get_state().lighting.head_bright = brightness\n\n    def set_color1(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n        \"\"\"Set the Color 1 of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            color (Iterable[int]): RGB Color values. Must have a length of 3\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.color1={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_color1 = list(color)\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_color1 = list(color)\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_color1 = list(color)\n\n    def set_color2(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n        \"\"\"Set the Color 2 of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            color (Iterable[int]): RGB Color values. Must have a length of 3\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.color2={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_color2 = list(color)\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_color2 = list(color)\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_color2 = list(color)\n\n    def set_effect(self, channel: Channel, effect: str):\n        \"\"\"Set the animation of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            effect (str): Animation ID\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.effect={effect}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_effect = effect\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_effect = effect\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_effect = effect\n\n    def set_update(self, channel: Channel, update: int):\n        \"\"\"Set the animation of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            update (int): Update rate (no fixed unit)\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.update={update}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_update = update\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_update = update\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_update = update\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Lighting segment identifier</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Channel(Enum):\n    \"\"\"Lighting segment identifier\"\"\"\n\n    Head = \"head\"\n    Body = \"body\"\n    Base = \"base\"\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.get_state","title":"<code>get_state()</code>","text":"<p>Get the state of the robot's light segments</p> <p>Returns:</p> Name Type Description <code>LightingState</code> <code>LightingState</code> <p>State</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_state(self) -&gt; LightingState:\n    \"\"\"Get the state of the robot's light segments\n\n    Returns:\n        LightingState: State\n    \"\"\"\n    return self.robot.get_state().lighting\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_cam_brightness","title":"<code>set_cam_brightness(brightness)</code>","text":"<p>Set brightness of camera illumination</p> <p>Parameters:</p> Name Type Description Default <code>brightness</code> <code>int</code> <p>Brightness from 0 to 255</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_cam_brightness(self, brightness: int):\n    \"\"\"Set brightness of camera illumination\n\n    Args:\n        brightness (int): Brightness from 0 to 255\n    \"\"\"\n    self.robot.send(f\"lighting.cam.bright={brightness}\")\n    self.robot.get_state().lighting.camera = brightness\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_brightness","title":"<code>set_brightness(channel, brightness)</code>","text":"<p>Set the brightness of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>brightness</code> <code>int</code> <p>Brightness from 0 to 255</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_brightness(self, channel: Channel, brightness: int):\n    \"\"\"Set the brightness of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        brightness (int): Brightness from 0 to 255\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.bright={brightness}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_bright = brightness\n        case self.Channel.Body:\n            self.robot.get_state().lighting.body_bright = brightness\n        case self.Channel.Head:\n            self.robot.get_state().lighting.head_bright = brightness\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_color1","title":"<code>set_color1(channel, color)</code>","text":"<p>Set the Color 1 of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>color</code> <code>Iterable[int]</code> <p>RGB Color values. Must have a length of 3</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_color1(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n    \"\"\"Set the Color 1 of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        color (Iterable[int]): RGB Color values. Must have a length of 3\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.color1={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_color1 = list(color)\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_color1 = list(color)\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_color1 = list(color)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_color2","title":"<code>set_color2(channel, color)</code>","text":"<p>Set the Color 2 of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>color</code> <code>Iterable[int]</code> <p>RGB Color values. Must have a length of 3</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_color2(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n    \"\"\"Set the Color 2 of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        color (Iterable[int]): RGB Color values. Must have a length of 3\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.color2={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_color2 = list(color)\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_color2 = list(color)\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_color2 = list(color)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_effect","title":"<code>set_effect(channel, effect)</code>","text":"<p>Set the animation of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>effect</code> <code>str</code> <p>Animation ID</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_effect(self, channel: Channel, effect: str):\n    \"\"\"Set the animation of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        effect (str): Animation ID\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.effect={effect}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_effect = effect\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_effect = effect\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_effect = effect\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_update","title":"<code>set_update(channel, update)</code>","text":"<p>Set the animation of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>update</code> <code>int</code> <p>Update rate (no fixed unit)</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_update(self, channel: Channel, update: int):\n    \"\"\"Set the animation of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        update (int): Update rate (no fixed unit)\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.update={update}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_update = update\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_update = update\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_update = update\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes","title":"<code>BaseKevinbotEyes</code>","text":"<p>The base Kevinbot Eyes class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>class BaseKevinbotEyes:\n    \"\"\"The base Kevinbot Eyes class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._state = KevinbotEyesState()\n        self.type = KevinbotConnectionType.BASE\n\n        self._auto_disconnect = True\n\n    def get_state(self) -&gt; KevinbotEyesState:\n        \"\"\"Gets the current state of the eyes\n\n        Returns:\n            KevinbotEyesState: State class\n        \"\"\"\n        return self._state\n\n    def disconnect(self):\n        \"\"\"Basic disconnect\"\"\"\n        self._state.connected = False\n\n    @property\n    def auto_disconnect(self) -&gt; bool:\n        \"\"\"Getter for auto disconnect state.\n\n        Returns:\n            bool: Whether to disconnect on application exit\n        \"\"\"\n        return self._auto_disconnect\n\n    @auto_disconnect.setter\n    def auto_disconnect(self, value: bool):\n        \"\"\"Setter for auto disconnect.\n\n        Args:\n            value (bool): Whether to disconnect on application exit\n        \"\"\"\n        self._auto_disconnect = value\n        if value:\n            atexit.register(self.disconnect)\n        else:\n            atexit.unregister(self.disconnect)\n\n    def send(self, data: str):\n        \"\"\"Null implementation of the send method\n\n        Args:\n            data (str): Data to send nowhere\n\n        Raises:\n            NotImplementedError: Always raised\n        \"\"\"\n        msg = f\"Function not implemented, attempting to send {data}\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.auto_disconnect","title":"<code>auto_disconnect: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for auto disconnect state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to disconnect on application exit</p>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.get_state","title":"<code>get_state()</code>","text":"<p>Gets the current state of the eyes</p> <p>Returns:</p> Name Type Description <code>KevinbotEyesState</code> <code>KevinbotEyesState</code> <p>State class</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def get_state(self) -&gt; KevinbotEyesState:\n    \"\"\"Gets the current state of the eyes\n\n    Returns:\n        KevinbotEyesState: State class\n    \"\"\"\n    return self._state\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.disconnect","title":"<code>disconnect()</code>","text":"<p>Basic disconnect</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def disconnect(self):\n    \"\"\"Basic disconnect\"\"\"\n    self._state.connected = False\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.send","title":"<code>send(data)</code>","text":"<p>Null implementation of the send method</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send nowhere</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Null implementation of the send method\n\n    Args:\n        data (str): Data to send nowhere\n\n    Raises:\n        NotImplementedError: Always raised\n    \"\"\"\n    msg = f\"Function not implemented, attempting to send {data}\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes","title":"<code>SerialEyes</code>","text":"<p>               Bases: <code>BaseKevinbotEyes</code></p> <p>The main serial Kevinbot Eyes class</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>class SerialEyes(BaseKevinbotEyes):\n    \"\"\"The main serial Kevinbot Eyes class\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.type = KevinbotConnectionType.SERIAL\n\n        self.serial: Serial | None = None\n        self.rx_thread: Thread | None = None\n\n        self._callback: Callable[[str, str | None], Any] | None = None\n\n        atexit.register(self.disconnect)\n\n    def connect(\n        self,\n        port: str,\n        baud: int,\n        timeout: float,\n        ser_timeout: float = 0.5,\n    ):\n        \"\"\"Start a connection with Kevinbot Eyes\n\n        Args:\n            port (str): Serial port to use (`/dev/ttyUSB0` is standard with the typical Kevinbot Hardware)\n            baud (int): Baud rate to use (`115200` is typical for the defualt eye configs)\n            timeout (float): Timeout for handshake\n            ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n\n        Raises:\n            HandshakeTimeoutException: Eyes didn't respond to the connection handshake before the timeout\n        \"\"\"\n        serial = self._setup_serial(port, baud, ser_timeout)\n\n        start_time = time.monotonic()\n        while True:\n            serial.write(b\"connectionReady\\n\")\n\n            line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n            if line == \"handshake.request\":\n                serial.write(b\"getSettings=true\\n\")\n                serial.write(b\"handshake.complete\\n\")\n                break\n\n            if time.monotonic() - start_time &gt; timeout:\n                msg = \"Handshake timed out\"\n                raise HandshakeTimeoutException(msg)\n\n            time.sleep(0.1)  # Avoid spamming the connection\n\n        # Data rx thread\n        self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n        self.rx_thread.name = \"KevinbotLib.Eyes.Rx\"\n        self.rx_thread.start()\n\n        self._state.connected = True\n\n    def disconnect(self):\n        super().disconnect()\n        if self.serial and self.serial.is_open:\n            self.send(\"resetConnection\")\n            self.serial.flush()\n            self.serial.close()\n        else:\n            logger.warning(\"Already disconnected\")\n\n    def send(self, data: str):\n        \"\"\"Send a string through serial.\n\n        Automatically adds a newline.\n\n        Args:\n            data (str): Data to send\n        \"\"\"\n        self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n\n    def raw_tx(self, data: bytes):\n        \"\"\"Send raw bytes over serial.\n\n        Args:\n            data (bytes): Raw data\n        \"\"\"\n        if self.serial:\n            self.serial.write(data)\n        else:\n            logger.warning(f\"Couldn't transmit data: {data!r}, Eyes aren't connected\")\n\n\n    @property\n    def callback(self) -&gt; Callable[[str, str | None], Any] | None:\n        return self._callback\n\n    @callback.setter\n    def callback(self, callback: Callable[[str, str | None], Any]) -&gt; None:\n        self._callback = callback\n\n    def _setup_serial(self, port: str, baud: int, timeout: float = 1):\n        self.serial = Serial(port, baud, timeout=timeout)\n        return self.serial\n\n    def _rx_loop(self, serial: Serial, delimeter: str = \"=\"):\n        while True:\n            try:\n                raw: bytes = serial.readline()\n            except TypeError:\n                # serial has been stopped\n                return\n\n            cmd: str = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[0].strip().replace('\\00', '')\n            if not cmd:\n                continue\n\n            val: str | None = None\n            if len(raw.decode(\"utf-8\").split(delimeter)) &gt; 1:\n                val = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[1].strip(\"\\r\\n\").replace('\\00', '')\n\n            if cmd.startswith(\"eyeSettings.\"):\n                # Remove prefix and split into path and value\n                setting = cmd[len(\"eyeSettings.\"):]\n\n                path = setting.split(\".\")\n\n                if not val:\n                    logger.error(f\"Got eyeSettings command without a value: {cmd} :: {val}\")\n                    continue\n\n                # Convert the value to appropriate type\n                try:\n                    # Handle array values [x, y]\n                    if val.startswith(\"[\") and val.endswith(\"]\"):\n                        value_str = val.strip(\"[]\")\n                        value = tuple(int(x.strip()) for x in value_str.split(\",\"))\n                    # Handle hex colors\n                    elif val.startswith(\"#\"):\n                        value = val\n                    # Handle quoted strings\n                    elif val.startswith('\"') and val.endswith('\"'):\n                        value = val.strip('\"')\n                    # Handle numbers\n                    else:\n                        try:\n                            value = int(val)\n                        except ValueError:\n                            value = val\n                except Exception as e:\n                    raise ValueError(f\"Failed to parse value '{value_str}': {e!s}\")\n\n                # Create a dict representation of the settings\n                settings_dict = self._state.settings.model_dump()\n\n                # Navigate to the correct nested dictionary\n                current_dict = settings_dict\n                for i, key in enumerate(path[:-1]):\n                    if key not in current_dict:\n                        raise ValueError(f\"Invalid path: {'.'.join(path[:i+1])}\")\n                    if not isinstance(current_dict[key], dict):\n                        raise ValueError(f\"Cannot navigate through non-dict value at {'.'.join(path[:i+1])}\")\n                    current_dict = current_dict[key]\n\n                # Update the value\n                if path[-1] not in current_dict:\n                    raise ValueError(f\"Invalid setting: {'.'.join(path)}\")\n                current_dict[path[-1]] = value\n\n                # Create new settings instance with updated values\n                self._state.settings = EyeSettings.model_validate(settings_dict)\n\n            if self.callback:\n                self.callback(cmd, val)\n\n    def set_skin(self, skin: Skin):\n        \"\"\"Set the current skin\n\n        Args:\n            skin (int): Skin index\n        \"\"\"\n        self._state.settings.states.page = skin\n        self.send(f\"setState={skin.value}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes.connect","title":"<code>connect(port, baud, timeout, ser_timeout=0.5)</code>","text":"<p>Start a connection with Kevinbot Eyes</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port to use (<code>/dev/ttyUSB0</code> is standard with the typical Kevinbot Hardware)</p> required <code>baud</code> <code>int</code> <p>Baud rate to use (<code>115200</code> is typical for the defualt eye configs)</p> required <code>timeout</code> <code>float</code> <p>Timeout for handshake</p> required <code>ser_timeout</code> <code>float</code> <p>Readline timeout, should be lower than <code>timeout</code>. Defaults to 0.5.</p> <code>0.5</code> <p>Raises:</p> Type Description <code>HandshakeTimeoutException</code> <p>Eyes didn't respond to the connection handshake before the timeout</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def connect(\n    self,\n    port: str,\n    baud: int,\n    timeout: float,\n    ser_timeout: float = 0.5,\n):\n    \"\"\"Start a connection with Kevinbot Eyes\n\n    Args:\n        port (str): Serial port to use (`/dev/ttyUSB0` is standard with the typical Kevinbot Hardware)\n        baud (int): Baud rate to use (`115200` is typical for the defualt eye configs)\n        timeout (float): Timeout for handshake\n        ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n\n    Raises:\n        HandshakeTimeoutException: Eyes didn't respond to the connection handshake before the timeout\n    \"\"\"\n    serial = self._setup_serial(port, baud, ser_timeout)\n\n    start_time = time.monotonic()\n    while True:\n        serial.write(b\"connectionReady\\n\")\n\n        line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n        if line == \"handshake.request\":\n            serial.write(b\"getSettings=true\\n\")\n            serial.write(b\"handshake.complete\\n\")\n            break\n\n        if time.monotonic() - start_time &gt; timeout:\n            msg = \"Handshake timed out\"\n            raise HandshakeTimeoutException(msg)\n\n        time.sleep(0.1)  # Avoid spamming the connection\n\n    # Data rx thread\n    self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n    self.rx_thread.name = \"KevinbotLib.Eyes.Rx\"\n    self.rx_thread.start()\n\n    self._state.connected = True\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes.send","title":"<code>send(data)</code>","text":"<p>Send a string through serial.</p> <p>Automatically adds a newline.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Send a string through serial.\n\n    Automatically adds a newline.\n\n    Args:\n        data (str): Data to send\n    \"\"\"\n    self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes.raw_tx","title":"<code>raw_tx(data)</code>","text":"<p>Send raw bytes over serial.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw data</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def raw_tx(self, data: bytes):\n    \"\"\"Send raw bytes over serial.\n\n    Args:\n        data (bytes): Raw data\n    \"\"\"\n    if self.serial:\n        self.serial.write(data)\n    else:\n        logger.warning(f\"Couldn't transmit data: {data!r}, Eyes aren't connected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes.set_skin","title":"<code>set_skin(skin)</code>","text":"<p>Set the current skin</p> <p>Parameters:</p> Name Type Description Default <code>skin</code> <code>int</code> <p>Skin index</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def set_skin(self, skin: Skin):\n    \"\"\"Set the current skin\n\n    Args:\n        skin (int): Skin index\n    \"\"\"\n    self._state.settings.states.page = skin\n    self.send(f\"setState={skin.value}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio","title":"<code>WirelessRadio</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>class WirelessRadio(BaseKevinbotSubsystem):\n    def __init__(self, robot: SerialKevinbot, port: str, baud: int, api: int, timeout: float) -&gt; None:\n        \"\"\"Initialize Kevinbot Wireless Radio (XBee)\n\n        Args:\n            robot (Kevinbot): The main robot class\n            port (str): Serial port to connect to `/dev/ttyAMA0` for typical Kevinbot hardware\n            baud (int): Baud rate for serial interface `921600` for typical Kevinbot configs\n            api (int): API mode for xbee interface `2` for typical Kevinbot configs (`0` isn't supported yet)\n            timeout (float): Timeout for serial operations\n        \"\"\"\n        super().__init__(robot)\n\n        if api not in [1, 2]:\n            logger.error(f\"XBee API Mode {api} isn't supported. Assuming API escaped (2)\")\n            api = 2\n\n        self.callback: Callable | None = None\n\n        self.serial = Serial(port, baud, timeout=timeout)\n        self.xbee = xbee.XBee(self.serial, callback=self.callback)\n\n    def get(self) -&gt; dict:\n        \"\"\"Get the latest packet (blocking)\n\n        Returns:\n            dict: Data packet\n        \"\"\"\n        return self.xbee.wait_read_frame()\n\n    def disconnect(self):\n        \"\"\"Disconnect robot radio, and halt processing\"\"\"\n        self.xbee.halt()\n        self.serial.close()\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio.__init__","title":"<code>__init__(robot, port, baud, api, timeout)</code>","text":"<p>Initialize Kevinbot Wireless Radio (XBee)</p> <p>Parameters:</p> Name Type Description Default <code>robot</code> <code>Kevinbot</code> <p>The main robot class</p> required <code>port</code> <code>str</code> <p>Serial port to connect to <code>/dev/ttyAMA0</code> for typical Kevinbot hardware</p> required <code>baud</code> <code>int</code> <p>Baud rate for serial interface <code>921600</code> for typical Kevinbot configs</p> required <code>api</code> <code>int</code> <p>API mode for xbee interface <code>2</code> for typical Kevinbot configs (<code>0</code> isn't supported yet)</p> required <code>timeout</code> <code>float</code> <p>Timeout for serial operations</p> required Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>def __init__(self, robot: SerialKevinbot, port: str, baud: int, api: int, timeout: float) -&gt; None:\n    \"\"\"Initialize Kevinbot Wireless Radio (XBee)\n\n    Args:\n        robot (Kevinbot): The main robot class\n        port (str): Serial port to connect to `/dev/ttyAMA0` for typical Kevinbot hardware\n        baud (int): Baud rate for serial interface `921600` for typical Kevinbot configs\n        api (int): API mode for xbee interface `2` for typical Kevinbot configs (`0` isn't supported yet)\n        timeout (float): Timeout for serial operations\n    \"\"\"\n    super().__init__(robot)\n\n    if api not in [1, 2]:\n        logger.error(f\"XBee API Mode {api} isn't supported. Assuming API escaped (2)\")\n        api = 2\n\n    self.callback: Callable | None = None\n\n    self.serial = Serial(port, baud, timeout=timeout)\n    self.xbee = xbee.XBee(self.serial, callback=self.callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio.get","title":"<code>get()</code>","text":"<p>Get the latest packet (blocking)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Data packet</p> Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>def get(self) -&gt; dict:\n    \"\"\"Get the latest packet (blocking)\n\n    Returns:\n        dict: Data packet\n    \"\"\"\n    return self.xbee.wait_read_frame()\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect robot radio, and halt processing</p> Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect robot radio, and halt processing\"\"\"\n    self.xbee.halt()\n    self.serial.close()\n</code></pre>"},{"location":"reference/#kevinbotlib.states.CoreErrors","title":"<code>CoreErrors</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Kevinbot Core Error States</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class CoreErrors(Enum):\n    \"\"\"\n    Kevinbot Core Error States\n    \"\"\"\n\n    OK = 0\n    \"\"\"No errors are present\"\"\"\n    UNKNOWN = 1\n    \"\"\"Error state unknown\"\"\"\n    OW_SHORT = 2\n    \"\"\"One-Wire bus is shorted\"\"\"\n    OW_ERROR = 3\n    \"\"\"One-Wire bus error\"\"\"\n    OW_DNF = 4\n    \"\"\"One-Wire device not found\"\"\"\n    LCD_INIT_FAIL = 5\n    \"\"\"LCD Init failed\"\"\"\n    PCA_INIT_FAIL = 6\n    \"\"\"PCA9685 (servos) init fail\"\"\"\n    TICK_FAIL = 7\n    \"\"\"Failure to recieve core tick\"\"\"\n    QUEUE_OVERRUN = 8\n    \"\"\"Serial queue overrun\"\"\"\n    ESTOP = 9\n    \"\"\"Core is in E-Stop state\"\"\"\n    BME_CHIP_ID = 10\n    \"\"\"Error getting environment sensor chip id\"\"\"\n    BME_CALIB_NVM = 11\n    \"\"\"Error with environment sensor calibration\"\"\"\n    BME_CALIB_TP = 12\n    \"\"\"Error with environment sensor calibration\"\"\"\n    BME_CALIB_HUM = 13\n    \"\"\"Error with environment sensor calibration\"\"\"\n    BME_THP = 14\n    \"\"\"Error with environment sensor\"\"\"\n    BME_MEAS_TIMEOUT = 15\n    \"\"\"Timeout with environment sensor measurement\"\"\"\n    BME_NOT_NORMAL_MODE = 16\n    \"\"\"Environemnt sensor is not in normal mode\"\"\"\n    BATT1_UV = 17\n    \"\"\"Battery #1 Undervoltage\"\"\"\n    BATT1_OV = 18\n    \"\"\"Battery #1 Overvoltage\"\"\"\n    BATT2_UV = 19\n    \"\"\"Battery #2 Undervoltage\"\"\"\n    BATT2_OV = 20\n    \"\"\"Battery #2 Overvoltage\"\"\"\n    BATT_UV = 21\n    \"\"\"Battery Undervoltage (single battery mode)\"\"\"\n    BATT_OV = 22\n    \"\"\"Battery Overvoltage (single battery mode)\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No errors are present</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error state unknown</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OW_SHORT","title":"<code>OW_SHORT = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire bus is shorted</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OW_ERROR","title":"<code>OW_ERROR = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire bus error</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OW_DNF","title":"<code>OW_DNF = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire device not found</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.LCD_INIT_FAIL","title":"<code>LCD_INIT_FAIL = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>LCD Init failed</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.PCA_INIT_FAIL","title":"<code>PCA_INIT_FAIL = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PCA9685 (servos) init fail</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.TICK_FAIL","title":"<code>TICK_FAIL = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Failure to recieve core tick</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.QUEUE_OVERRUN","title":"<code>QUEUE_OVERRUN = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Serial queue overrun</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.ESTOP","title":"<code>ESTOP = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Core is in E-Stop state</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BME_CHIP_ID","title":"<code>BME_CHIP_ID = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error getting environment sensor chip id</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BME_CALIB_NVM","title":"<code>BME_CALIB_NVM = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error with environment sensor calibration</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BME_CALIB_TP","title":"<code>BME_CALIB_TP = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error with environment sensor calibration</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BME_CALIB_HUM","title":"<code>BME_CALIB_HUM = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error with environment sensor calibration</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BME_THP","title":"<code>BME_THP = 14</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error with environment sensor</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BME_MEAS_TIMEOUT","title":"<code>BME_MEAS_TIMEOUT = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Timeout with environment sensor measurement</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BME_NOT_NORMAL_MODE","title":"<code>BME_NOT_NORMAL_MODE = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Environemnt sensor is not in normal mode</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BATT1_UV","title":"<code>BATT1_UV = 17</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery #1 Undervoltage</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BATT1_OV","title":"<code>BATT1_OV = 18</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery #1 Overvoltage</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BATT2_UV","title":"<code>BATT2_UV = 19</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery #2 Undervoltage</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BATT2_OV","title":"<code>BATT2_OV = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery #2 Overvoltage</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BATT_UV","title":"<code>BATT_UV = 21</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery Undervoltage (single battery mode)</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.BATT_OV","title":"<code>BATT_OV = 22</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery Overvoltage (single battery mode)</p>"},{"location":"reference/#kevinbotlib.states.MotorDriveStatus","title":"<code>MotorDriveStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of each motor in the drivebase</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class MotorDriveStatus(Enum):\n    \"\"\"\n    The status of each motor in the drivebase\n    \"\"\"\n\n    UNKNOWN = 10\n    \"\"\"Motor status is unknown\"\"\"\n    MOVING = 11\n    \"\"\"Motor is rotating\"\"\"\n    HOLDING = 12\n    \"\"\"Motor is holding at position\"\"\"\n    OFF = 13\n    \"\"\"Motor is off\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.states.MotorDriveStatus.UNKNOWN","title":"<code>UNKNOWN = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Motor status is unknown</p>"},{"location":"reference/#kevinbotlib.states.MotorDriveStatus.MOVING","title":"<code>MOVING = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Motor is rotating</p>"},{"location":"reference/#kevinbotlib.states.MotorDriveStatus.HOLDING","title":"<code>HOLDING = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Motor is holding at position</p>"},{"location":"reference/#kevinbotlib.states.MotorDriveStatus.OFF","title":"<code>OFF = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Motor is off</p>"},{"location":"reference/#kevinbotlib.states.BmsBatteryState","title":"<code>BmsBatteryState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of a single battery attached to the BMS</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class BmsBatteryState(Enum):\n    \"\"\"\n    The status of a single battery attached to the BMS\n    \"\"\"\n\n    UNKNOWN = 0\n    \"\"\"State is unknown (usually at bootup)\"\"\"\n    NORMAL = 1\n    \"\"\"Battery is normal\"\"\"\n    UNDER = 2\n    \"\"\"Battery is undervoltage\"\"\"\n    OVER = 3\n    \"\"\"Battery is overvoltage\"\"\"\n    STOPPED = 4  # Stopped state if BMS driver crashed\n    \"\"\"BMS has crashed or stopped\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.states.BmsBatteryState.UNKNOWN","title":"<code>UNKNOWN = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>State is unknown (usually at bootup)</p>"},{"location":"reference/#kevinbotlib.states.BmsBatteryState.NORMAL","title":"<code>NORMAL = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery is normal</p>"},{"location":"reference/#kevinbotlib.states.BmsBatteryState.UNDER","title":"<code>UNDER = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery is undervoltage</p>"},{"location":"reference/#kevinbotlib.states.BmsBatteryState.OVER","title":"<code>OVER = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery is overvoltage</p>"},{"location":"reference/#kevinbotlib.states.BmsBatteryState.STOPPED","title":"<code>STOPPED = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>BMS has crashed or stopped</p>"},{"location":"reference/#kevinbotlib.states.DrivebaseState","title":"<code>DrivebaseState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the drivebase as a whole</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class DrivebaseState(BaseModel):\n    \"\"\"The state of the drivebase as a whole\"\"\"\n\n    left_power: int = 0\n    \"\"\"Current power of the left motor\"\"\"\n    right_power: int = 0\n    \"\"\"Current power of the right motor\"\"\"\n    amps: list[float] = Field(default_factory=lambda: [0, 0])\n    \"\"\"Current amps for both motors\"\"\"\n    watts: list[float] = Field(default_factory=lambda: [0, 0])\n    \"\"\"Current watts for both motors\"\"\"\n    status: list[MotorDriveStatus] = Field(default_factory=lambda: [MotorDriveStatus.UNKNOWN, MotorDriveStatus.UNKNOWN])\n    \"\"\"Current status for both motors\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.states.DrivebaseState.left_power","title":"<code>left_power: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current power of the left motor</p>"},{"location":"reference/#kevinbotlib.states.DrivebaseState.right_power","title":"<code>right_power: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current power of the right motor</p>"},{"location":"reference/#kevinbotlib.states.DrivebaseState.amps","title":"<code>amps: list[float] = Field(default_factory=lambda: [0, 0])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current amps for both motors</p>"},{"location":"reference/#kevinbotlib.states.DrivebaseState.watts","title":"<code>watts: list[float] = Field(default_factory=lambda: [0, 0])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current watts for both motors</p>"},{"location":"reference/#kevinbotlib.states.DrivebaseState.status","title":"<code>status: list[MotorDriveStatus] = Field(default_factory=lambda: [MotorDriveStatus.UNKNOWN, MotorDriveStatus.UNKNOWN])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current status for both motors</p>"},{"location":"reference/#kevinbotlib.states.ServoState","title":"<code>ServoState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the servo subsystem</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class ServoState(BaseModel):\n    \"\"\"The state of the servo subsystem\"\"\"\n\n    angles: list[int] = Field(default_factory=lambda: [-1] * 32)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.BMState","title":"<code>BMState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the BMS (Battery Management System)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class BMState(BaseModel):\n    \"\"\"The state of the BMS (Battery Management System)\"\"\"\n\n    voltages: list[float] = Field(default_factory=lambda: [0.0, 0.0])\n    raw_voltages: list[float] = Field(default_factory=lambda: [0.0, 0.0])\n    states: list[BmsBatteryState] = Field(default_factory=lambda: [BmsBatteryState.UNKNOWN, BmsBatteryState.UNKNOWN])\n</code></pre>"},{"location":"reference/#kevinbotlib.states.IMUState","title":"<code>IMUState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the IMU (Inertial Measurement System)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class IMUState(BaseModel):\n    \"\"\"The state of the IMU (Inertial Measurement System)\"\"\"\n\n    accel: list[int] = Field(default_factory=lambda: [-1] * 3)  # X Y Z\n    gyro: list[int] = Field(default_factory=lambda: [-1] * 3)  # R P Y\n</code></pre>"},{"location":"reference/#kevinbotlib.states.ThermometerState","title":"<code>ThermometerState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the DS18B20 Thermometers (does not include BME280)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class ThermometerState(BaseModel):\n    \"\"\"The state of the DS18B20 Thermometers (does not include BME280)\"\"\"\n\n    left_motor: float = -1\n    right_motor: float = -1\n    internal: float = -1\n</code></pre>"},{"location":"reference/#kevinbotlib.states.EnviroState","title":"<code>EnviroState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the BME280 Envoronmental sensor</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class EnviroState(BaseModel):\n    \"\"\"The state of the BME280 Envoronmental sensor\"\"\"\n\n    temperature: float = -1\n    humidity: float = 0\n    pressure: int = 0\n</code></pre>"},{"location":"reference/#kevinbotlib.states.LightingState","title":"<code>LightingState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of Kevinbot's led segments</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class LightingState(BaseModel):\n    \"\"\"The state of Kevinbot's led segments\"\"\"\n\n    camera: int = 0\n    head_effect: str = \"unknown\"\n    head_bright: int = 0\n    head_update: int = -1\n    head_color1: list[int] = Field(default=[0, 0, 0], min_length=3)\n    head_color2: list[int] = Field(default=[0, 0, 0], min_length=3)\n    body_effect: str = \"unknown\"\n    body_bright: int = 0\n    body_update: int = -1\n    body_color1: list[int] = Field(default=[0, 0, 0], min_length=3)\n    body_color2: list[int] = Field(default=[0, 0, 0], min_length=3)\n    base_effect: str = \"unknown\"\n    base_bright: int = 0\n    base_update: int = -1\n    base_color1: list[int] = Field(default=[0, 0, 0], min_length=3)\n    base_color2: list[int] = Field(default=[0, 0, 0], min_length=3)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.KevinbotState","title":"<code>KevinbotState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the robot as a whole</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class KevinbotState(BaseModel):\n    \"\"\"The state of the robot as a whole\"\"\"\n\n    connected: bool = False\n    enabled: bool = False\n    error: CoreErrors = CoreErrors.OK\n    estop: bool = False\n    uptime: int = 0\n    uptime_ms: int = 0\n    motion: DrivebaseState = Field(default_factory=DrivebaseState)\n    servos: ServoState = Field(default_factory=ServoState)\n    battery: BMState = Field(default_factory=BMState)\n    imu: IMUState = Field(default_factory=IMUState)\n    thermal: ThermometerState = Field(default_factory=ThermometerState)\n    enviro: EnviroState = Field(default_factory=EnviroState)\n    lighting: LightingState = Field(default_factory=LightingState)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.KevinbotEyesState","title":"<code>KevinbotEyesState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the eye system</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class KevinbotEyesState(BaseModel):\n    \"\"\"The state of the eye system\"\"\"\n\n    connected: bool = False\n    settings: EyeSettings = EyeSettings()\n</code></pre>"},{"location":"reference/#kevinbotlib.states.KevinbotServerState","title":"<code>KevinbotServerState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state system used internally in the Kevinbot Server</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class KevinbotServerState(BaseModel):\n    \"\"\"The state system used internally in the Kevinbot Server\"\"\"\n\n    mqtt_connected: bool = False\n    clients: int = 0\n    connected_cids: list[str] = []\n    last_driver_cid: str | None = None\n    driver_cid: str | None = None\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.HandshakeTimeoutException","title":"<code>HandshakeTimeoutException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when the connection handshake times out</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class HandshakeTimeoutException(BaseException):\n    \"\"\"Exception that is produced when the connection handshake times out\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.config.ConfigLocation","title":"<code>ConfigLocation</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum to represent the location of the config file</p> Source code in <code>src/kevinbotlib/config.py</code> <pre><code>class ConfigLocation(Enum):\n    \"\"\"Enum to represent the location of the config file\"\"\"\n\n    USER = \"user\"\n    SYSTEM = \"system\"\n    AUTO = \"auto\"\n    NONE = \"none\"\n    MANUAL = \"manual\"\n</code></pre>"},{"location":"reference/#kevinbotlib.config.KevinbotConfig","title":"<code>KevinbotConfig</code>","text":"Source code in <code>src/kevinbotlib/config.py</code> <pre><code>class KevinbotConfig:\n    def __init__(self, location: ConfigLocation = ConfigLocation.AUTO, path: str | Path | None = None):\n        self.config_location = location\n\n        self.user_config_path = Path(user_config_dir(\"kevinbotlib\")) / \"settings.yaml\"\n        self.system_config_path = Path(site_config_dir(\"kevinbotlib\")) / \"settings.yaml\"\n\n        self.manual_path: Path | None = None\n        if path:\n            self.manual_path = Path(path)\n\n        self.config_path = self._get_config_path()\n\n        self.config: dict = {}\n\n        self.mqtt: _MQTT = _MQTT({}, self)\n        self.core: _Core = _Core({}, self)\n        self.xbee: _XBee = _XBee({}, self)\n        self.server: _Server = _Server({}, self)\n\n        self.load()\n\n    def _get_config_path(self) -&gt; Path | None:\n        \"\"\"Get the optimal configuration path\n\n        Returns:\n            Path | None: File location\n        \"\"\"\n        if self.config_location == ConfigLocation.NONE:\n            return None\n        if self.config_location == ConfigLocation.MANUAL:\n            if self.manual_path:\n                return Path(self.manual_path)\n            logger.warning(\"ConfigLocation.MANUAL set without config path, defaulting to ConfigLocation.NONE\")\n            return None  # should never happen\n        if self.config_location == ConfigLocation.USER:\n            return self.user_config_path\n        if self.config_location == ConfigLocation.SYSTEM:\n            return self.system_config_path\n        # AUTO: Prefer user, else system, if none, return user\n        if self.user_config_path.exists():\n            return self.user_config_path\n        if self.system_config_path.exists():\n            return self.system_config_path\n        return self.user_config_path\n\n    def load(self) -&gt; None:\n        if self.config_path and self.config_path.exists():\n            with open(self.config_path) as file:\n                self.config = yaml.safe_load(file) or {}\n\n        self.mqtt = _MQTT(self.config.get(\"mqtt\", {}), self)\n        self.core = _Core(self.config.get(\"core\", {}), self)\n        self.xbee = _XBee(self.config.get(\"xbee\", {}), self)\n        self.server = _Server(self.config.get(\"server\", {}), self)\n\n    def save(self) -&gt; None:\n        if self.config_path:\n            with open(self.config_path, \"w\") as file:\n                yaml.dump(self._get_data(), file, default_flow_style=False)\n        else:\n            logger.error(\"Couldn't save configuration to empty path\")\n\n    def dump(self) -&gt; str:\n        \"\"\"Dump configuration\n\n        Returns:\n            str: YAML\n        \"\"\"\n        return yaml.dump(self._get_data(), default_flow_style=False)\n\n    def _get_data(self):\n        return {\n            \"mqtt\": self.mqtt.data,\n            \"core\": self.core.data,\n            \"xbee\": self.xbee.data,\n            \"server\": self.server.data,\n        }\n\n    def __repr__(self):\n        return f\"{super().__repr__()}\\n\\n{yaml.dump(self._get_data(), default_flow_style=False)}\"\n</code></pre>"},{"location":"reference/#kevinbotlib.config.KevinbotConfig.dump","title":"<code>dump()</code>","text":"<p>Dump configuration</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>YAML</p> Source code in <code>src/kevinbotlib/config.py</code> <pre><code>def dump(self) -&gt; str:\n    \"\"\"Dump configuration\n\n    Returns:\n        str: YAML\n    \"\"\"\n    return yaml.dump(self._get_data(), default_flow_style=False)\n</code></pre>"},{"location":"subsystems/","title":"Subsystems","text":""},{"location":"subsystems/#what-is-a-subsystem","title":"What is a Subsystem?","text":"<p>A subsystem is a child component of a system</p> <p>All connection and state logic is handled in it's root system.</p>"},{"location":"subsystems/drivebase/","title":"Drivebase","text":""},{"location":"subsystems/lighting/","title":"Lighting","text":""},{"location":"subsystems/servos/","title":"Servos","text":""},{"location":"systems/","title":"Systems","text":""},{"location":"systems/#what-is-a-system","title":"What is a System?","text":"<p>A system is a root component that is used in KevinbotLib. </p> <p>In the case of serial communication, KevinbotLib will have to connect to it separately from another system.</p> <p>When using MQTT communication, you will need to pass in the Kevinbot system.</p> <p>A system will contain it's own state management, connection system, and subsystems.</p>"},{"location":"systems/eyes/","title":"Eyes (System)","text":""},{"location":"systems/kevinbot/","title":"Kevinbot (System)","text":"<p>The Kevinbot system is the main system and controller. It is designed to use the Kevinbot Core.</p> <p>It supports serial communication and MQTT communication using SerialKevinbot and MqttKevinbot respectively.</p>"}]}