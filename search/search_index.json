{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KevinbotLib","text":"<p>This library consists of classes to operate Kevinbot v3.</p> <p>Development</p> <p>This project is in the early stage of development. There are many missing functions that will be supported in the future.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"cli/","title":"Command Line","text":"<p>KevinbotLib features multiple command line utilities:</p> <ul> <li>KevinbotLib Server</li> <li>MQTT Listener</li> </ul> <p>tbd</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#kevinbotlib.core.BaseKevinbotSubsystem","title":"<code>BaseKevinbotSubsystem</code>","text":"<p>The base subsystem class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class BaseKevinbotSubsystem:\n    \"\"\"The base subsystem class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self, robot: \"Kevinbot\") -&gt; None:\n        self.robot = robot\n        self.robot._register_component(self)  # noqa: SLF001\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot","title":"<code>Kevinbot</code>","text":"<p>The main robot class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Kevinbot:\n    \"\"\"The main robot class\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._state = KevinbotState()\n        self._subsystems: list[BaseKevinbotSubsystem] = []\n\n        self.serial: Serial | None = None\n        self.rx_thread: Thread | None = None\n\n        self._auto_disconnect = True\n        atexit.register(self.disconnect)\n\n    def connect(\n        self,\n        port: str,\n        baud: int,\n        timeout: float,\n        tick_interval: float,\n        ser_timeout: float = 0.5,\n        *,\n        tick_thread: bool = True,\n    ):\n        \"\"\"Start a connection with Kevinbot Core\n\n        Args:\n            port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n            baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n            timeout (float): Timeout for handshake\n            tick_interval (float): How often a heartbeat should be produced\n            ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n            tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n        Raises:\n            HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n        \"\"\"\n        serial = self._setup_serial(port, baud, ser_timeout)\n\n        start_time = time.monotonic()\n        while True:\n            serial.write(b\"connection.isready=0\\n\")\n\n            line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n            if line == \"ready\":\n                serial.write(b\"connection.start\\n\")\n                serial.write(b\"core.errors.clear\\n\")\n                serial.write(b\"connection.ok\\n\")\n                break\n\n            if time.monotonic() - start_time &gt; timeout:\n                msg = \"Handshake timed out\"\n                raise HandshakeTimeoutException(msg)\n\n            time.sleep(0.1)  # Avoid spamming the connection\n\n        # Data rx thread\n        self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n        self.rx_thread.name = \"KevinbotLib.Rx\"\n        self.rx_thread.start()\n\n        if tick_thread:\n            thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n            thread.start()\n            thread.name = \"KevinbotLib.Tick\"\n\n        self._state.connected = True\n\n    def disconnect(self):\n        \"\"\"Disconnect core gracefully\"\"\"\n        self._state.connected = False\n        if self.serial:\n            self.serial.write(b\"core.link.unlink\\n\")\n            self.serial.flush()\n            self.serial.close()\n        else:\n            logger.warning(\"Already disconnected\")\n\n    def request_enable(self) -&gt; int:\n        \"\"\"Request the core to enable\n\n        Returns:\n            int: -1 = core disconnected, -2 = core in error state, 1 = enable requested\n        \"\"\"\n        if not self.serial:\n            logger.error(\"Couldn't request state change, please use connect() first\")\n            return -1\n        if self._state.error != CoreErrors.OK:\n            logger.error(\"Couldn't request state change, core is in an error state\")\n            return -2\n        self.serial.write(b\"kevinbot.tryenable=1\\n\")\n        return 1\n\n    def request_disable(self) -&gt; int:\n        \"\"\"Request the core to disable\n\n        Returns:\n            int: -1 = core disconnected, -2 = core in error state, 1 = disable requested\n        \"\"\"\n        if not self.serial:\n            logger.error(\"Couldn't request state change, please use connect() first\")\n            return -1\n        if self._state.error != CoreErrors.OK:\n            logger.error(\"Couldn't request state change, core is in an error state\")\n            return -2\n        self.serial.write(b\"kevinbot.tryenable=0\\n\")\n        return 1\n\n    def e_stop(self):\n        \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n        if not self.serial:\n            logger.error(\"Couldn't send e-stop, please use connect() first\")\n            return\n\n        self.serial.write(b\"system.estop\\n\")\n\n    def tick_loop(self, interval: float = 1):\n        \"\"\"Send ticks indefinetely\n\n        Args:\n            interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n        \"\"\"\n        while True:\n            self._tick()\n            time.sleep(interval)\n\n    def get_state(self) -&gt; KevinbotState:\n        \"\"\"Gets the current state of the robot\n\n        Returns:\n            KevinbotState: State class\n        \"\"\"\n        return self._state\n\n    def send(self, data: str):\n        \"\"\"Send a string through serial.\n\n        Automatically adds a newline.\n\n        Args:\n            data (str): Data to send\n        \"\"\"\n        self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n\n    def raw_tx(self, data: bytes):\n        \"\"\"Send raw bytes over serial.\n\n        Args:\n            data (bytes): Raw data\n        \"\"\"\n        if self.serial:\n            self.serial.write(data)\n        else:\n            logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n\n    @property\n    def auto_disconnect(self) -&gt; bool:\n        \"\"\"Getter for auto disconnect state.\n\n        Returns:\n            bool: Whether to disconnect on application exit\n        \"\"\"\n        return self._auto_disconnect\n\n    @auto_disconnect.setter\n    def auto_disconnect(self, value: bool):\n        \"\"\"Setter for auto disconnect.\n\n        Args:\n            value (bool): Whether to disconnect on application exit\n        \"\"\"\n        self._auto_disconnect = value\n        if value:\n            atexit.register(self.disconnect)\n        else:\n            atexit.unregister(self.disconnect)\n\n    def _rx_loop(self, serial: Serial, delimeter: str = \"=\"):\n        while True:\n            raw: bytes = serial.readline()\n            cmd: str = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[0]\n\n            val: str | None = None\n            if len(raw.decode(\"utf-8\").split(delimeter)) &gt; 1:\n                val = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[1].strip(\"\\r\\n\")\n\n            match cmd:\n                case \"ready\\n\":\n                    pass\n                case \"core.enabled\":\n                    if not val:\n                        logger.warning(\"No value recieved for 'core.enabled'\")\n                        continue\n                    if val.lower() in [\"true\", \"t\", \"1\"]:\n                        self._state.enabled = True\n                    else:\n                        self._state.enabled = False\n                case \"core.uptime\":\n                    if val:\n                        self._state.uptime = int(val)\n                case \"core.uptime_ms\":\n                    if val:\n                        self._state.uptime_ms = int(val)\n                case \"motors.amps\":\n                    if val:\n                        self._state.motion.amps = list(map(float, val.split(\",\")))\n                case \"motors.watts\":\n                    if val:\n                        self._state.motion.watts = list(map(float, val.split(\",\")))\n                case \"motors.status\":\n                    if val:\n                        self._state.motion.status = [MotorDriveStatus(int(x)) for x in val.split(\",\")]\n                case \"bms.voltages\":\n                    if val:\n                        self._state.battery.voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.raw_voltages\":\n                    if val:\n                        self._state.battery.raw_voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.status\":\n                    if val:\n                        self._state.battery.states = [BmsBatteryState(int(x)) for x in val.split(\",\")]\n                case \"sensors.gyro\":\n                    if val:\n                        self._state.imu.gyro = [int(x) for x in val.split(\",\")]\n                case \"sensors.accel\":\n                    if val:\n                        self._state.imu.accel = [int(x) for x in val.split(\",\")]\n                case \"sensors.temps\":\n                    if val:\n                        temps = val.split(\",\")\n                        for temp in temps:\n                            if not re.match(\"^[-+]?[0-9]+$\", temp):\n                                logger.error(f\"Found non-integer value in temps, {temps}\")\n                                continue\n\n                        self._state.thermal.left_motor = Temperature(int(temps[0]) / 100)\n                        self._state.thermal.right_motor = Temperature(int(temps[1]) / 100)\n                        self._state.thermal.internal = Temperature(int(temps[2]) / 100)\n                case \"sensors.bme\":\n                    if val:\n                        vals = val.split(\",\")\n                        for value in vals:\n                            if not re.match(\"^[-+]?[0-9]+$\", value):\n                                logger.error(f\"Found non-integer value in bme values, {temps}\")\n                                continue\n\n                        self._state.enviro.temperature = Temperature(int(vals[0]))\n                        self._state.enviro.humidity = int(vals[2])\n                        self._state.enviro.pressure = int(vals[3])\n                case _:\n                    logger.warning(f\"Got a command that isn't supported yet: {cmd} with value {val}\")\n\n    def _setup_serial(self, port: str, baud: int, timeout: float = 1):\n        self.serial = Serial(port, baud, timeout=timeout)\n        return self.serial\n\n    def _tick(self):\n        if self.serial:\n            self.serial.write(b\"core.tick\\n\")\n\n    def _register_component(self, component: BaseKevinbotSubsystem):\n        self._subsystems.append(component)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.auto_disconnect","title":"<code>auto_disconnect: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for auto disconnect state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to disconnect on application exit</p>"},{"location":"reference/#kevinbotlib.core.Kevinbot.connect","title":"<code>connect(port, baud, timeout, tick_interval, ser_timeout=0.5, *, tick_thread=True)</code>","text":"<p>Start a connection with Kevinbot Core</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port to use (<code>/dev/ttyAMA2</code> is standard with the typical Kevinbot Hardware)</p> required <code>baud</code> <code>int</code> <p>Baud rate to use (<code>921600</code> is typical for the defualt Core configs)</p> required <code>timeout</code> <code>float</code> <p>Timeout for handshake</p> required <code>tick_interval</code> <code>float</code> <p>How often a heartbeat should be produced</p> required <code>ser_timeout</code> <code>float</code> <p>Readline timeout, should be lower than <code>timeout</code>. Defaults to 0.5.</p> <code>0.5</code> <code>tick_thread</code> <code>bool</code> <p>Whether a tick thread should be started. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>HandshakeTimeoutException</code> <p>Core didn't respond to the connection handshake before the timeout</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def connect(\n    self,\n    port: str,\n    baud: int,\n    timeout: float,\n    tick_interval: float,\n    ser_timeout: float = 0.5,\n    *,\n    tick_thread: bool = True,\n):\n    \"\"\"Start a connection with Kevinbot Core\n\n    Args:\n        port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n        baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n        timeout (float): Timeout for handshake\n        tick_interval (float): How often a heartbeat should be produced\n        ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n        tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n    Raises:\n        HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n    \"\"\"\n    serial = self._setup_serial(port, baud, ser_timeout)\n\n    start_time = time.monotonic()\n    while True:\n        serial.write(b\"connection.isready=0\\n\")\n\n        line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n        if line == \"ready\":\n            serial.write(b\"connection.start\\n\")\n            serial.write(b\"core.errors.clear\\n\")\n            serial.write(b\"connection.ok\\n\")\n            break\n\n        if time.monotonic() - start_time &gt; timeout:\n            msg = \"Handshake timed out\"\n            raise HandshakeTimeoutException(msg)\n\n        time.sleep(0.1)  # Avoid spamming the connection\n\n    # Data rx thread\n    self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n    self.rx_thread.name = \"KevinbotLib.Rx\"\n    self.rx_thread.start()\n\n    if tick_thread:\n        thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n        thread.start()\n        thread.name = \"KevinbotLib.Tick\"\n\n    self._state.connected = True\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect core gracefully</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect core gracefully\"\"\"\n    self._state.connected = False\n    if self.serial:\n        self.serial.write(b\"core.link.unlink\\n\")\n        self.serial.flush()\n        self.serial.close()\n    else:\n        logger.warning(\"Already disconnected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.request_enable","title":"<code>request_enable()</code>","text":"<p>Request the core to enable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>-1 = core disconnected, -2 = core in error state, 1 = enable requested</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_enable(self) -&gt; int:\n    \"\"\"Request the core to enable\n\n    Returns:\n        int: -1 = core disconnected, -2 = core in error state, 1 = enable requested\n    \"\"\"\n    if not self.serial:\n        logger.error(\"Couldn't request state change, please use connect() first\")\n        return -1\n    if self._state.error != CoreErrors.OK:\n        logger.error(\"Couldn't request state change, core is in an error state\")\n        return -2\n    self.serial.write(b\"kevinbot.tryenable=1\\n\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.request_disable","title":"<code>request_disable()</code>","text":"<p>Request the core to disable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>-1 = core disconnected, -2 = core in error state, 1 = disable requested</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_disable(self) -&gt; int:\n    \"\"\"Request the core to disable\n\n    Returns:\n        int: -1 = core disconnected, -2 = core in error state, 1 = disable requested\n    \"\"\"\n    if not self.serial:\n        logger.error(\"Couldn't request state change, please use connect() first\")\n        return -1\n    if self._state.error != CoreErrors.OK:\n        logger.error(\"Couldn't request state change, core is in an error state\")\n        return -2\n    self.serial.write(b\"kevinbot.tryenable=0\\n\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.e_stop","title":"<code>e_stop()</code>","text":"<p>Attempt to send and E-Stop signal to the Core</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def e_stop(self):\n    \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n    if not self.serial:\n        logger.error(\"Couldn't send e-stop, please use connect() first\")\n        return\n\n    self.serial.write(b\"system.estop\\n\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.tick_loop","title":"<code>tick_loop(interval=1)</code>","text":"<p>Send ticks indefinetely</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>Interval between ticks in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def tick_loop(self, interval: float = 1):\n    \"\"\"Send ticks indefinetely\n\n    Args:\n        interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n    \"\"\"\n    while True:\n        self._tick()\n        time.sleep(interval)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.get_state","title":"<code>get_state()</code>","text":"<p>Gets the current state of the robot</p> <p>Returns:</p> Name Type Description <code>KevinbotState</code> <code>KevinbotState</code> <p>State class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_state(self) -&gt; KevinbotState:\n    \"\"\"Gets the current state of the robot\n\n    Returns:\n        KevinbotState: State class\n    \"\"\"\n    return self._state\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.send","title":"<code>send(data)</code>","text":"<p>Send a string through serial.</p> <p>Automatically adds a newline.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Send a string through serial.\n\n    Automatically adds a newline.\n\n    Args:\n        data (str): Data to send\n    \"\"\"\n    self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.raw_tx","title":"<code>raw_tx(data)</code>","text":"<p>Send raw bytes over serial.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw data</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def raw_tx(self, data: bytes):\n    \"\"\"Send raw bytes over serial.\n\n    Args:\n        data (bytes): Raw data\n    \"\"\"\n    if self.serial:\n        self.serial.write(data)\n    else:\n        logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase","title":"<code>Drivebase</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Drivebase subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Drivebase(BaseKevinbotSubsystem):\n    \"\"\"Drivebase subsystem for Kevinbot\"\"\"\n\n    def get_amps(self) -&gt; list[float]:\n        \"\"\"Get the amps being used by the drivebase\n\n        Returns:\n            list[float]: Amps\n        \"\"\"\n        return self.robot.get_state().motion.amps\n\n    def get_watts(self) -&gt; list[float]:\n        \"\"\"Get the watts being used by the drivebase\n\n        Returns:\n            list[float]: Watts\n        \"\"\"\n        return self.robot.get_state().motion.watts\n\n    def get_powers(self) -&gt; tuple[int, int]:\n        \"\"\"Get the currently set wheel speeds in percent\n\n        Returns:\n            tuple[int, int]: Percent values from 0 to 100\n        \"\"\"\n        return self.robot.get_state().motion.left_power, self.robot.get_state().motion.right_power\n\n    def get_states(self) -&gt; list[MotorDriveStatus]:\n        \"\"\"Get the wheels states\n\n        Returns:\n            list[MotorDriveStatus]: States\n        \"\"\"\n        return self.robot.get_state().motion.status\n\n    def drive_at_power(self, left: float, right: float):\n        \"\"\"Set the drive power for wheels. 0 to 1\n\n        Args:\n            left (float): Left motor power\n            right (float): Right motor power\n        \"\"\"\n        self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n\n    def stop(self):\n        \"\"\"Set all wheel powers to 0\"\"\"\n        self.robot.send(\"drive.stop\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_amps","title":"<code>get_amps()</code>","text":"<p>Get the amps being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Amps</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_amps(self) -&gt; list[float]:\n    \"\"\"Get the amps being used by the drivebase\n\n    Returns:\n        list[float]: Amps\n    \"\"\"\n    return self.robot.get_state().motion.amps\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_watts","title":"<code>get_watts()</code>","text":"<p>Get the watts being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Watts</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_watts(self) -&gt; list[float]:\n    \"\"\"Get the watts being used by the drivebase\n\n    Returns:\n        list[float]: Watts\n    \"\"\"\n    return self.robot.get_state().motion.watts\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_powers","title":"<code>get_powers()</code>","text":"<p>Get the currently set wheel speeds in percent</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: Percent values from 0 to 100</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_powers(self) -&gt; tuple[int, int]:\n    \"\"\"Get the currently set wheel speeds in percent\n\n    Returns:\n        tuple[int, int]: Percent values from 0 to 100\n    \"\"\"\n    return self.robot.get_state().motion.left_power, self.robot.get_state().motion.right_power\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_states","title":"<code>get_states()</code>","text":"<p>Get the wheels states</p> <p>Returns:</p> Type Description <code>list[MotorDriveStatus]</code> <p>list[MotorDriveStatus]: States</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_states(self) -&gt; list[MotorDriveStatus]:\n    \"\"\"Get the wheels states\n\n    Returns:\n        list[MotorDriveStatus]: States\n    \"\"\"\n    return self.robot.get_state().motion.status\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.drive_at_power","title":"<code>drive_at_power(left, right)</code>","text":"<p>Set the drive power for wheels. 0 to 1</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>float</code> <p>Left motor power</p> required <code>right</code> <code>float</code> <p>Right motor power</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def drive_at_power(self, left: float, right: float):\n    \"\"\"Set the drive power for wheels. 0 to 1\n\n    Args:\n        left (float): Left motor power\n        right (float): Right motor power\n    \"\"\"\n    self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.stop","title":"<code>stop()</code>","text":"<p>Set all wheel powers to 0</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def stop(self):\n    \"\"\"Set all wheel powers to 0\"\"\"\n    self.robot.send(\"drive.stop\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servo","title":"<code>Servo</code>","text":"<p>Individually controllable servo</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Servo:\n    \"\"\"Individually controllable servo\"\"\"\n\n    def __init__(self, robot: Kevinbot, index: int) -&gt; None:\n        self.robot = robot\n        self.index = index\n\n    @property\n    def bank(self) -&gt; int:\n        \"\"\"Get the bank the servo is in\n\n        Returns:\n            int: Bank number\n        \"\"\"\n        return self.index // 16\n\n    @property\n    def angle(self) -&gt; int:\n        \"\"\"Get the optimistic current servo angle\n\n        Returns:\n            int: Angle in degrees\n        \"\"\"\n        return self.robot.get_state().servos.angles[self.index]\n\n    @angle.setter\n    def angle(self, angle: int):\n        \"\"\"Set the optimistic servo angle\n\n        Args:\n            angle (int): Angle in degrees\n        \"\"\"\n        self.robot.send(f\"s={self.index},{angle}\")\n        self.robot.get_state().servos.angles[self.index] = angle\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servo.bank","title":"<code>bank: int</code>  <code>property</code>","text":"<p>Get the bank the servo is in</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Bank number</p>"},{"location":"reference/#kevinbotlib.core.Servo.angle","title":"<code>angle: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the optimistic current servo angle</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Angle in degrees</p>"},{"location":"reference/#kevinbotlib.core.Servos","title":"<code>Servos</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Servo subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Servos(BaseKevinbotSubsystem):\n    \"\"\"Servo subsystem for Kevinbot\"\"\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"Length will always be 32 since the P2 Kevinbot Board can only control 32\n\n        Returns:\n            int: Number of servos in the subsystem\n        \"\"\"\n        return 32\n\n    def __iter__(self):\n        for i in range(self.__len__()):\n            yield Servo(self.robot, i)\n\n    def __getitem__(self, index: int):\n        if index &gt; self.__len__():\n            msg = f\"Servo index {index} &gt; {self.__len__()}\"\n            raise IndexError(msg)\n        if index &lt; 0:\n            msg = f\"Servo index {index} &lt; 0\"\n            raise IndexError(msg)\n        return Servo(self.robot, index)\n\n    def get_servo(self, channel: int) -&gt; Servo:\n        \"\"\"Get an individual servo in the subsystem\n\n        Args:\n            channel (int): PWM Port\n\n        Returns:\n            Servo: Individual servo\n        \"\"\"\n        if channel &gt; self.__len__() or channel &lt; 0:\n            msg = f\"Servo channel {channel} is out of bounds.\"\n            raise IndexError(msg)\n        return Servo(self.robot, channel)\n\n    @property\n    def all(self) -&gt; int:\n        if all(i == self.robot.get_state().servos.angles[0] for i in self.robot.get_state().servos.angles):\n            return self.robot.get_state().servos.angles[0]\n        return -1\n\n    @all.setter\n    def all(self, angle: int):\n        self.robot.send(f\"servo.all={angle}\")\n        self.robot.get_state().servos.angles = [angle] * self.__len__()\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servos.__len__","title":"<code>__len__()</code>","text":"<p>Length will always be 32 since the P2 Kevinbot Board can only control 32</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of servos in the subsystem</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Length will always be 32 since the P2 Kevinbot Board can only control 32\n\n    Returns:\n        int: Number of servos in the subsystem\n    \"\"\"\n    return 32\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servos.get_servo","title":"<code>get_servo(channel)</code>","text":"<p>Get an individual servo in the subsystem</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>PWM Port</p> required <p>Returns:</p> Name Type Description <code>Servo</code> <code>Servo</code> <p>Individual servo</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_servo(self, channel: int) -&gt; Servo:\n    \"\"\"Get an individual servo in the subsystem\n\n    Args:\n        channel (int): PWM Port\n\n    Returns:\n        Servo: Individual servo\n    \"\"\"\n    if channel &gt; self.__len__() or channel &lt; 0:\n        msg = f\"Servo channel {channel} is out of bounds.\"\n        raise IndexError(msg)\n    return Servo(self.robot, channel)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting","title":"<code>Lighting</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Lighting subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Lighting(BaseKevinbotSubsystem):\n    \"\"\"Lighting subsystem for Kevinbot\"\"\"\n\n    class Channel(Enum):\n        \"\"\"Lighting segment identifier\"\"\"\n\n        Head = \"head\"\n        Body = \"body\"\n        Base = \"base\"\n\n    def get_state(self) -&gt; LightingState:\n        \"\"\"Get the state of the robot's light segments\n\n        Returns:\n            LightingState: State\n        \"\"\"\n        return self.robot.get_state().lighting\n\n    def set_cam_brightness(self, brightness: int):\n        \"\"\"Set brightness of camera illumination\n\n        Args:\n            brightness (int): Brightness from 0 to 255\n        \"\"\"\n        self.robot.send(f\"lighting.cam.bright={brightness}\")\n        self.robot.get_state().lighting.camera = brightness\n\n    def set_brightness(self, channel: Channel, brightness: int):\n        \"\"\"Set the brightness of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            brightness (int): Brightness from 0 to 255\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.bright={brightness}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_bright = brightness\n            case self.Channel.Body:\n                self.robot.get_state().lighting.body_bright = brightness\n            case self.Channel.Head:\n                self.robot.get_state().lighting.head_bright = brightness\n\n    def set_color1(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n        \"\"\"Set the Color 1 of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            color (Iterable[int]): RGB Color values. Must have a length of 3\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.color1={color[0]:02x}{color[1]:02x}{color[2]:02x}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_color1 = color\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_color1 = color\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_color1 = color\n\n    def set_color2(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n        \"\"\"Set the Color 2 of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            color (Iterable[int]): RGB Color values. Must have a length of 3\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.color2={color[0]:02x}{color[1]:02x}{color[2]:02x}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_color2 = color\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_color2 = color\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_color2 = color\n\n    def set_effect(self, channel: Channel, effect: str):\n        \"\"\"Set the animation of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            effect (Iterable[int]): RGB Color values. Must have a length of 3\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.effect={effect}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_effect = effect\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_effect = effect\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_effect = effect\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Lighting segment identifier</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Channel(Enum):\n    \"\"\"Lighting segment identifier\"\"\"\n\n    Head = \"head\"\n    Body = \"body\"\n    Base = \"base\"\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.get_state","title":"<code>get_state()</code>","text":"<p>Get the state of the robot's light segments</p> <p>Returns:</p> Name Type Description <code>LightingState</code> <code>LightingState</code> <p>State</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_state(self) -&gt; LightingState:\n    \"\"\"Get the state of the robot's light segments\n\n    Returns:\n        LightingState: State\n    \"\"\"\n    return self.robot.get_state().lighting\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_cam_brightness","title":"<code>set_cam_brightness(brightness)</code>","text":"<p>Set brightness of camera illumination</p> <p>Parameters:</p> Name Type Description Default <code>brightness</code> <code>int</code> <p>Brightness from 0 to 255</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_cam_brightness(self, brightness: int):\n    \"\"\"Set brightness of camera illumination\n\n    Args:\n        brightness (int): Brightness from 0 to 255\n    \"\"\"\n    self.robot.send(f\"lighting.cam.bright={brightness}\")\n    self.robot.get_state().lighting.camera = brightness\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_brightness","title":"<code>set_brightness(channel, brightness)</code>","text":"<p>Set the brightness of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>brightness</code> <code>int</code> <p>Brightness from 0 to 255</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_brightness(self, channel: Channel, brightness: int):\n    \"\"\"Set the brightness of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        brightness (int): Brightness from 0 to 255\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.bright={brightness}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_bright = brightness\n        case self.Channel.Body:\n            self.robot.get_state().lighting.body_bright = brightness\n        case self.Channel.Head:\n            self.robot.get_state().lighting.head_bright = brightness\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_color1","title":"<code>set_color1(channel, color)</code>","text":"<p>Set the Color 1 of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>color</code> <code>Iterable[int]</code> <p>RGB Color values. Must have a length of 3</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_color1(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n    \"\"\"Set the Color 1 of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        color (Iterable[int]): RGB Color values. Must have a length of 3\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.color1={color[0]:02x}{color[1]:02x}{color[2]:02x}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_color1 = color\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_color1 = color\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_color1 = color\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_color2","title":"<code>set_color2(channel, color)</code>","text":"<p>Set the Color 2 of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>color</code> <code>Iterable[int]</code> <p>RGB Color values. Must have a length of 3</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_color2(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n    \"\"\"Set the Color 2 of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        color (Iterable[int]): RGB Color values. Must have a length of 3\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.color2={color[0]:02x}{color[1]:02x}{color[2]:02x}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_color2 = color\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_color2 = color\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_color2 = color\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_effect","title":"<code>set_effect(channel, effect)</code>","text":"<p>Set the animation of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>effect</code> <code>Iterable[int]</code> <p>RGB Color values. Must have a length of 3</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_effect(self, channel: Channel, effect: str):\n    \"\"\"Set the animation of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        effect (Iterable[int]): RGB Color values. Must have a length of 3\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.effect={effect}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_effect = effect\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_effect = effect\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_effect = effect\n</code></pre>"},{"location":"reference/#kevinbotlib.states.CoreErrors","title":"<code>CoreErrors</code>","text":"<p>               Bases: <code>Enum</code></p> <p>These are errors from Kevinbot Core</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class CoreErrors(Enum):\n    \"\"\"These are errors from Kevinbot Core\"\"\"\n\n    \"\"\"No errors are present\"\"\"\n    OK = 0\n    \"\"\"Error state unknown\"\"\"\n    UNKNOWN = 1\n    \"\"\"One-Wire bus is shorted\"\"\"\n    OW_SHORT = 2\n    \"\"\"One-Wire bus error\"\"\"\n    OW_ERROR = 3\n    \"\"\"One-Wire device not found\"\"\"\n    OW_DNF = 4\n    \"\"\"LCD Init failed\"\"\"\n    LCD_INIT_FAIL = 5\n    \"\"\"PCA9685 (servos) init fail\"\"\"\n    PCA_INIT_FAIL = 6\n    \"\"\"Failure to recieve core tick\"\"\"\n    TICK_FAIL = 7\n</code></pre>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error state unknown</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire bus is shorted</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OW_SHORT","title":"<code>OW_SHORT = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire bus error</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OW_ERROR","title":"<code>OW_ERROR = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire device not found</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.OW_DNF","title":"<code>OW_DNF = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>LCD Init failed</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.LCD_INIT_FAIL","title":"<code>LCD_INIT_FAIL = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PCA9685 (servos) init fail</p>"},{"location":"reference/#kevinbotlib.states.CoreErrors.PCA_INIT_FAIL","title":"<code>PCA_INIT_FAIL = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Failure to recieve core tick</p>"},{"location":"reference/#kevinbotlib.states.MotorDriveStatus","title":"<code>MotorDriveStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of each motor in the drivebase</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class MotorDriveStatus(Enum):\n    \"\"\"The status of each motor in the drivebase\"\"\"\n\n    UNKNOWN = 10\n    MOVING = 11\n    HOLDING = 12\n    OFF = 13\n</code></pre>"},{"location":"reference/#kevinbotlib.states.BmsBatteryState","title":"<code>BmsBatteryState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of a single battery attached to the BMS</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class BmsBatteryState(Enum):\n    \"\"\"The status of a single battery attached to the BMS\"\"\"\n\n    UNKNOWN = 0\n    NORMAL = 1\n    UNDER = 2\n    OVER = 3\n    STOPPED = 4  # Stopped state if BMS driver crashed\n</code></pre>"},{"location":"reference/#kevinbotlib.states.DrivebaseState","title":"<code>DrivebaseState</code>  <code>dataclass</code>","text":"<p>The state of the drivebase as a whole</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass DrivebaseState:\n    \"\"\"The state of the drivebase as a whole\"\"\"\n\n    left_power: int = 0\n    right_power: int = 0\n    amps: list[float] = field(default_factory=lambda: [0, 0])\n    watts: list[float] = field(default_factory=lambda: [0, 0])\n    status: list[MotorDriveStatus] = field(default_factory=lambda: [MotorDriveStatus.UNKNOWN, MotorDriveStatus.UNKNOWN])\n</code></pre>"},{"location":"reference/#kevinbotlib.states.ServoState","title":"<code>ServoState</code>  <code>dataclass</code>","text":"<p>The state of the servo subsystem</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass ServoState:\n    \"\"\"The state of the servo subsystem\"\"\"\n\n    angles: list[int] = field(default_factory=lambda: [-1] * 32)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.BMState","title":"<code>BMState</code>  <code>dataclass</code>","text":"<p>The state of the BMS (Battery Management System)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass BMState:\n    \"\"\"The state of the BMS (Battery Management System)\"\"\"\n\n    voltages: list[float] = field(default_factory=lambda: [0.0, 0.0])\n    raw_voltages: list[float] = field(default_factory=lambda: [0.0, 0.0])\n    states: list[BmsBatteryState] = field(default_factory=lambda: [BmsBatteryState.UNKNOWN, BmsBatteryState.UNKNOWN])\n</code></pre>"},{"location":"reference/#kevinbotlib.states.IMUState","title":"<code>IMUState</code>  <code>dataclass</code>","text":"<p>The state of the IMU (Inertial Measurement System)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass IMUState:\n    \"\"\"The state of the IMU (Inertial Measurement System)\"\"\"\n\n    accel: list[int] = field(default_factory=lambda: [-1] * 3)  # X Y Z\n    gyro: list[int] = field(default_factory=lambda: [-1] * 3)  # R P Y\n</code></pre>"},{"location":"reference/#kevinbotlib.states.ThermometerState","title":"<code>ThermometerState</code>  <code>dataclass</code>","text":"<p>The state of the DS18B20 Thermometers (does not include BME280)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass ThermometerState:\n    \"\"\"The state of the DS18B20 Thermometers (does not include BME280)\"\"\"\n\n    left_motor: Temperature = field(default_factory=lambda: Temperature(-1))\n    right_motor: Temperature = field(default_factory=lambda: Temperature(-1))\n    internal: Temperature = field(default_factory=lambda: Temperature(-1))\n</code></pre>"},{"location":"reference/#kevinbotlib.states.EnviroState","title":"<code>EnviroState</code>  <code>dataclass</code>","text":"<p>The state of the BME280 Envoronmental sensor</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass EnviroState:\n    \"\"\"The state of the BME280 Envoronmental sensor\"\"\"\n\n    temperature: Temperature = field(default_factory=lambda: Temperature(-1))\n    humidity: float = 0\n    pressure: int = 0\n</code></pre>"},{"location":"reference/#kevinbotlib.states.LightingState","title":"<code>LightingState</code>  <code>dataclass</code>","text":"<p>The state of Kevinbot's led segments</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass LightingState:\n    \"\"\"The state of Kevinbot's led segments\"\"\"\n\n    camera: int = 0\n    head_effect: str = \"unknown\"\n    head_bright: int = 0\n    head_color1: Iterable[int] = (0, 0, 0)\n    head_color2: Iterable[int] = (0, 0, 0)\n    body_effect: str = \"unknown\"\n    body_bright: int = 0\n    body_color1: Iterable[int] = (0, 0, 0)\n    body_color2: Iterable[int] = (0, 0, 0)\n    base_effect: str = \"unknown\"\n    base_bright: int = 0\n    base_color1: Iterable[int] = (0, 0, 0)\n    base_color2: Iterable[int] = (0, 0, 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.KevinbotState","title":"<code>KevinbotState</code>  <code>dataclass</code>","text":"<p>The state of the robot as a whole</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass KevinbotState:\n    \"\"\"The state of the robot as a whole\"\"\"\n\n    connected: bool = False\n    enabled: bool = False\n    error: CoreErrors = CoreErrors.OK\n    uptime: int = 0\n    uptime_ms: int = 0\n    motion: DrivebaseState = field(default_factory=DrivebaseState)\n    servos: ServoState = field(default_factory=ServoState)\n    battery: BMState = field(default_factory=BMState)\n    imu: IMUState = field(default_factory=IMUState)\n    thermal: ThermometerState = field(default_factory=ThermometerState)\n    enviro: EnviroState = field(default_factory=EnviroState)\n    lighting: LightingState = field(default_factory=LightingState)\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.HandshakeTimeoutException","title":"<code>HandshakeTimeoutException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when the connection handshake times out</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class HandshakeTimeoutException(BaseException):\n    \"\"\"Exception that is produced when the connection handshake times out\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.misc.Temperature","title":"<code>Temperature</code>","text":"<p>               Bases: <code>float</code></p> <p>Extended float class that can convert it's value from Celcius to Farenheit</p> Source code in <code>src/kevinbotlib/misc.py</code> <pre><code>class Temperature(float):\n    \"\"\"Extended float class that can convert it's value from Celcius to Farenheit\"\"\"\n\n    @property\n    def f(self) -&gt; float:\n        \"\"\"Convert value to Farenheit\n\n        Returns:\n            float: Value in F\n        \"\"\"\n        return self.__float__() * 1.8 + 32\n\n    @staticmethod\n    def from_f(f: float) -&gt; \"Temperature\":\n        \"\"\"Convert a Farenheit value to a Temperature object\n\n        Args:\n            f (float): Temp in Farenheit\n\n        Returns:\n            Temperature: Celcius, convertable\n        \"\"\"\n        return Temperature((f - 32) * 1.8)\n</code></pre>"},{"location":"reference/#kevinbotlib.misc.Temperature.f","title":"<code>f: float</code>  <code>property</code>","text":"<p>Convert value to Farenheit</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Value in F</p>"},{"location":"reference/#kevinbotlib.misc.Temperature.from_f","title":"<code>from_f(f)</code>  <code>staticmethod</code>","text":"<p>Convert a Farenheit value to a Temperature object</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Temp in Farenheit</p> required <p>Returns:</p> Name Type Description <code>Temperature</code> <code>Temperature</code> <p>Celcius, convertable</p> Source code in <code>src/kevinbotlib/misc.py</code> <pre><code>@staticmethod\ndef from_f(f: float) -&gt; \"Temperature\":\n    \"\"\"Convert a Farenheit value to a Temperature object\n\n    Args:\n        f (float): Temp in Farenheit\n\n    Returns:\n        Temperature: Celcius, convertable\n    \"\"\"\n    return Temperature((f - 32) * 1.8)\n</code></pre>"}]}