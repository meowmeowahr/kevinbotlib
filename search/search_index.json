{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KevinbotLib","text":"<p>This library consists of classes to operate Kevinbot v3.</p> <p>Development</p> <p>This project is in the early stage of development. There are many missing functions that will be supported in the future.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#kevinbotlib.core.BaseKevinbotSubsystem","title":"<code>BaseKevinbotSubsystem</code>","text":"<p>The base subsystem class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class BaseKevinbotSubsystem:\n    \"\"\"The base subsystem class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self, robot: \"Kevinbot\") -&gt; None:\n        self.robot = robot\n        self.robot._register_component(self)  # noqa: SLF001\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase","title":"<code>Drivebase</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Drivebase subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Drivebase(BaseKevinbotSubsystem):\n    \"\"\"Drivebase subsystem for Kevinbot\"\"\"\n\n    def get_amps(self) -&gt; list[float]:\n        \"\"\"Get the amps being used by the drivebase\n\n        Returns:\n            list[float]: Amps\n        \"\"\"\n        return self.robot.get_state().motion.amps\n\n    def get_watts(self) -&gt; list[float]:\n        \"\"\"Get the watts being used by the drivebase\n\n        Returns:\n            list[float]: Watts\n        \"\"\"\n        return self.robot.get_state().motion.watts\n\n    def get_powers(self) -&gt; tuple[int, int]:\n        \"\"\"Get the currently set wheel speeds in percent\n\n        Returns:\n            tuple[int, int]: Percent values from 0 to 100\n        \"\"\"\n        return self.robot.get_state().motion.left_power, self.robot.get_state().motion.right_power\n\n    def get_states(self) -&gt; list[MotorDriveStatus]:\n        \"\"\"Get the wheels states\n\n        Returns:\n            list[MotorDriveStatus]: States\n        \"\"\"\n        return self.robot.get_state().motion.status\n\n    def drive_at_power(self, left: float, right: float):\n        \"\"\"Set the drive power for wheels. 0 to 1\n\n        Args:\n            left (float): Left motor power\n            right (float): Right motor power\n        \"\"\"\n        self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n\n    def stop(self):\n        \"\"\"Set all wheel powers to 0\"\"\"\n        self.robot.send(\"drive.stop\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.drive_at_power","title":"<code>drive_at_power(left, right)</code>","text":"<p>Set the drive power for wheels. 0 to 1</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>float</code> <p>Left motor power</p> required <code>right</code> <code>float</code> <p>Right motor power</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def drive_at_power(self, left: float, right: float):\n    \"\"\"Set the drive power for wheels. 0 to 1\n\n    Args:\n        left (float): Left motor power\n        right (float): Right motor power\n    \"\"\"\n    self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_amps","title":"<code>get_amps()</code>","text":"<p>Get the amps being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Amps</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_amps(self) -&gt; list[float]:\n    \"\"\"Get the amps being used by the drivebase\n\n    Returns:\n        list[float]: Amps\n    \"\"\"\n    return self.robot.get_state().motion.amps\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_powers","title":"<code>get_powers()</code>","text":"<p>Get the currently set wheel speeds in percent</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: Percent values from 0 to 100</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_powers(self) -&gt; tuple[int, int]:\n    \"\"\"Get the currently set wheel speeds in percent\n\n    Returns:\n        tuple[int, int]: Percent values from 0 to 100\n    \"\"\"\n    return self.robot.get_state().motion.left_power, self.robot.get_state().motion.right_power\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_states","title":"<code>get_states()</code>","text":"<p>Get the wheels states</p> <p>Returns:</p> Type Description <code>list[MotorDriveStatus]</code> <p>list[MotorDriveStatus]: States</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_states(self) -&gt; list[MotorDriveStatus]:\n    \"\"\"Get the wheels states\n\n    Returns:\n        list[MotorDriveStatus]: States\n    \"\"\"\n    return self.robot.get_state().motion.status\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_watts","title":"<code>get_watts()</code>","text":"<p>Get the watts being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Watts</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_watts(self) -&gt; list[float]:\n    \"\"\"Get the watts being used by the drivebase\n\n    Returns:\n        list[float]: Watts\n    \"\"\"\n    return self.robot.get_state().motion.watts\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.stop","title":"<code>stop()</code>","text":"<p>Set all wheel powers to 0</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def stop(self):\n    \"\"\"Set all wheel powers to 0\"\"\"\n    self.robot.send(\"drive.stop\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot","title":"<code>Kevinbot</code>","text":"<p>The main robot class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Kevinbot:\n    \"\"\"The main robot class\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._state = KevinbotState()\n        self._subsystems: list[BaseKevinbotSubsystem] = []\n\n        self.serial: Serial | None = None\n        self.rx_thread: Thread | None = None\n\n        self._auto_disconnect = True\n        atexit.register(self.disconnect)\n\n    def connect(\n        self,\n        port: str,\n        baud: int,\n        timeout: float,\n        tick_interval: float,\n        ser_timeout: float = 0.5,\n        *,\n        tick_thread: bool = True,\n    ):\n        \"\"\"Start a connection with Kevinbot Core\n\n        Args:\n            port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n            baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n            timeout (float): Timeout for handshake\n            tick_interval (float): How often a heartbeat should be produced\n            ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n            tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n        Raises:\n            HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n        \"\"\"\n        serial = self._setup_serial(port, baud, ser_timeout)\n\n        start_time = time.monotonic()\n        while True:\n            serial.write(b\"connection.isready=0\\n\")\n\n            line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n            if line == \"ready\":\n                serial.write(b\"connection.start\\n\")\n                serial.write(b\"core.errors.clear\\n\")\n                serial.write(b\"connection.ok\\n\")\n                break\n\n            if time.monotonic() - start_time &gt; timeout:\n                msg = \"Handshake timed out\"\n                raise HandshakeTimeoutException(msg)\n\n            time.sleep(0.1)  # Avoid spamming the connection\n\n        # Data rx thread\n        self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n        self.rx_thread.name = \"KevinbotLib.Rx\"\n        self.rx_thread.start()\n\n        if tick_thread:\n            thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n            thread.start()\n            thread.name = \"KevinbotLib.Tick\"\n\n        self._state.connected = True\n\n    def disconnect(self):\n        \"\"\"Disconnect core gracefully\"\"\"\n        self._state.connected = False\n        if self.serial:\n            self.serial.write(b\"core.link.unlink\\n\")\n            self.serial.flush()\n            self.serial.close()\n        else:\n            logger.warning(\"Already disconnected\")\n\n    def request_enable(self) -&gt; int:\n        \"\"\"Request the core to enable\n\n        Returns:\n            int: -1 = core disconnected, -2 = core in error state, 1 = enable requested\n        \"\"\"\n        if not self.serial:\n            logger.error(\"Couldn't request state change, please use connect() first\")\n            return -1\n        if self._state.error != CoreErrors.OK:\n            logger.error(\"Couldn't request state change, core is in an error state\")\n            return -2\n        self.serial.write(b\"kevinbot.tryenable=1\\n\")\n        return 1\n\n    def request_disable(self) -&gt; int:\n        \"\"\"Request the core to disable\n\n        Returns:\n            int: -1 = core disconnected, -2 = core in error state, 1 = disable requested\n        \"\"\"\n        if not self.serial:\n            logger.error(\"Couldn't request state change, please use connect() first\")\n            return -1\n        if self._state.error != CoreErrors.OK:\n            logger.error(\"Couldn't request state change, core is in an error state\")\n            return -2\n        self.serial.write(b\"kevinbot.tryenable=0\\n\")\n        return 1\n\n    def e_stop(self):\n        \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n        if not self.serial:\n            logger.error(\"Couldn't send e-stop, please use connect() first\")\n            return\n\n        self.serial.write(b\"system.estop\\n\")\n\n    def tick_loop(self, interval: float = 1):\n        \"\"\"Send ticks indefinetely\n\n        Args:\n            interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n        \"\"\"\n        while True:\n            self._tick()\n            time.sleep(interval)\n\n    def get_state(self) -&gt; KevinbotState:\n        \"\"\"Gets the current state of the robot\n\n        Returns:\n            KevinbotState: State class\n        \"\"\"\n        return self._state\n\n    def send(self, data: str):\n        \"\"\"Send a string through serial.\n\n        Automatically adds a newline.\n\n        Args:\n            data (str): Data to send\n        \"\"\"\n        self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n\n    def raw_tx(self, data: bytes):\n        \"\"\"Send raw bytes over serial.\n\n        Args:\n            data (bytes): Raw data\n        \"\"\"\n        if self.serial:\n            self.serial.write(data)\n        else:\n            logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n\n    @property\n    def auto_disconnect(self) -&gt; bool:\n        \"\"\"Getter for auto disconnect state.\n\n        Returns:\n            bool: Whether to disconnect on application exit\n        \"\"\"\n        return self._auto_disconnect\n\n    @auto_disconnect.setter\n    def auto_disconnect(self, value: bool):\n        \"\"\"Setter for auto disconnect.\n\n        Args:\n            value (bool): Whether to disconnect on application exit\n        \"\"\"\n        self._auto_disconnect = value\n        if value:\n            atexit.register(self.disconnect)\n        else:\n            atexit.unregister(self.disconnect)\n\n    def _rx_loop(self, serial: Serial, delimeter: str = \"=\"):\n        while True:\n            raw: bytes = serial.readline()\n            cmd: str = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[0]\n\n            val: str | None = None\n            if len(raw.decode(\"utf-8\").split(delimeter)) &gt; 1:\n                val = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[1].strip(\"\\r\\n\")\n\n            match cmd:\n                case \"ready\\n\":\n                    pass\n                case \"core.enabled\":\n                    if not val:\n                        logger.warning(\"No value recieved for 'core.enabled'\")\n                        return\n                    if val.lower() in [\"true\", \"t\", \"1\"]:\n                        self._state.enabled = True\n                    else:\n                        self._state.enabled = False\n                case \"core.uptime\":\n                    if val:\n                        self._state.uptime = int(val)\n                case \"core.uptime_ms\":\n                    if val:\n                        self._state.uptime_ms = int(val)\n                case \"motors.amps\":\n                    if val:\n                        self._state.motion.amps = list(map(float, val.split(\",\")))\n                case \"motors.watts\":\n                    if val:\n                        self._state.motion.watts = list(map(float, val.split(\",\")))\n                case \"motors.status\":\n                    if val:\n                        self._state.motion.status = [MotorDriveStatus(int(x)) for x in val.split(\",\")]\n                case \"bms.voltages\":\n                    if val:\n                        self._state.battery.voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.raw_voltages\":\n                    if val:\n                        self._state.battery.raw_voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.status\":\n                    if val:\n                        self._state.battery.states = [BmsBatteryState(int(x)) for x in val.split(\",\")]\n                case \"sensors.gyro\":\n                    if val:\n                        self._state.imu.gyro = [int(x) for x in val.split(\",\")]\n                case \"sensors.accel\":\n                    if val:\n                        self._state.imu.accel = [int(x) for x in val.split(\",\")]\n                case \"sensors.temps\":\n                    if val:\n                        temps = val.split(\",\")\n                        self._state.thermal.left_motor = Temperature(int(temps[0]) / 100)\n                        self._state.thermal.right_motor = Temperature(int(temps[1]) / 100)\n                        self._state.thermal.internal = Temperature(int(temps[2]) / 100)\n                case _:\n                    logger.warning(f\"Got a command that isn't supported yet: {cmd} with value {val}\")\n\n    def _setup_serial(self, port: str, baud: int, timeout: float = 1):\n        self.serial = Serial(port, baud, timeout=timeout)\n        return self.serial\n\n    def _tick(self):\n        if self.serial:\n            self.serial.write(b\"core.tick\\n\")\n\n    def _register_component(self, component: BaseKevinbotSubsystem):\n        self._subsystems.append(component)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.auto_disconnect","title":"<code>auto_disconnect: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for auto disconnect state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to disconnect on application exit</p>"},{"location":"reference/#kevinbotlib.core.Kevinbot.connect","title":"<code>connect(port, baud, timeout, tick_interval, ser_timeout=0.5, *, tick_thread=True)</code>","text":"<p>Start a connection with Kevinbot Core</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port to use (<code>/dev/ttyAMA2</code> is standard with the typical Kevinbot Hardware)</p> required <code>baud</code> <code>int</code> <p>Baud rate to use (<code>921600</code> is typical for the defualt Core configs)</p> required <code>timeout</code> <code>float</code> <p>Timeout for handshake</p> required <code>tick_interval</code> <code>float</code> <p>How often a heartbeat should be produced</p> required <code>ser_timeout</code> <code>float</code> <p>Readline timeout, should be lower than <code>timeout</code>. Defaults to 0.5.</p> <code>0.5</code> <code>tick_thread</code> <code>bool</code> <p>Whether a tick thread should be started. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>HandshakeTimeoutException</code> <p>Core didn't respond to the connection handshake before the timeout</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def connect(\n    self,\n    port: str,\n    baud: int,\n    timeout: float,\n    tick_interval: float,\n    ser_timeout: float = 0.5,\n    *,\n    tick_thread: bool = True,\n):\n    \"\"\"Start a connection with Kevinbot Core\n\n    Args:\n        port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n        baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n        timeout (float): Timeout for handshake\n        tick_interval (float): How often a heartbeat should be produced\n        ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n        tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n    Raises:\n        HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n    \"\"\"\n    serial = self._setup_serial(port, baud, ser_timeout)\n\n    start_time = time.monotonic()\n    while True:\n        serial.write(b\"connection.isready=0\\n\")\n\n        line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n        if line == \"ready\":\n            serial.write(b\"connection.start\\n\")\n            serial.write(b\"core.errors.clear\\n\")\n            serial.write(b\"connection.ok\\n\")\n            break\n\n        if time.monotonic() - start_time &gt; timeout:\n            msg = \"Handshake timed out\"\n            raise HandshakeTimeoutException(msg)\n\n        time.sleep(0.1)  # Avoid spamming the connection\n\n    # Data rx thread\n    self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n    self.rx_thread.name = \"KevinbotLib.Rx\"\n    self.rx_thread.start()\n\n    if tick_thread:\n        thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n        thread.start()\n        thread.name = \"KevinbotLib.Tick\"\n\n    self._state.connected = True\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect core gracefully</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect core gracefully\"\"\"\n    self._state.connected = False\n    if self.serial:\n        self.serial.write(b\"core.link.unlink\\n\")\n        self.serial.flush()\n        self.serial.close()\n    else:\n        logger.warning(\"Already disconnected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.e_stop","title":"<code>e_stop()</code>","text":"<p>Attempt to send and E-Stop signal to the Core</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def e_stop(self):\n    \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n    if not self.serial:\n        logger.error(\"Couldn't send e-stop, please use connect() first\")\n        return\n\n    self.serial.write(b\"system.estop\\n\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.get_state","title":"<code>get_state()</code>","text":"<p>Gets the current state of the robot</p> <p>Returns:</p> Name Type Description <code>KevinbotState</code> <code>KevinbotState</code> <p>State class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_state(self) -&gt; KevinbotState:\n    \"\"\"Gets the current state of the robot\n\n    Returns:\n        KevinbotState: State class\n    \"\"\"\n    return self._state\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.raw_tx","title":"<code>raw_tx(data)</code>","text":"<p>Send raw bytes over serial.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw data</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def raw_tx(self, data: bytes):\n    \"\"\"Send raw bytes over serial.\n\n    Args:\n        data (bytes): Raw data\n    \"\"\"\n    if self.serial:\n        self.serial.write(data)\n    else:\n        logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.request_disable","title":"<code>request_disable()</code>","text":"<p>Request the core to disable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>-1 = core disconnected, -2 = core in error state, 1 = disable requested</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_disable(self) -&gt; int:\n    \"\"\"Request the core to disable\n\n    Returns:\n        int: -1 = core disconnected, -2 = core in error state, 1 = disable requested\n    \"\"\"\n    if not self.serial:\n        logger.error(\"Couldn't request state change, please use connect() first\")\n        return -1\n    if self._state.error != CoreErrors.OK:\n        logger.error(\"Couldn't request state change, core is in an error state\")\n        return -2\n    self.serial.write(b\"kevinbot.tryenable=0\\n\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.request_enable","title":"<code>request_enable()</code>","text":"<p>Request the core to enable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>-1 = core disconnected, -2 = core in error state, 1 = enable requested</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_enable(self) -&gt; int:\n    \"\"\"Request the core to enable\n\n    Returns:\n        int: -1 = core disconnected, -2 = core in error state, 1 = enable requested\n    \"\"\"\n    if not self.serial:\n        logger.error(\"Couldn't request state change, please use connect() first\")\n        return -1\n    if self._state.error != CoreErrors.OK:\n        logger.error(\"Couldn't request state change, core is in an error state\")\n        return -2\n    self.serial.write(b\"kevinbot.tryenable=1\\n\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.send","title":"<code>send(data)</code>","text":"<p>Send a string through serial.</p> <p>Automatically adds a newline.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Send a string through serial.\n\n    Automatically adds a newline.\n\n    Args:\n        data (str): Data to send\n    \"\"\"\n    self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Kevinbot.tick_loop","title":"<code>tick_loop(interval=1)</code>","text":"<p>Send ticks indefinetely</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>Interval between ticks in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def tick_loop(self, interval: float = 1):\n    \"\"\"Send ticks indefinetely\n\n    Args:\n        interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n    \"\"\"\n    while True:\n        self._tick()\n        time.sleep(interval)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.BMState","title":"<code>BMState</code>  <code>dataclass</code>","text":"<p>The state of the BMS (Battery Management System)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass BMState:\n    \"\"\"The state of the BMS (Battery Management System)\"\"\"\n\n    voltages: list[float] = field(default_factory=lambda: [0.0, 0.0])\n    raw_voltages: list[float] = field(default_factory=lambda: [0.0, 0.0])\n    states: list[BmsBatteryState] = field(default_factory=lambda: [BmsBatteryState.UNKNOWN, BmsBatteryState.UNKNOWN])\n</code></pre>"},{"location":"reference/#kevinbotlib.states.BmsBatteryState","title":"<code>BmsBatteryState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of a single battery attached to the BMS</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class BmsBatteryState(Enum):\n    \"\"\"The status of a single battery attached to the BMS\"\"\"\n\n    UNKNOWN = 0\n    NORMAL = 1\n    UNDER = 2\n    OVER = 3\n    STOPPED = 4  # Stopped state if BMS driver crashed\n</code></pre>"},{"location":"reference/#kevinbotlib.states.CoreErrors","title":"<code>CoreErrors</code>","text":"<p>               Bases: <code>Enum</code></p> <p>These are errors from Kevinbot Core</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class CoreErrors(Enum):\n    \"\"\"These are errors from Kevinbot Core\"\"\"\n\n    OK = 0\n    UNKNOWN = 1\n    OW_SHORT = 2\n    OW_ERROR = 3\n    OW_DNF = 4\n    LCD_INIT_FAIL = 5\n    PCA_INIT_FAIL = 6\n    TICK_FAIL = 7\n</code></pre>"},{"location":"reference/#kevinbotlib.states.DrivebaseState","title":"<code>DrivebaseState</code>  <code>dataclass</code>","text":"<p>The state of the drivebase as a whole</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass DrivebaseState:\n    \"\"\"The state of the drivebase as a whole\"\"\"\n\n    left_power: int = 0\n    right_power: int = 0\n    amps: list[float] = field(default_factory=lambda: [0, 0])\n    watts: list[float] = field(default_factory=lambda: [0, 0])\n    status: list[MotorDriveStatus] = field(default_factory=lambda: [MotorDriveStatus.UNKNOWN, MotorDriveStatus.UNKNOWN])\n</code></pre>"},{"location":"reference/#kevinbotlib.states.IMUState","title":"<code>IMUState</code>  <code>dataclass</code>","text":"<p>The state of the IMU (Inertial Measurement System)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass IMUState:\n    \"\"\"The state of the IMU (Inertial Measurement System)\"\"\"\n\n    accel: list[int] = field(default_factory=lambda: [-1] * 3)  # X Y Z\n    gyro: list[int] = field(default_factory=lambda: [-1] * 3)  # R P Y\n</code></pre>"},{"location":"reference/#kevinbotlib.states.KevinbotState","title":"<code>KevinbotState</code>  <code>dataclass</code>","text":"<p>The state of the robot as a whole</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass KevinbotState:\n    \"\"\"The state of the robot as a whole\"\"\"\n\n    connected: bool = False\n    enabled: bool = False\n    error: CoreErrors = CoreErrors.OK\n    uptime: int = 0\n    uptime_ms: int = 0\n    motion: DrivebaseState = field(default_factory=DrivebaseState)\n    servos: ServoState = field(default_factory=ServoState)\n    battery: BMState = field(default_factory=BMState)\n    imu: IMUState = field(default_factory=IMUState)\n    thermal: ThermometerState = field(default_factory=ThermometerState)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.MotorDriveStatus","title":"<code>MotorDriveStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of each motor in the drivebase</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>class MotorDriveStatus(Enum):\n    \"\"\"The status of each motor in the drivebase\"\"\"\n\n    UNKNOWN = 10\n    MOVING = 11\n    HOLDING = 12\n    OFF = 13\n</code></pre>"},{"location":"reference/#kevinbotlib.states.ServoState","title":"<code>ServoState</code>  <code>dataclass</code>","text":"<p>The state of the servo subsystem</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass ServoState:\n    \"\"\"The state of the servo subsystem\"\"\"\n\n    angles: list[int] = field(default_factory=lambda: [-1] * 32)\n</code></pre>"},{"location":"reference/#kevinbotlib.states.ThermometerState","title":"<code>ThermometerState</code>  <code>dataclass</code>","text":"<p>The state of the DS18B20 Thermometers (does not include BME280)</p> Source code in <code>src/kevinbotlib/states.py</code> <pre><code>@dataclass\nclass ThermometerState:\n    \"\"\"The state of the DS18B20 Thermometers (does not include BME280)\"\"\"\n\n    left_motor: Temperature = field(default_factory=lambda: Temperature(-1))\n    right_motor: Temperature = field(default_factory=lambda: Temperature(-1))\n    internal: Temperature = field(default_factory=lambda: Temperature(-1))\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.HandshakeTimeoutException","title":"<code>HandshakeTimeoutException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when the connection handshake times out</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class HandshakeTimeoutException(BaseException):\n    \"\"\"Exception that is produced when the connection handshake times out\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.misc.Temperature","title":"<code>Temperature</code>","text":"<p>               Bases: <code>float</code></p> <p>Extended float class that can convert it's value from Celcius to Farenheit</p> Source code in <code>src/kevinbotlib/misc.py</code> <pre><code>class Temperature(float):\n    \"\"\"Extended float class that can convert it's value from Celcius to Farenheit\"\"\"\n\n    @property\n    def f(self) -&gt; float:\n        \"\"\"Convert value to Farenheit\n\n        Returns:\n            float: Value in F\n        \"\"\"\n        return self.__float__() * 1.8 + 32\n\n    @staticmethod\n    def from_f(f: float) -&gt; \"Temperature\":\n        \"\"\"Convert a Farenheit value to a Temperature object\n\n        Args:\n            f (float): Temp in Farenheit\n\n        Returns:\n            Temperature: Celcius, convertable\n        \"\"\"\n        return Temperature((f - 32) * 1.8)\n</code></pre>"},{"location":"reference/#kevinbotlib.misc.Temperature.f","title":"<code>f: float</code>  <code>property</code>","text":"<p>Convert value to Farenheit</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Value in F</p>"},{"location":"reference/#kevinbotlib.misc.Temperature.from_f","title":"<code>from_f(f)</code>  <code>staticmethod</code>","text":"<p>Convert a Farenheit value to a Temperature object</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Temp in Farenheit</p> required <p>Returns:</p> Name Type Description <code>Temperature</code> <code>Temperature</code> <p>Celcius, convertable</p> Source code in <code>src/kevinbotlib/misc.py</code> <pre><code>@staticmethod\ndef from_f(f: float) -&gt; \"Temperature\":\n    \"\"\"Convert a Farenheit value to a Temperature object\n\n    Args:\n        f (float): Temp in Farenheit\n\n    Returns:\n        Temperature: Celcius, convertable\n    \"\"\"\n    return Temperature((f - 32) * 1.8)\n</code></pre>"}]}