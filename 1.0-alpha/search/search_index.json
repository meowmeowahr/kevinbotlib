{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KevinbotLib","text":"<p>KevinbotLib is a modular robot control system integrating a high-speed server-client communication system, robust logging, gamepad inputs, and more.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>The Command Scheduler<ul> <li>A way to asynchronously run robot tasks</li> <li>Commands can be grouped to run sequentially, or in parallel if desired</li> <li>Commands can be executed at a set interval</li> </ul> </li> <li>The Communication System<ul> <li>Based on websockets</li> <li>Data can be easily sent from robot to client or vice-versa</li> <li>Data is synchronized between all clients</li> <li>Out-of-the-box ready-made sendables for builtin primitive types</li> <li>Easy to create custom sendables based on pydantic models</li> </ul> </li> <li>The Vision Pipeline System<ul> <li>Create vision pipelines based on OpenCV</li> <li>Pre-made sendables for video frames</li> <li>Pre-made encoders and decoders for the communication system</li> </ul> </li> <li>Robust Logging<ul> <li>Logging is based on loguru</li> <li>Automatic file rotations</li> <li>Logs to <code>stdout</code>, an inbuilt file server over HTTP, and/or an inbuilt FTP server (deprecated)</li> </ul> </li> <li>Gamepad Inputs<ul> <li>Based on SDL2</li> <li>Builtin-support for Raw devices and Xbox One and Xbox Series controllers</li> <li>Joystick data sender and receiver through the communication system</li> </ul> </li> </ul> <p>Development</p> <p>This project is in the early stage of development. There are many missing functions that will be supported in the future.</p>"},{"location":"commandscheduler/","title":"The Command Scheduler","text":""},{"location":"installation/","title":"Installation","text":"<p>Info</p> <p>KevinbotLib requires Python 3.10 or newer.</p>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"<p>Run the following in a virtual environment for the base version. <pre><code>pip install kevinbotlib\n</code></pre></p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#kevinbotlib.robot","title":"<code>kevinbotlib.robot</code>","text":""},{"location":"reference/#kevinbotlib.robot.InstanceLocker","title":"<code>kevinbotlib.robot.InstanceLocker</code>","text":"<p>Generate and release a lockfile for an entire application. Useful when trying to prevent multiple instances of an app.</p> <p>Verifies if the application was killed without releasing the lockfile.</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>class InstanceLocker:\n    \"\"\"\n    Generate and release a lockfile for an entire application. Useful when trying to prevent multiple instances of an app.\n\n    Verifies if the application was killed without releasing the lockfile.\n    \"\"\"\n\n    def __init__(self, lockfile_name: str):\n        \"\"\"Initialize the InstanceLocker\n\n        Args:\n            lockfile_name (str): The name of the lockfile (e.g., 'robot.lock').\n        \"\"\"\n        self.lockfile_name = lockfile_name\n        self.pid = os.getpid()\n        self._locked = False\n\n    def lock(self) -&gt; bool:\n        \"\"\"Attempt to acquire the lock by creating a lockfile with the current PID.\n\n        Returns:\n            bool: True if the lock was successfully acquired, False if another instance is running.\n        \"\"\"\n        if self._locked:\n            return True  # Already locked by this instance\n\n        # Check if another instance is running\n        if self.is_locked(self.lockfile_name):\n            return False\n\n        # Try to create the lockfile\n        try:\n            with open(os.path.join(tempfile.gettempdir(), self.lockfile_name), \"w\") as f:\n                f.write(str(self.pid))\n            self._locked = True\n        except FileExistsError:\n            # Double-check in case of race condition\n            if self.is_locked(self.lockfile_name):\n                return False\n            # If the process is gone, overwrite the lockfile\n            with open(os.path.join(tempfile.gettempdir(), self.lockfile_name), \"w\") as f:\n                f.write(str(self.pid))\n            self._locked = True\n            return True\n        except OSError as e:\n            Logger().error(f\"Failed to create lockfile: {e!r}\")\n            return False\n        else:\n            return True\n\n    def unlock(self) -&gt; None:\n        \"\"\"Release the lock by removing the lockfile.\"\"\"\n        if not self._locked:\n            return\n\n        try:\n            if os.path.exists(os.path.join(tempfile.gettempdir(), self.lockfile_name)):\n                with open(os.path.join(tempfile.gettempdir(), self.lockfile_name)) as f:\n                    pid = f.read().strip()\n                if pid == str(self.pid):  # Only remove if this process owns the lock\n                    os.remove(os.path.join(tempfile.gettempdir(), self.lockfile_name))\n            self._locked = False\n        except OSError as e:\n            Logger().error(f\"Failed to remove lockfile: {e!r}\")\n\n    @staticmethod\n    def is_locked(lockfile_name: str) -&gt; int:\n        \"\"\"Check if the lockfile exists and corresponds to a running process.\n\n        Args:\n            lockfile_name (str): The name of the lockfile to check.\n\n        Returns:\n            int: -1 if not locked, PID of locking process\n        \"\"\"\n        if not os.path.exists(os.path.join(tempfile.gettempdir(), lockfile_name)):\n            return False\n\n        try:\n            with open(os.path.join(tempfile.gettempdir(), lockfile_name)) as f:\n                pid_str = f.read().strip()\n                pid = int(pid_str)\n        except (OSError, ValueError):\n            # If the file is corrupt or unreadable, assume it's stale and not locked\n            return False\n        return pid in [p.info[\"pid\"] for p in psutil.process_iter(attrs=[\"pid\", \"name\"])]\n\n    def __enter__(self) -&gt; \"InstanceLocker\":\n        \"\"\"Context manager support: acquire the lock.\"\"\"\n        self.lock()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Context manager support: release the lock.\"\"\"\n        self.unlock()\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.__init__","title":"<code>__init__(lockfile_name)</code>","text":"<p>Initialize the InstanceLocker</p> <p>Parameters:</p> Name Type Description Default <code>lockfile_name</code> <code>str</code> <p>The name of the lockfile (e.g., 'robot.lock').</p> required Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def __init__(self, lockfile_name: str):\n    \"\"\"Initialize the InstanceLocker\n\n    Args:\n        lockfile_name (str): The name of the lockfile (e.g., 'robot.lock').\n    \"\"\"\n    self.lockfile_name = lockfile_name\n    self.pid = os.getpid()\n    self._locked = False\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.lock","title":"<code>lock()</code>","text":"<p>Attempt to acquire the lock by creating a lockfile with the current PID.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the lock was successfully acquired, False if another instance is running.</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def lock(self) -&gt; bool:\n    \"\"\"Attempt to acquire the lock by creating a lockfile with the current PID.\n\n    Returns:\n        bool: True if the lock was successfully acquired, False if another instance is running.\n    \"\"\"\n    if self._locked:\n        return True  # Already locked by this instance\n\n    # Check if another instance is running\n    if self.is_locked(self.lockfile_name):\n        return False\n\n    # Try to create the lockfile\n    try:\n        with open(os.path.join(tempfile.gettempdir(), self.lockfile_name), \"w\") as f:\n            f.write(str(self.pid))\n        self._locked = True\n    except FileExistsError:\n        # Double-check in case of race condition\n        if self.is_locked(self.lockfile_name):\n            return False\n        # If the process is gone, overwrite the lockfile\n        with open(os.path.join(tempfile.gettempdir(), self.lockfile_name), \"w\") as f:\n            f.write(str(self.pid))\n        self._locked = True\n        return True\n    except OSError as e:\n        Logger().error(f\"Failed to create lockfile: {e!r}\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.unlock","title":"<code>unlock()</code>","text":"<p>Release the lock by removing the lockfile.</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def unlock(self) -&gt; None:\n    \"\"\"Release the lock by removing the lockfile.\"\"\"\n    if not self._locked:\n        return\n\n    try:\n        if os.path.exists(os.path.join(tempfile.gettempdir(), self.lockfile_name)):\n            with open(os.path.join(tempfile.gettempdir(), self.lockfile_name)) as f:\n                pid = f.read().strip()\n            if pid == str(self.pid):  # Only remove if this process owns the lock\n                os.remove(os.path.join(tempfile.gettempdir(), self.lockfile_name))\n        self._locked = False\n    except OSError as e:\n        Logger().error(f\"Failed to remove lockfile: {e!r}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.is_locked","title":"<code>is_locked(lockfile_name)</code>  <code>staticmethod</code>","text":"<p>Check if the lockfile exists and corresponds to a running process.</p> <p>Parameters:</p> Name Type Description Default <code>lockfile_name</code> <code>str</code> <p>The name of the lockfile to check.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>-1 if not locked, PID of locking process</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>@staticmethod\ndef is_locked(lockfile_name: str) -&gt; int:\n    \"\"\"Check if the lockfile exists and corresponds to a running process.\n\n    Args:\n        lockfile_name (str): The name of the lockfile to check.\n\n    Returns:\n        int: -1 if not locked, PID of locking process\n    \"\"\"\n    if not os.path.exists(os.path.join(tempfile.gettempdir(), lockfile_name)):\n        return False\n\n    try:\n        with open(os.path.join(tempfile.gettempdir(), lockfile_name)) as f:\n            pid_str = f.read().strip()\n            pid = int(pid_str)\n    except (OSError, ValueError):\n        # If the file is corrupt or unreadable, assume it's stale and not locked\n        return False\n    return pid in [p.info[\"pid\"] for p in psutil.process_iter(attrs=[\"pid\", \"name\"])]\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot","title":"<code>kevinbotlib.robot.BaseRobot</code>","text":"Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>class BaseRobot:\n    def __init__(\n        self,\n        opmodes: list[str],\n        serve_port: int = 8765,\n        log_level: Level = Level.INFO,\n        print_level: Level = Level.INFO,\n        default_opmode: str | None = None,\n        cycle_time: float = 250,\n        log_cleanup_timer: float = 10.0,\n    ):\n        \"\"\"\n        Initialize the robot\n\n        Args:\n            opmodes (list[str]): List of operational mode names.\n            serve_port (int, optional): Port for comm server. Shouldn't have to be changed in most cases. Defaults to 8765.\n            log_level (Level, optional): Level to logging. Defaults to Level.INFO.\n            print_level (Level, optional): Level for print statement redirector. Defaults to Level.INFO.\n            default_opmode (str, optional): Default Operational Mode to start in. Defaults to the first item of `opmodes`.\n            cycle_time (float, optional): How fast to run periodic functions in Hz. Defaults to 250.\n            log_cleanup_timer (float, optional): How often to cleanup logs in seconds Set to 0 to disable log cleanup. Defaults to 10.0.\n        \"\"\"\n\n        self.telemetry = Logger()\n        self.telemetry.configure(LoggerConfiguration(level=log_level, file_logger=FileLoggerConfig()))\n\n        sys.excepthook = self._exc_hook\n        threading.excepthook = self._thread_exc_hook\n\n        self.fileserver = FileServer(LoggerDirectories.get_logger_directory())\n\n        self._instance_locker = InstanceLocker(f\"{self.__class__.__name__}.lock\")\n        atexit.register(self._instance_locker.unlock)\n\n        self._opmodes = opmodes\n\n        self.comm_server = KevinbotCommServer(port=serve_port)\n        self.comm_client = KevinbotCommClient(port=serve_port)\n\n        self._print_log_level = print_level\n        self._log_timer_interval = log_cleanup_timer\n\n        self._ctrl_status_root_key = \"%ControlConsole/status\"\n        self._ctrl_request_root_key = \"%ControlConsole/request\"\n\n        self._signal_stop = False\n        self._signal_estop = False\n\n        self._ready_for_periodic = False\n        self._cycle_hz = cycle_time\n\n        # Track the previous state for opmode transitions\n        self._prev_enabled = None\n        self._prev_opmode = None\n        self._estop = False\n\n        self._opmode = opmodes[0] if default_opmode is None else default_opmode\n\n    @property\n    def opmode(self) -&gt; str:\n        return self._opmode\n\n    @final\n    def _signal_usr1_capture(self, _, __):\n        self.telemetry.critical(\"Signal stop detected... Stopping now\")\n        self._signal_stop = True\n\n    @final\n    def _signal_usr2_capture(self, _, __):\n        \"\"\"Internal method used for the *EMERGENCY STOP* system **DO NOT OVERRIDE**\"\"\"\n        self.telemetry.critical(\"Signal EMERGENCY STOP detected... Stopping now\")\n        self._signal_estop = True\n\n    @final\n    def _thread_exc_hook(self, args):\n        self._exc_hook(*args)\n\n    @final\n    def _exc_hook(self, _: type, exc_value: BaseException, __: TracebackType, *_args):\n        if isinstance(exc_value, RobotEmergencyStoppedException | RobotStoppedException):\n            return\n        self.telemetry.log(\n            Level.CRITICAL, \"The robot stopped due to an exception\", LoggerWriteOpts(exception=exc_value)\n        )\n\n    @final\n    def _log_cleanup_internal(self):\n        LoggerDirectories.cleanup_logs(LoggerDirectories.get_logger_directory())\n        self.telemetry.trace(\"Cleaned up logs\")\n        if self._log_timer_interval != 0:\n            timer = threading.Timer(self._log_timer_interval, self._log_cleanup_internal)\n            timer.setDaemon(True)\n            timer.setName(\"KevinbotLib.Cleanup.LogCleanup\")\n            timer.start()\n\n    @final\n    def _update_console_enabled(self, enabled: bool):\n        # we don't want to allow dashbaord visibility - set struct to {}\n        return self.comm_client.send(CommPath(self._ctrl_status_root_key) / \"enabled\", BooleanSendable(value=enabled, struct={}))\n\n    @final\n    def _update_console_opmodes(self, opmodes: list[str]):\n        # we don't want to allow dashbaord visibility - set struct to {}\n        return self.comm_client.send(CommPath(self._ctrl_status_root_key) / \"opmodes\", AnyListSendable(value=opmodes, struct={}))\n\n    @final\n    def _update_console_opmode(self, opmode: str):\n        # we don't want to allow dashbaord visibility - set struct to {}\n        return self.comm_client.send(CommPath(self._ctrl_status_root_key) / \"opmode\", StringSendable(value=opmode, struct={}))\n\n    @final\n    def _get_console_enabled_request(self):\n        sendable = self.comm_client.get(CommPath(self._ctrl_request_root_key) / \"enabled\", BooleanSendable)\n        return sendable.value if sendable else False\n\n    @final\n    def _get_console_opmode_request(self):\n        sendable = self.comm_client.get(CommPath(self._ctrl_request_root_key) / \"opmode\", StringSendable)\n        return sendable.value if sendable else self._opmodes[0]\n\n    @final\n    def _get_estop_request(self):\n        return self.comm_client.get_raw(CommPath(self._ctrl_request_root_key) / \"estop\") is not None\n\n    @final\n    def run(self) -&gt; NoReturn:\n        \"\"\"Run the robot loop. Method is **final**.\"\"\"\n        if InstanceLocker.is_locked(f\"{self.__class__.__name__}.lock\"):\n            msg = f\"Another robot with the class name {self.__class__.__name__} is already running\"\n            raise RobotLockedException(msg)\n        self._instance_locker.lock()\n\n        if platform.system() != \"Linux\":\n            self.telemetry.warning(\n                \"Non-Linux OSes are not fully supported. Features such as signal shutdown may be broken\"\n            )\n\n        signal.signal(signal.SIGUSR1, self._signal_usr1_capture)\n        signal.signal(signal.SIGUSR2, self._signal_usr2_capture)\n        self.telemetry.debug(f\"{self.__class__.__name__}'s process id is {os.getpid()}\")\n\n        Thread(\n            target=self.comm_server.serve,\n            daemon=True,\n            name=f\"KevinbotLib.Robot.{self.__class__.__name__}.CommServer\",\n        ).start()\n        self.comm_server.wait_until_serving()\n        self.comm_client.connect()\n\n        self.fileserver.start()\n\n        if self._log_timer_interval != 0:\n            timer = threading.Timer(self._log_timer_interval, self._log_cleanup_internal)\n            timer.setDaemon(True)\n            timer.setName(\"KevinbotLib.Cleanup.LogCleanup\")\n            timer.start()\n\n        with contextlib.redirect_stdout(StreamRedirector(self.telemetry, self._print_log_level)):\n            self.comm_client.wait_until_connected()\n            self._update_console_enabled(False)\n            self._update_console_opmodes(self._opmodes)\n            self._update_console_opmode(self._opmode)\n\n            try:\n                self.robot_start()\n                self._ready_for_periodic = True\n                self.telemetry.log(Level.INFO, \"Robot started\")\n\n                while True:\n                    if self._signal_stop:\n                        msg = \"Robot signal stopped\"\n                        self.robot_end()\n                        raise RobotStoppedException(msg)\n                    if self._signal_estop:\n                        msg = \"Robot signal e-stopped\"\n                        raise RobotEmergencyStoppedException(msg)\n\n                    if self._get_estop_request():\n                        self.telemetry.critical(\"Control Console EMERGENCY STOP detected... Stopping now\")\n                        msg = \"Robot control console e-stopped\"\n                        self._estop = True\n                        raise RobotEmergencyStoppedException(msg)\n\n\n                    if self._ready_for_periodic:\n                        current_enabled: bool = self._get_console_enabled_request()\n                        current_opmode = self._get_console_opmode_request()\n\n                        # Handle opmode change\n                        if current_opmode != self._opmode:\n                            if self._prev_enabled is not None:  # Not first iteration\n                                self.opmode_exit(self._opmode, self._prev_enabled)\n                            self._opmode = current_opmode\n                            self._update_console_opmode(current_opmode)\n                            self.opmode_init(current_opmode, current_enabled)\n\n                        # Handle enable/disable transitions\n                        elif self._prev_enabled != current_enabled:\n                            self._update_console_enabled(current_enabled)\n                            if self._prev_enabled is not None:  # Not first iteration\n                                self.opmode_exit(self._opmode, self._prev_enabled)\n                            self.opmode_init(self._opmode, current_enabled)\n\n                        # Run periodic\n                        self.opmode_periodic(self._opmode, current_enabled)\n\n                        self._prev_enabled = current_enabled\n                        self._prev_opmode = current_opmode\n\n                    time.sleep(1 / self._cycle_hz)\n            finally:\n                if not self._estop:\n                    self.robot_end()\n                # this will be a pre-mature exit to estop as fast as possible\n\n    def robot_start(self) -&gt; None:\n        \"\"\"Run after the robot is initialized\"\"\"\n\n    def robot_end(self) -&gt; None:\n        \"\"\"Runs before the robot is requested to stop via service or keyboard interrupt\"\"\"\n\n    def opmode_init(self, opmode: str, enabled: bool) -&gt; None:\n        \"\"\"Runs when entering an opmode state (either enabled or disabled)\n\n        Args:\n            opmode (str): The OpMode being entered\n            enabled (bool): Whether the robot is enabled in this opmode\n        \"\"\"\n\n    def opmode_exit(self, opmode: str, enabled: bool) -&gt; None:\n        \"\"\"Runs when exiting an opmode state (either enabled or disabled)\n\n        Args:\n            opmode (str): The OpMode being exited\n            enabled (bool): Whether the robot was enabled in this opmode\n        \"\"\"\n\n    def opmode_periodic(self, opmode: str, enabled: bool) -&gt; None:\n        \"\"\"Loops continuously while in an opmode state\n\n        Args:\n            opmode (str): The current OpMode\n            enabled (bool): Whether the robot is currently enabled\n        \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.__init__","title":"<code>__init__(opmodes, serve_port=8765, log_level=Level.INFO, print_level=Level.INFO, default_opmode=None, cycle_time=250, log_cleanup_timer=10.0)</code>","text":"<p>Initialize the robot</p> <p>Parameters:</p> Name Type Description Default <code>opmodes</code> <code>list[str]</code> <p>List of operational mode names.</p> required <code>serve_port</code> <code>int</code> <p>Port for comm server. Shouldn't have to be changed in most cases. Defaults to 8765.</p> <code>8765</code> <code>log_level</code> <code>Level</code> <p>Level to logging. Defaults to Level.INFO.</p> <code>INFO</code> <code>print_level</code> <code>Level</code> <p>Level for print statement redirector. Defaults to Level.INFO.</p> <code>INFO</code> <code>default_opmode</code> <code>str</code> <p>Default Operational Mode to start in. Defaults to the first item of <code>opmodes</code>.</p> <code>None</code> <code>cycle_time</code> <code>float</code> <p>How fast to run periodic functions in Hz. Defaults to 250.</p> <code>250</code> <code>log_cleanup_timer</code> <code>float</code> <p>How often to cleanup logs in seconds Set to 0 to disable log cleanup. Defaults to 10.0.</p> <code>10.0</code> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def __init__(\n    self,\n    opmodes: list[str],\n    serve_port: int = 8765,\n    log_level: Level = Level.INFO,\n    print_level: Level = Level.INFO,\n    default_opmode: str | None = None,\n    cycle_time: float = 250,\n    log_cleanup_timer: float = 10.0,\n):\n    \"\"\"\n    Initialize the robot\n\n    Args:\n        opmodes (list[str]): List of operational mode names.\n        serve_port (int, optional): Port for comm server. Shouldn't have to be changed in most cases. Defaults to 8765.\n        log_level (Level, optional): Level to logging. Defaults to Level.INFO.\n        print_level (Level, optional): Level for print statement redirector. Defaults to Level.INFO.\n        default_opmode (str, optional): Default Operational Mode to start in. Defaults to the first item of `opmodes`.\n        cycle_time (float, optional): How fast to run periodic functions in Hz. Defaults to 250.\n        log_cleanup_timer (float, optional): How often to cleanup logs in seconds Set to 0 to disable log cleanup. Defaults to 10.0.\n    \"\"\"\n\n    self.telemetry = Logger()\n    self.telemetry.configure(LoggerConfiguration(level=log_level, file_logger=FileLoggerConfig()))\n\n    sys.excepthook = self._exc_hook\n    threading.excepthook = self._thread_exc_hook\n\n    self.fileserver = FileServer(LoggerDirectories.get_logger_directory())\n\n    self._instance_locker = InstanceLocker(f\"{self.__class__.__name__}.lock\")\n    atexit.register(self._instance_locker.unlock)\n\n    self._opmodes = opmodes\n\n    self.comm_server = KevinbotCommServer(port=serve_port)\n    self.comm_client = KevinbotCommClient(port=serve_port)\n\n    self._print_log_level = print_level\n    self._log_timer_interval = log_cleanup_timer\n\n    self._ctrl_status_root_key = \"%ControlConsole/status\"\n    self._ctrl_request_root_key = \"%ControlConsole/request\"\n\n    self._signal_stop = False\n    self._signal_estop = False\n\n    self._ready_for_periodic = False\n    self._cycle_hz = cycle_time\n\n    # Track the previous state for opmode transitions\n    self._prev_enabled = None\n    self._prev_opmode = None\n    self._estop = False\n\n    self._opmode = opmodes[0] if default_opmode is None else default_opmode\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.run","title":"<code>run()</code>","text":"<p>Run the robot loop. Method is final.</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>@final\ndef run(self) -&gt; NoReturn:\n    \"\"\"Run the robot loop. Method is **final**.\"\"\"\n    if InstanceLocker.is_locked(f\"{self.__class__.__name__}.lock\"):\n        msg = f\"Another robot with the class name {self.__class__.__name__} is already running\"\n        raise RobotLockedException(msg)\n    self._instance_locker.lock()\n\n    if platform.system() != \"Linux\":\n        self.telemetry.warning(\n            \"Non-Linux OSes are not fully supported. Features such as signal shutdown may be broken\"\n        )\n\n    signal.signal(signal.SIGUSR1, self._signal_usr1_capture)\n    signal.signal(signal.SIGUSR2, self._signal_usr2_capture)\n    self.telemetry.debug(f\"{self.__class__.__name__}'s process id is {os.getpid()}\")\n\n    Thread(\n        target=self.comm_server.serve,\n        daemon=True,\n        name=f\"KevinbotLib.Robot.{self.__class__.__name__}.CommServer\",\n    ).start()\n    self.comm_server.wait_until_serving()\n    self.comm_client.connect()\n\n    self.fileserver.start()\n\n    if self._log_timer_interval != 0:\n        timer = threading.Timer(self._log_timer_interval, self._log_cleanup_internal)\n        timer.setDaemon(True)\n        timer.setName(\"KevinbotLib.Cleanup.LogCleanup\")\n        timer.start()\n\n    with contextlib.redirect_stdout(StreamRedirector(self.telemetry, self._print_log_level)):\n        self.comm_client.wait_until_connected()\n        self._update_console_enabled(False)\n        self._update_console_opmodes(self._opmodes)\n        self._update_console_opmode(self._opmode)\n\n        try:\n            self.robot_start()\n            self._ready_for_periodic = True\n            self.telemetry.log(Level.INFO, \"Robot started\")\n\n            while True:\n                if self._signal_stop:\n                    msg = \"Robot signal stopped\"\n                    self.robot_end()\n                    raise RobotStoppedException(msg)\n                if self._signal_estop:\n                    msg = \"Robot signal e-stopped\"\n                    raise RobotEmergencyStoppedException(msg)\n\n                if self._get_estop_request():\n                    self.telemetry.critical(\"Control Console EMERGENCY STOP detected... Stopping now\")\n                    msg = \"Robot control console e-stopped\"\n                    self._estop = True\n                    raise RobotEmergencyStoppedException(msg)\n\n\n                if self._ready_for_periodic:\n                    current_enabled: bool = self._get_console_enabled_request()\n                    current_opmode = self._get_console_opmode_request()\n\n                    # Handle opmode change\n                    if current_opmode != self._opmode:\n                        if self._prev_enabled is not None:  # Not first iteration\n                            self.opmode_exit(self._opmode, self._prev_enabled)\n                        self._opmode = current_opmode\n                        self._update_console_opmode(current_opmode)\n                        self.opmode_init(current_opmode, current_enabled)\n\n                    # Handle enable/disable transitions\n                    elif self._prev_enabled != current_enabled:\n                        self._update_console_enabled(current_enabled)\n                        if self._prev_enabled is not None:  # Not first iteration\n                            self.opmode_exit(self._opmode, self._prev_enabled)\n                        self.opmode_init(self._opmode, current_enabled)\n\n                    # Run periodic\n                    self.opmode_periodic(self._opmode, current_enabled)\n\n                    self._prev_enabled = current_enabled\n                    self._prev_opmode = current_opmode\n\n                time.sleep(1 / self._cycle_hz)\n        finally:\n            if not self._estop:\n                self.robot_end()\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.robot_start","title":"<code>robot_start()</code>","text":"<p>Run after the robot is initialized</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def robot_start(self) -&gt; None:\n    \"\"\"Run after the robot is initialized\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.robot_end","title":"<code>robot_end()</code>","text":"<p>Runs before the robot is requested to stop via service or keyboard interrupt</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def robot_end(self) -&gt; None:\n    \"\"\"Runs before the robot is requested to stop via service or keyboard interrupt\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.opmode_init","title":"<code>opmode_init(opmode, enabled)</code>","text":"<p>Runs when entering an opmode state (either enabled or disabled)</p> <p>Parameters:</p> Name Type Description Default <code>opmode</code> <code>str</code> <p>The OpMode being entered</p> required <code>enabled</code> <code>bool</code> <p>Whether the robot is enabled in this opmode</p> required Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def opmode_init(self, opmode: str, enabled: bool) -&gt; None:\n    \"\"\"Runs when entering an opmode state (either enabled or disabled)\n\n    Args:\n        opmode (str): The OpMode being entered\n        enabled (bool): Whether the robot is enabled in this opmode\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.opmode_exit","title":"<code>opmode_exit(opmode, enabled)</code>","text":"<p>Runs when exiting an opmode state (either enabled or disabled)</p> <p>Parameters:</p> Name Type Description Default <code>opmode</code> <code>str</code> <p>The OpMode being exited</p> required <code>enabled</code> <code>bool</code> <p>Whether the robot was enabled in this opmode</p> required Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def opmode_exit(self, opmode: str, enabled: bool) -&gt; None:\n    \"\"\"Runs when exiting an opmode state (either enabled or disabled)\n\n    Args:\n        opmode (str): The OpMode being exited\n        enabled (bool): Whether the robot was enabled in this opmode\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.opmode_periodic","title":"<code>opmode_periodic(opmode, enabled)</code>","text":"<p>Loops continuously while in an opmode state</p> <p>Parameters:</p> Name Type Description Default <code>opmode</code> <code>str</code> <p>The current OpMode</p> required <code>enabled</code> <code>bool</code> <p>Whether the robot is currently enabled</p> required Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def opmode_periodic(self, opmode: str, enabled: bool) -&gt; None:\n    \"\"\"Loops continuously while in an opmode state\n\n    Args:\n        opmode (str): The current OpMode\n        enabled (bool): Whether the robot is currently enabled\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.comm","title":"<code>kevinbotlib.comm</code>","text":""},{"location":"reference/#kevinbotlib.comm.BaseSendable","title":"<code>kevinbotlib.comm.BaseSendable</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>The base for all of KevinbotLib's sendables.</p> <p>What is a sendable?</p> <p>A sendable is a basic unit of data that can be transported through the <code>KevinbotCommClient</code> and server</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class BaseSendable(BaseModel, ABC):\n    \"\"\"\n    The base for all of KevinbotLib's sendables.\n\n    _**What is a sendable?**_\n\n    A sendable is a basic unit of data that can be transported through the `KevinbotCommClient` and server\n    \"\"\"\n\n    timeout: float | None = None\n    data_id: str = \"kevinbotlib.dtype.null\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    flags: list[str] = []\n    struct: dict[str, Any] = {}\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        return {\"timeout\": self.timeout, \"value\": None, \"did\": self.data_id, \"struct\": self.struct}\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.BaseSendable.data_id","title":"<code>data_id = 'kevinbotlib.dtype.null'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.comm.BaseSendable.struct","title":"<code>struct = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.comm.BaseSendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    return {\"timeout\": self.timeout, \"value\": None, \"did\": self.data_id, \"struct\": self.struct}\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.SendableGenerator","title":"<code>kevinbotlib.comm.SendableGenerator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for a function capable of being sent over <code>KevinbotCommClient</code></p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class SendableGenerator(ABC):\n    \"\"\"\n    Abstract class for a function capable of being sent over `KevinbotCommClient`\n    \"\"\"\n\n    @abstractmethod\n    def generate_sendable(self) -&gt; BaseSendable:\n        \"\"\"Abstract method to generate a sendable\n\n        Returns:\n            BaseSendable: The returned sendable\n        \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.SendableGenerator.generate_sendable","title":"<code>generate_sendable()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to generate a sendable</p> <p>Returns:</p> Name Type Description <code>BaseSendable</code> <code>BaseSendable</code> <p>The returned sendable</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>@abstractmethod\ndef generate_sendable(self) -&gt; BaseSendable:\n    \"\"\"Abstract method to generate a sendable\n\n    Returns:\n        BaseSendable: The returned sendable\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.IntegerSendable","title":"<code>kevinbotlib.comm.IntegerSendable</code>","text":"<p>               Bases: <code>BaseSendable</code></p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class IntegerSendable(BaseSendable):\n    value: int\n    \"\"\"Value to send\"\"\"\n    data_id: str = \"kevinbotlib.dtype.int\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    struct: dict[str, Any] = {\"dashboard\": [{\"element\": \"value\", \"format\": \"raw\"}]}\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        data = super().get_dict()\n        data[\"value\"] = self.value\n        return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.IntegerSendable.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>Value to send</p>"},{"location":"reference/#kevinbotlib.comm.IntegerSendable.data_id","title":"<code>data_id = 'kevinbotlib.dtype.int'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.comm.IntegerSendable.struct","title":"<code>struct = {'dashboard': [{'element': 'value', 'format': 'raw'}]}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.comm.IntegerSendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    data = super().get_dict()\n    data[\"value\"] = self.value\n    return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.BooleanSendable","title":"<code>kevinbotlib.comm.BooleanSendable</code>","text":"<p>               Bases: <code>BaseSendable</code></p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class BooleanSendable(BaseSendable):\n    value: bool\n    \"\"\"Value to send\"\"\"\n    data_id: str = \"kevinbotlib.dtype.bool\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    struct: dict[str, Any] = {\"dashboard\": [{\"element\": \"value\", \"format\": \"raw\"}]}\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        data = super().get_dict()\n        data[\"value\"] = self.value\n        return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.BooleanSendable.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>Value to send</p>"},{"location":"reference/#kevinbotlib.comm.BooleanSendable.data_id","title":"<code>data_id = 'kevinbotlib.dtype.bool'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.comm.BooleanSendable.struct","title":"<code>struct = {'dashboard': [{'element': 'value', 'format': 'raw'}]}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.comm.BooleanSendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    data = super().get_dict()\n    data[\"value\"] = self.value\n    return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.StringSendable","title":"<code>kevinbotlib.comm.StringSendable</code>","text":"<p>               Bases: <code>BaseSendable</code></p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class StringSendable(BaseSendable):\n    value: str\n    \"\"\"Value to send\"\"\"\n    data_id: str = \"kevinbotlib.dtype.str\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    struct: dict[str, Any] = {\"dashboard\": [{\"element\": \"value\", \"format\": \"raw\"}]}\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        data = super().get_dict()\n        data[\"value\"] = self.value\n        return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.StringSendable.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>Value to send</p>"},{"location":"reference/#kevinbotlib.comm.StringSendable.data_id","title":"<code>data_id = 'kevinbotlib.dtype.str'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.comm.StringSendable.struct","title":"<code>struct = {'dashboard': [{'element': 'value', 'format': 'raw'}]}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.comm.StringSendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    data = super().get_dict()\n    data[\"value\"] = self.value\n    return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.FloatSendable","title":"<code>kevinbotlib.comm.FloatSendable</code>","text":"<p>               Bases: <code>BaseSendable</code></p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class FloatSendable(BaseSendable):\n    value: float\n    \"\"\"Value to send\"\"\"\n    data_id: str = \"kevinbotlib.dtype.float\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    struct: dict[str, Any] = {\"dashboard\": [{\"element\": \"value\", \"format\": \"raw\"}]}\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        data = super().get_dict()\n        data[\"value\"] = self.value\n        return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.FloatSendable.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>Value to send</p>"},{"location":"reference/#kevinbotlib.comm.FloatSendable.data_id","title":"<code>data_id = 'kevinbotlib.dtype.float'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.comm.FloatSendable.struct","title":"<code>struct = {'dashboard': [{'element': 'value', 'format': 'raw'}]}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.comm.FloatSendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    data = super().get_dict()\n    data[\"value\"] = self.value\n    return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.AnyListSendable","title":"<code>kevinbotlib.comm.AnyListSendable</code>","text":"<p>               Bases: <code>BaseSendable</code></p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class AnyListSendable(BaseSendable):\n    value: list\n    \"\"\"Value to send\"\"\"\n    data_id: str = \"kevinbotlib.dtype.list.any\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    struct: dict[str, Any] = {\"dashboard\": [{\"element\": \"value\", \"format\": \"raw\"}]}\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        data = super().get_dict()\n        data[\"value\"] = self.value\n        return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.AnyListSendable.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>Value to send</p>"},{"location":"reference/#kevinbotlib.comm.AnyListSendable.data_id","title":"<code>data_id = 'kevinbotlib.dtype.list.any'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.comm.AnyListSendable.struct","title":"<code>struct = {'dashboard': [{'element': 'value', 'format': 'raw'}]}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.comm.AnyListSendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    data = super().get_dict()\n    data[\"value\"] = self.value\n    return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.DictSendable","title":"<code>kevinbotlib.comm.DictSendable</code>","text":"<p>               Bases: <code>BaseSendable</code></p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class DictSendable(BaseSendable):\n    value: dict\n    \"\"\"Value to send\"\"\"\n    data_id: str = \"kevinbotlib.dtype.dict\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    struct: dict[str, Any] = {\"dashboard\": [{\"element\": \"value\", \"format\": \"raw\"}]}\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        data = super().get_dict()\n        data[\"value\"] = self.value\n        return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.DictSendable.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>Value to send</p>"},{"location":"reference/#kevinbotlib.comm.DictSendable.data_id","title":"<code>data_id = 'kevinbotlib.dtype.dict'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.comm.DictSendable.struct","title":"<code>struct = {'dashboard': [{'element': 'value', 'format': 'raw'}]}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.comm.DictSendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    data = super().get_dict()\n    data[\"value\"] = self.value\n    return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.BinarySendable","title":"<code>kevinbotlib.comm.BinarySendable</code>","text":"<p>               Bases: <code>BaseSendable</code></p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class BinarySendable(BaseSendable):\n    value: bytes\n    \"\"\"Value to send\"\"\"\n    data_id: str = \"kevinbotlib.dtype.bin\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    struct: dict[str, Any] = {\"dashboard\": [{\"element\": \"value\", \"format\": \"limit:1024\"}]}\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        data = super().get_dict()\n        data[\"value\"] = self.value.decode(\"utf-8\")\n        return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.BinarySendable.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>Value to send</p>"},{"location":"reference/#kevinbotlib.comm.BinarySendable.data_id","title":"<code>data_id = 'kevinbotlib.dtype.bin'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.comm.BinarySendable.struct","title":"<code>struct = {'dashboard': [{'element': 'value', 'format': 'limit:1024'}]}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.comm.BinarySendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    data = super().get_dict()\n    data[\"value\"] = self.value.decode(\"utf-8\")\n    return data\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer","title":"<code>kevinbotlib.comm.KevinbotCommServer</code>","text":"<p>WebSocket-based server for handling real-time data synchronization.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class KevinbotCommServer:\n    \"\"\"WebSocket-based server for handling real-time data synchronization.\"\"\"\n\n    def __init__(self, host: str = \"localhost\", port: int = 8765) -&gt; None:\n        self.host: str = host\n        self.port: int = port\n\n        self.logger = _Logger()\n\n        self.data_store: dict[str, dict[str, Any]] = {}\n        self.clients: set[websockets.ServerConnection] = set()\n        self.tasks = set()\n\n        self.serving = False\n\n    async def remove_expired_data(self) -&gt; None:\n        \"\"\"Periodically removes expired data based on timeouts.\"\"\"\n        while True:\n            current_time = time.time()\n            expired_keys = [\n                key\n                for key, entry in self.data_store.items()\n                if entry[\"data\"][\"timeout\"] and entry[\"tsu\"] + entry[\"data\"][\"timeout\"] &lt; current_time\n            ]\n            for key in expired_keys:\n                del self.data_store[key]\n                await self.broadcast({\"action\": \"delete\", \"key\": key})\n            await asyncio.sleep(1)\n\n    async def broadcast(self, message: dict[str, Any]) -&gt; None:\n        \"\"\"Broadcasts a message to all connected clients.\"\"\"\n        if self.clients:\n            msg = orjson.dumps(message)\n            await asyncio.gather(*(client.send(msg) for client in self.clients))\n\n    async def handle_client(self, websocket: websockets.ServerConnection) -&gt; None:\n        \"\"\"Handles incoming WebSocket connections.\"\"\"\n        self.clients.add(websocket)\n        self.logger.info(f\"New client connected: {websocket.id}\")\n        try:\n            await websocket.send(orjson.dumps({\"action\": \"sync\", \"data\": self.data_store}))\n            async for message in websocket:\n                msg = orjson.loads(message)\n                if msg[\"action\"] == \"publish\":\n                    key = msg[\"key\"]\n                    tsc = time.time() if key not in self.data_store else self.data_store[key][\"tsc\"]\n                    self.data_store[key] = {\n                        \"data\": msg[\"data\"],\n                        \"tsu\": time.time(),\n                        \"tsc\": tsc,\n                    }\n                    await self.broadcast({\"action\": \"update\", \"key\": key, \"data\": self.data_store[key]})\n                elif msg[\"action\"] == \"delete\" and msg[\"key\"] in self.data_store:\n                    del self.data_store[msg[\"key\"]]\n                    await self.broadcast({\"action\": \"delete\", \"key\": msg[\"key\"]})\n        except websockets.ConnectionClosed:\n            pass\n        finally:\n            self.logger.info(f\"Client disconnected: {websocket.id}\")\n            self.clients.remove(websocket)\n\n    async def serve_async(self) -&gt; None:\n        \"\"\"Starts the WebSocket server.\"\"\"\n        self.logger.info(\"Starting a new KevinbotCommServer\")\n        server = await websockets.serve(self.handle_client, self.host, self.port, max_size=2**48 - 1)\n        task = asyncio.create_task(self.remove_expired_data())\n        self.tasks.add(task)\n        task.add_done_callback(self.tasks.discard)\n        self.serving = True\n        await server.wait_closed()\n        self.serving = False\n\n    def serve(self):\n        asyncio.run(self.serve_async())\n\n    def wait_until_serving(self, timeout: float = 5.0):\n        start_time = time.time()\n        while not self.serving:\n            if time.time() &gt; start_time + timeout:\n                msg = \"The server is not serving. You most likely called `wait_until_serving` before starting the server, or the server failed to start\"\n                raise kevinbotlib.exceptions.ServerTimeoutException(msg)\n            time.sleep(0.02)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer.remove_expired_data","title":"<code>remove_expired_data()</code>  <code>async</code>","text":"<p>Periodically removes expired data based on timeouts.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def remove_expired_data(self) -&gt; None:\n    \"\"\"Periodically removes expired data based on timeouts.\"\"\"\n    while True:\n        current_time = time.time()\n        expired_keys = [\n            key\n            for key, entry in self.data_store.items()\n            if entry[\"data\"][\"timeout\"] and entry[\"tsu\"] + entry[\"data\"][\"timeout\"] &lt; current_time\n        ]\n        for key in expired_keys:\n            del self.data_store[key]\n            await self.broadcast({\"action\": \"delete\", \"key\": key})\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer.broadcast","title":"<code>broadcast(message)</code>  <code>async</code>","text":"<p>Broadcasts a message to all connected clients.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def broadcast(self, message: dict[str, Any]) -&gt; None:\n    \"\"\"Broadcasts a message to all connected clients.\"\"\"\n    if self.clients:\n        msg = orjson.dumps(message)\n        await asyncio.gather(*(client.send(msg) for client in self.clients))\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer.handle_client","title":"<code>handle_client(websocket)</code>  <code>async</code>","text":"<p>Handles incoming WebSocket connections.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def handle_client(self, websocket: websockets.ServerConnection) -&gt; None:\n    \"\"\"Handles incoming WebSocket connections.\"\"\"\n    self.clients.add(websocket)\n    self.logger.info(f\"New client connected: {websocket.id}\")\n    try:\n        await websocket.send(orjson.dumps({\"action\": \"sync\", \"data\": self.data_store}))\n        async for message in websocket:\n            msg = orjson.loads(message)\n            if msg[\"action\"] == \"publish\":\n                key = msg[\"key\"]\n                tsc = time.time() if key not in self.data_store else self.data_store[key][\"tsc\"]\n                self.data_store[key] = {\n                    \"data\": msg[\"data\"],\n                    \"tsu\": time.time(),\n                    \"tsc\": tsc,\n                }\n                await self.broadcast({\"action\": \"update\", \"key\": key, \"data\": self.data_store[key]})\n            elif msg[\"action\"] == \"delete\" and msg[\"key\"] in self.data_store:\n                del self.data_store[msg[\"key\"]]\n                await self.broadcast({\"action\": \"delete\", \"key\": msg[\"key\"]})\n    except websockets.ConnectionClosed:\n        pass\n    finally:\n        self.logger.info(f\"Client disconnected: {websocket.id}\")\n        self.clients.remove(websocket)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer.serve_async","title":"<code>serve_async()</code>  <code>async</code>","text":"<p>Starts the WebSocket server.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def serve_async(self) -&gt; None:\n    \"\"\"Starts the WebSocket server.\"\"\"\n    self.logger.info(\"Starting a new KevinbotCommServer\")\n    server = await websockets.serve(self.handle_client, self.host, self.port, max_size=2**48 - 1)\n    task = asyncio.create_task(self.remove_expired_data())\n    self.tasks.add(task)\n    task.add_done_callback(self.tasks.discard)\n    self.serving = True\n    await server.wait_closed()\n    self.serving = False\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient","title":"<code>kevinbotlib.comm.KevinbotCommClient</code>","text":"<p>KevinbotLib WebSocket-based client for real-time data synchronization and communication.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class KevinbotCommClient:\n    \"\"\"KevinbotLib WebSocket-based client for real-time data synchronization and communication.\"\"\"\n\n    def __init__(\n        self,\n        host: str = \"localhost\",\n        port: int = 8765,\n        on_update: Callable[[str, Any], None] | None = None,\n        on_delete: Callable[[str], None] | None = None,\n        on_connect: Callable[[], None] | None = None,\n        on_disconnect: Callable[[], None] | None = None,\n        *,\n        auto_reconnect: bool = True,\n        register_basic_types: bool = True,\n    ) -&gt; None:\n        self._host = host\n        self._port = port\n        self.auto_reconnect = auto_reconnect\n\n        self.logger = _Logger()\n\n        self.data_store: dict[str, Any] = {}\n        self.data_types: dict[str, type[BaseSendable]] = {}\n\n        self.running = False\n        self.websocket: websockets.ClientConnection | None = None\n        self.loop = asyncio.get_event_loop()\n        self.thread: threading.Thread | None = None\n\n        self.on_update = on_update\n        self.on_delete = on_delete\n        self.on_connect = on_connect\n        self.on_disconnect = on_disconnect\n\n        self.hooks: dict[str, tuple[type[BaseSendable], Callable[[str, BaseSendable | None], Any]]] = {}\n\n        if register_basic_types:\n            self.register_type(BaseSendable)\n            self.register_type(IntegerSendable)\n            self.register_type(BooleanSendable)\n            self.register_type(StringSendable)\n            self.register_type(FloatSendable)\n            self.register_type(AnyListSendable)\n            self.register_type(DictSendable)\n\n    @property\n    def host(self):\n        return self._host\n\n    @host.setter\n    def host(self, value: str):\n        self._host = value\n        if self.is_connected():\n            self.disconnect()\n            self.connect()\n\n    @property\n    def port(self):\n        return self._port\n\n    @port.setter\n    def port(self, value: str):\n        self._port = value\n        if self.is_connected():\n            self.disconnect()\n            self.connect()\n\n    def get_latency(self) -&gt; float:\n        return self.websocket.latency if self.websocket else float(\"inf\")\n\n    def register_type(self, data_type: type[BaseSendable]):\n        self.data_types[data_type.model_fields[\"data_id\"].default] = data_type\n        self.logger.trace(\n            f\"Registered data type of id {data_type.model_fields['data_id'].default} as {data_type.__name__}\"\n        )\n\n    def connect(self) -&gt; None:\n        \"\"\"Starts the client in a background thread.\"\"\"\n        if self.running:\n            self.logger.warning(\"Client is already running\")\n            return\n\n        self.running = True\n        self.thread = threading.Thread(\n            target=self._run_async_loop, daemon=True, name=\"KevinbotLib.CommClient.AsyncLoop\"\n        )\n        self.thread.start()\n\n    def wait_until_connected(self, timeout: float = 5.0):\n        start_time = time.time()\n        while not self.websocket:\n            if time.time() &gt; start_time + timeout:\n                msg = \"The connection timed out\"\n                raise kevinbotlib.exceptions.HandshakeTimeoutException(msg)\n            time.sleep(0.02)\n\n    def is_connected(self):\n        return bool(self.websocket)\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Stops the client and closes the connection gracefully.\"\"\"\n        self.running = False\n        if self.loop and self.loop.is_running():\n            asyncio.run_coroutine_threadsafe(self._close_connection(), self.loop)\n\n    def _run_async_loop(self) -&gt; None:\n        \"\"\"Runs the async event loop in a separate thread.\"\"\"\n        asyncio.set_event_loop(self.loop)\n        if not self.loop.is_running():\n            self.loop.run_until_complete(self._connect_and_listen())\n        else:\n            asyncio.run_coroutine_threadsafe(self._connect_and_listen(), self.loop)\n\n    async def _connect_and_listen(self) -&gt; None:\n        \"\"\"Handles connection and message listening.\"\"\"\n        prev_connection = False\n        while self.running:\n            try:\n                async with websockets.connect(\n                    f\"ws://{self._host}:{self._port}\", max_size=2**48 - 1, ping_interval=1\n                ) as ws:\n                    self.websocket = ws\n                    if not prev_connection:\n                        self.logger.info(\"Connected to the server\")\n                        if self.on_connect:\n                            self.on_connect()\n                    prev_connection = True\n                    await self._handle_messages()\n            except (websockets.ConnectionClosed, ConnectionError, OSError, websockets.InvalidMessage) as e:\n                self.logger.error(f\"Unexpected error: {e!r}\")\n                self.websocket = None\n                if prev_connection:\n                    if self.on_disconnect:\n                        self.on_disconnect()\n                        self.data_store = {}\n                prev_connection = False\n                if self.auto_reconnect and self.running:\n                    self.logger.warning(\"Can't connect to server, retrying...\")\n                    await asyncio.sleep(1)\n                else:\n                    break\n\n    async def _handle_messages(self) -&gt; None:\n        \"\"\"Processes incoming messages.\"\"\"\n        if not self.websocket:\n            return\n        try:\n            async for message in self.websocket:\n                data = orjson.loads(message)\n\n                if data[\"action\"] == \"sync\":\n                    for hook in self.hooks:\n                        if data[\"data\"].get(hook) != self.data_store.get(hook):\n                            self.hooks[hook][1](hook, self.hooks[hook][0](**data[\"data\"].get(hook)[\"data\"]))\n                    self.data_store = data[\"data\"]\n                elif data[\"action\"] == \"update\":\n                    key, value = data[\"key\"], data[\"data\"]\n                    self.data_store[key] = value\n                    if self.on_update:\n                        self.on_update(key, value)\n                    if key in self.hooks:\n                        self.hooks[key][1](key, self.hooks[key][0](**data[\"data\"][\"data\"]))\n                elif data[\"action\"] == \"delete\":\n                    key = data[\"key\"]\n                    self.data_store.pop(key, None)\n                    if self.on_delete:\n                        self.on_delete(key)\n                    if key in self.hooks:\n                        self.hooks[hook][1](hook, None)\n        except orjson.JSONDecodeError as e:\n            self.logger.error(f\"Error processing messages: {e}\")\n\n    async def _close_connection(self) -&gt; None:\n        \"\"\"Closes the WebSocket connection.\"\"\"\n        if self.websocket:\n            await self.websocket.close()\n            self.logger.info(\"Connection closed\")\n            if self.on_disconnect:\n                self.on_disconnect()\n            self.websocket = None\n\n    def add_hook(self, key: str | CommPath, data_type: type[T], callback: Callable[[str, T | None], Any]):\n        \"\"\"Adds a hook for when new data is recieved from the key\n\n        Args:\n            key (str): Key for data hook\n        \"\"\"\n        if isinstance(key, CommPath):\n            key = key.path\n        self.hooks[key] = (data_type, callback) # type: ignore\n\n    def send(self, key: str | CommPath, data: BaseSendable | SendableGenerator) -&gt; None:\n        \"\"\"Publishes data to the server.\"\"\"\n        if not self.running or not self.websocket:\n            self.logger.error(f\"Cannot publish to {key}: client is not connected\")\n            return\n\n        if isinstance(key, CommPath):\n            key = key.path\n\n        if isinstance(data, SendableGenerator):\n            data = data.generate_sendable()\n\n        async def _publish() -&gt; None:\n            if not self.websocket:\n                return\n            message = orjson.dumps({\"action\": \"publish\", \"key\": key, \"data\": data.get_dict()})\n            await self.websocket.send(message)\n\n        asyncio.run_coroutine_threadsafe(_publish(), self.loop)\n\n    def get(self, key: str | CommPath, data_type: type[T], default: Any = None) -&gt; T | None:\n        \"\"\"Retrieves stored data.\"\"\"\n        if isinstance(key, CommPath):\n            key = key.path\n\n        if key not in self.data_store:\n            return None\n        if self.data_store.get(key, default)[\"data\"][\"did\"] != data_type.model_fields[\"data_id\"].default:\n            self.logger.error(\n                f\"Couldn't get value of {key}, requested value of id {data_type.model_fields['data_id'].default}, got one of {self.data_store.get(key, default)['data']['did']}\"\n            )\n            return None\n\n        return data_type(**self.data_store.get(key, default)[\"data\"])\n\n    def get_raw(self, key: str | CommPath) -&gt; dict | None:\n        if isinstance(key, CommPath):\n            key = key.path\n\n        if key not in self.data_store:\n            return None\n\n        return self.data_store.get(key, None)[\"data\"]\n\n    def get_keys(self):\n        return list(self.data_store.keys())\n\n    def delete(self, key: str | CommPath) -&gt; None:\n        \"\"\"Deletes data from the server.\"\"\"\n        if isinstance(key, CommPath):\n            key = key.path\n\n        if not self.running or not self.websocket:\n            self.logger.error(\"Cannot delete: client is not connected\")\n            return\n\n        async def _delete() -&gt; None:\n            if not self.websocket:\n                return\n            message = orjson.dumps({\"action\": \"delete\", \"key\": key})\n            await self.websocket.send(message)\n\n        asyncio.run_coroutine_threadsafe(_delete(), self.loop)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.connect","title":"<code>connect()</code>","text":"<p>Starts the client in a background thread.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def connect(self) -&gt; None:\n    \"\"\"Starts the client in a background thread.\"\"\"\n    if self.running:\n        self.logger.warning(\"Client is already running\")\n        return\n\n    self.running = True\n    self.thread = threading.Thread(\n        target=self._run_async_loop, daemon=True, name=\"KevinbotLib.CommClient.AsyncLoop\"\n    )\n    self.thread.start()\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.disconnect","title":"<code>disconnect()</code>","text":"<p>Stops the client and closes the connection gracefully.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Stops the client and closes the connection gracefully.\"\"\"\n    self.running = False\n    if self.loop and self.loop.is_running():\n        asyncio.run_coroutine_threadsafe(self._close_connection(), self.loop)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.add_hook","title":"<code>add_hook(key, data_type, callback)</code>","text":"<p>Adds a hook for when new data is recieved from the key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key for data hook</p> required Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def add_hook(self, key: str | CommPath, data_type: type[T], callback: Callable[[str, T | None], Any]):\n    \"\"\"Adds a hook for when new data is recieved from the key\n\n    Args:\n        key (str): Key for data hook\n    \"\"\"\n    if isinstance(key, CommPath):\n        key = key.path\n    self.hooks[key] = (data_type, callback) # type: ignore\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.send","title":"<code>send(key, data)</code>","text":"<p>Publishes data to the server.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def send(self, key: str | CommPath, data: BaseSendable | SendableGenerator) -&gt; None:\n    \"\"\"Publishes data to the server.\"\"\"\n    if not self.running or not self.websocket:\n        self.logger.error(f\"Cannot publish to {key}: client is not connected\")\n        return\n\n    if isinstance(key, CommPath):\n        key = key.path\n\n    if isinstance(data, SendableGenerator):\n        data = data.generate_sendable()\n\n    async def _publish() -&gt; None:\n        if not self.websocket:\n            return\n        message = orjson.dumps({\"action\": \"publish\", \"key\": key, \"data\": data.get_dict()})\n        await self.websocket.send(message)\n\n    asyncio.run_coroutine_threadsafe(_publish(), self.loop)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.get","title":"<code>get(key, data_type, default=None)</code>","text":"<p>Retrieves stored data.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get(self, key: str | CommPath, data_type: type[T], default: Any = None) -&gt; T | None:\n    \"\"\"Retrieves stored data.\"\"\"\n    if isinstance(key, CommPath):\n        key = key.path\n\n    if key not in self.data_store:\n        return None\n    if self.data_store.get(key, default)[\"data\"][\"did\"] != data_type.model_fields[\"data_id\"].default:\n        self.logger.error(\n            f\"Couldn't get value of {key}, requested value of id {data_type.model_fields['data_id'].default}, got one of {self.data_store.get(key, default)['data']['did']}\"\n        )\n        return None\n\n    return data_type(**self.data_store.get(key, default)[\"data\"])\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.delete","title":"<code>delete(key)</code>","text":"<p>Deletes data from the server.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def delete(self, key: str | CommPath) -&gt; None:\n    \"\"\"Deletes data from the server.\"\"\"\n    if isinstance(key, CommPath):\n        key = key.path\n\n    if not self.running or not self.websocket:\n        self.logger.error(\"Cannot delete: client is not connected\")\n        return\n\n    async def _delete() -&gt; None:\n        if not self.websocket:\n            return\n        message = orjson.dumps({\"action\": \"delete\", \"key\": key})\n        await self.websocket.send(message)\n\n    asyncio.run_coroutine_threadsafe(_delete(), self.loop)\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler","title":"<code>kevinbotlib.scheduler</code>","text":""},{"location":"reference/#kevinbotlib.scheduler.Command","title":"<code>kevinbotlib.scheduler.Command</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Synchronous command interface that users will implement</p> Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>class Command(ABC):\n    \"\"\"Synchronous command interface that users will implement\"\"\"\n\n    @abstractmethod\n    def init(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def execute(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def end(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def finished(self) -&gt; bool:\n        return False\n\n    def then(self, next_command: \"Command\"):\n        \"\"\"Chain commands to run sequentially\"\"\"\n        commands = self.startup_commands if isinstance(self, SequentialCommand) else [self]\n        commands.append(next_command)\n        return SequentialCommand(commands)\n\n    def alongside(self, next_command: \"Command\"):\n        \"\"\"Chain commands to run sequentially\"\"\"\n        commands = self.startup_commands if isinstance(self, ParallelCommand) else [self]\n        commands.append(next_command)\n        return ParallelCommand(commands)\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler.Command.then","title":"<code>then(next_command)</code>","text":"<p>Chain commands to run sequentially</p> Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>def then(self, next_command: \"Command\"):\n    \"\"\"Chain commands to run sequentially\"\"\"\n    commands = self.startup_commands if isinstance(self, SequentialCommand) else [self]\n    commands.append(next_command)\n    return SequentialCommand(commands)\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler.Command.alongside","title":"<code>alongside(next_command)</code>","text":"<p>Chain commands to run sequentially</p> Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>def alongside(self, next_command: \"Command\"):\n    \"\"\"Chain commands to run sequentially\"\"\"\n    commands = self.startup_commands if isinstance(self, ParallelCommand) else [self]\n    commands.append(next_command)\n    return ParallelCommand(commands)\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler.CommandScheduler","title":"<code>kevinbotlib.scheduler.CommandScheduler</code>","text":"Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>class CommandScheduler:\n    instance: Self | None = None\n\n    def __init__(self) -&gt; None:\n        if CommandScheduler.instance:\n            msg = \"Another instance of CommandScheduler is running\"\n            raise CommandSchedulerAlreadyExistsException(msg)\n\n        self._scheduled: list[_ScheduledCommand] = []\n        self._triggers: list[Trigger] = []\n\n    def get_instance(self):\n        if CommandScheduler.instance:\n            return CommandScheduler.instance\n        raise CommandSchedulerDoesNotExistException\n\n    def schedule(self, command: Command):\n        self._schedule(command, None)\n\n    def register_trigger(self, trigger: Trigger):\n        self._triggers.append(trigger)\n\n    def _schedule(self, command: Command, trigger: Trigger | None):\n        self._scheduled.append({\"command\": command, \"trigger\": trigger, \"has_init\": False})\n\n    def iterate(self):\n        \"\"\"\n        Executes one iteration of the command scheduler, processing all scheduled commands\n        and their triggers according to their current state and conditions.\n        \"\"\"\n        # Get trigger states, determine if command should be run\n        for trigger in self._triggers:\n            current_state, state_changed = trigger.check()\n\n            if current_state and state_changed and trigger.actions.on_true:\n                self._schedule(trigger.actions.on_true, trigger)\n\n            if not current_state and state_changed and trigger.actions.on_false:\n                self._schedule(trigger.actions.on_false, trigger)\n\n            if (\n                current_state\n                and trigger.actions.while_true\n                and state_changed\n                and not any(scheduled[\"command\"] is trigger.actions.while_true for scheduled in self._scheduled)\n            ):\n                self._schedule(trigger.actions.while_true, trigger)\n\n            if (\n                not current_state\n                and trigger.actions.while_false\n                and state_changed\n                and not any(scheduled[\"command\"] is trigger.actions.while_false for scheduled in self._scheduled)\n            ):\n                self._schedule(trigger.actions.while_false, trigger)\n\n        # Process all scheduled commands\n        i = 0\n        while i &lt; len(self._scheduled):\n            scheduled = self._scheduled[i]\n            command = scheduled[\"command\"]\n            trigger = scheduled[\"trigger\"]\n\n            # Initialize command if not already initialized\n            if not scheduled[\"has_init\"]:\n                command.init()\n                scheduled[\"has_init\"] = True\n\n            # Check if trigger conditions are still satisfied for while_* commands\n            if trigger:\n                current_state, _ = trigger.check()\n                is_while_command = (trigger.actions.while_true is command and not current_state) or (\n                    trigger.actions.while_false is command and current_state\n                )\n                if is_while_command:\n                    # End and remove the command if trigger conditions are no longer satisfied\n                    command.end()\n                    self._scheduled.pop(i)\n                    continue\n\n            # Execute command\n            command.execute()\n\n            # Check if command is finished\n            if command.finished():\n                command.end()\n                self._scheduled.pop(i)\n            else:\n                i += 1\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler.CommandScheduler.iterate","title":"<code>iterate()</code>","text":"<p>Executes one iteration of the command scheduler, processing all scheduled commands and their triggers according to their current state and conditions.</p> Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>def iterate(self):\n    \"\"\"\n    Executes one iteration of the command scheduler, processing all scheduled commands\n    and their triggers according to their current state and conditions.\n    \"\"\"\n    # Get trigger states, determine if command should be run\n    for trigger in self._triggers:\n        current_state, state_changed = trigger.check()\n\n        if current_state and state_changed and trigger.actions.on_true:\n            self._schedule(trigger.actions.on_true, trigger)\n\n        if not current_state and state_changed and trigger.actions.on_false:\n            self._schedule(trigger.actions.on_false, trigger)\n\n        if (\n            current_state\n            and trigger.actions.while_true\n            and state_changed\n            and not any(scheduled[\"command\"] is trigger.actions.while_true for scheduled in self._scheduled)\n        ):\n            self._schedule(trigger.actions.while_true, trigger)\n\n        if (\n            not current_state\n            and trigger.actions.while_false\n            and state_changed\n            and not any(scheduled[\"command\"] is trigger.actions.while_false for scheduled in self._scheduled)\n        ):\n            self._schedule(trigger.actions.while_false, trigger)\n\n    # Process all scheduled commands\n    i = 0\n    while i &lt; len(self._scheduled):\n        scheduled = self._scheduled[i]\n        command = scheduled[\"command\"]\n        trigger = scheduled[\"trigger\"]\n\n        # Initialize command if not already initialized\n        if not scheduled[\"has_init\"]:\n            command.init()\n            scheduled[\"has_init\"] = True\n\n        # Check if trigger conditions are still satisfied for while_* commands\n        if trigger:\n            current_state, _ = trigger.check()\n            is_while_command = (trigger.actions.while_true is command and not current_state) or (\n                trigger.actions.while_false is command and current_state\n            )\n            if is_while_command:\n                # End and remove the command if trigger conditions are no longer satisfied\n                command.end()\n                self._scheduled.pop(i)\n                continue\n\n        # Execute command\n        command.execute()\n\n        # Check if command is finished\n        if command.finished():\n            command.end()\n            self._scheduled.pop(i)\n        else:\n            i += 1\n</code></pre>"},{"location":"reference/#kevinbotlib.vision","title":"<code>kevinbotlib.vision</code>","text":""},{"location":"reference/#kevinbotlib.vision.SingleFrameSendable","title":"<code>kevinbotlib.vision.SingleFrameSendable</code>","text":"<p>               Bases: <code>BinarySendable</code></p> <p>Sendable for a single frame of video or an image</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class SingleFrameSendable(BinarySendable):\n    \"\"\"\n    Sendable for a single frame of video or an image\n    \"\"\"\n\n    encoding: str\n    \"\"\"Frame encoding format\n\n    Supported encodings:\n    * JPG\n    * PNG\n    \"\"\"\n    data_id: str = \"kevinbotlib.vision.dtype.frame\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    struct: ClassVar[dict[str, Any]] = {\n        \"dashboard\": [\n            {\"element\": \"value\", \"format\": \"limit:1024\"},\n            {\"element\": \"resolution\", \"format\": \"raw\"},\n            {\"element\": \"quality\", \"format\": \"raw\"},\n            {\"element\": \"encoding\", \"format\": \"raw\"},\n        ]\n    }\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        data = super().get_dict()\n        data[\"encoding\"] = self.encoding\n        return data\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.SingleFrameSendable.encoding","title":"<code>encoding</code>  <code>instance-attribute</code>","text":"<p>Frame encoding format</p> <p>Supported encodings: * JPG * PNG</p>"},{"location":"reference/#kevinbotlib.vision.SingleFrameSendable.data_id","title":"<code>data_id = 'kevinbotlib.vision.dtype.frame'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.vision.SingleFrameSendable.struct","title":"<code>struct = {'dashboard': [{'element': 'value', 'format': 'limit:1024'}, {'element': 'resolution', 'format': 'raw'}, {'element': 'quality', 'format': 'raw'}, {'element': 'encoding', 'format': 'raw'}]}</code>  <code>class-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.vision.SingleFrameSendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    data = super().get_dict()\n    data[\"encoding\"] = self.encoding\n    return data\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.MjpegStreamSendable","title":"<code>kevinbotlib.vision.MjpegStreamSendable</code>","text":"<p>               Bases: <code>SingleFrameSendable</code></p> <p>Sendable for a single frame of an MJPG stream</p> <p>Contains all required information for decoding a video stream</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class MjpegStreamSendable(SingleFrameSendable):\n    \"\"\"\n    Sendable for a single frame of an MJPG stream\n\n    Contains all required information for decoding a video stream\n    \"\"\"\n\n    data_id: str = \"kevinbotlib.vision.dtype.mjpeg\"\n    \"\"\"Internally used to differentiate sendable types\"\"\"\n    quality: int\n    \"\"\"The current JPEG compression level out of 100 - lower means more compression\"\"\"\n    resolution: Annotated[list[int], Len(min_length=2, max_length=2)]\n    \"\"\"A two integer list containing the video resolution (WIDTH x HEIGHT)\"\"\"\n    encoding: str = \"JPG\"\n    \"\"\"Frame encoding format\"\"\"\n    struct: ClassVar[dict[str, Any]] = {\n        \"dashboard\": [\n            {\"element\": \"value\", \"format\": \"limit:1024\"},\n            {\"element\": \"resolution\", \"format\": \"raw\"},\n            {\"element\": \"quality\", \"format\": \"raw\"},\n            {\"element\": \"encoding\", \"format\": \"raw\"},\n        ]\n    }\n    \"\"\"Data structure _suggestion_ for use in dashboard applications\"\"\"\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Return the sendable in dictionary form\n\n        Returns:\n            dict: The sendable data\n        \"\"\"\n        data = super().get_dict()\n        data[\"quality\"] = self.quality\n        data[\"resolution\"] = self.resolution\n        return data\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.MjpegStreamSendable.data_id","title":"<code>data_id = 'kevinbotlib.vision.dtype.mjpeg'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internally used to differentiate sendable types</p>"},{"location":"reference/#kevinbotlib.vision.MjpegStreamSendable.quality","title":"<code>quality</code>  <code>instance-attribute</code>","text":"<p>The current JPEG compression level out of 100 - lower means more compression</p>"},{"location":"reference/#kevinbotlib.vision.MjpegStreamSendable.resolution","title":"<code>resolution</code>  <code>instance-attribute</code>","text":"<p>A two integer list containing the video resolution (WIDTH x HEIGHT)</p>"},{"location":"reference/#kevinbotlib.vision.MjpegStreamSendable.encoding","title":"<code>encoding = 'JPG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Frame encoding format</p>"},{"location":"reference/#kevinbotlib.vision.MjpegStreamSendable.struct","title":"<code>struct = {'dashboard': [{'element': 'value', 'format': 'limit:1024'}, {'element': 'resolution', 'format': 'raw'}, {'element': 'quality', 'format': 'raw'}, {'element': 'encoding', 'format': 'raw'}]}</code>  <code>class-attribute</code>","text":"<p>Data structure suggestion for use in dashboard applications</p>"},{"location":"reference/#kevinbotlib.vision.MjpegStreamSendable.get_dict","title":"<code>get_dict()</code>","text":"<p>Return the sendable in dictionary form</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The sendable data</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Return the sendable in dictionary form\n\n    Returns:\n        dict: The sendable data\n    \"\"\"\n    data = super().get_dict()\n    data[\"quality\"] = self.quality\n    data[\"resolution\"] = self.resolution\n    return data\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameEncoders","title":"<code>kevinbotlib.vision.FrameEncoders</code>","text":"<p>Encoders from OpenCV Mats into raw bytes or network sendables</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class FrameEncoders:\n    \"\"\"\n    Encoders from OpenCV Mats into raw bytes or network sendables\n    \"\"\"\n\n    @staticmethod\n    def encode_sendable_jpg(frame: MatLike, quality: int = 80) -&gt; SingleFrameSendable:\n        \"\"\"Encode an OpenCV Mat to a `SingleFrameSendable` using JPEG encoding\n\n        Args:\n            frame (MatLike): The Mat to encode\n            quality (int, optional): The JPEG quality level. Defaults to 80.\n\n        Returns:\n            SingleFrameSendable: A sendable to be sent over the network\n        \"\"\"\n        _, buffer = cv2.imencode(\".jpg\", frame, [cv2.IMWRITE_JPEG_QUALITY, quality])\n        return SingleFrameSendable(value=base64.b64encode(buffer), encoding=\"JPG\")\n\n    @staticmethod\n    def encode_sendable_png(frame: MatLike, compression: int = 3) -&gt; SingleFrameSendable:\n        \"\"\"Encode an OpenCV Mat to a `SingleFrameSendable` using PNG encoding\n\n        Args:\n            frame (MatLike): The Mat to encode\n            compression (int, optional): The PNG compression level. Defaults to 3.\n\n        Returns:\n            SingleFrameSendable: A sendable to be sent over the network\n        \"\"\"\n        _, buffer = cv2.imencode(\".png\", frame, [cv2.IMWRITE_PNG_COMPRESSION, compression])\n        return SingleFrameSendable(value=base64.b64encode(buffer), encoding=\"PNG\")\n\n    @staticmethod\n    def encode_jpg(frame: MatLike, quality: int = 80) -&gt; bytes:\n        \"\"\"Encode an OpenCV Mat to raw bytes using JPEG encoding\n\n        Args:\n            frame (MatLike): The Mat to encode\n            quality (int, optional): The JPEG quality level. Defaults to 80.\n\n        Returns:\n            bytes: Raw data\n        \"\"\"\n        _, buffer = cv2.imencode(\".jpg\", frame, [cv2.IMWRITE_JPEG_QUALITY, quality])\n        return base64.b64encode(buffer)\n\n    @staticmethod\n    def encode_png(frame: MatLike, compression: int = 3) -&gt; bytes:\n        \"\"\"Encode an OpenCV Mat to raw bytes using PNG encoding\n\n        Args:\n            frame (MatLike): The Mat to encode\n            compression (int, optional): The PNG compression level. Defaults to 3.\n\n        Returns:\n            bytes: Raw data\n        \"\"\"\n        _, buffer = cv2.imencode(\".png\", frame, [cv2.IMWRITE_PNG_COMPRESSION, compression])\n        return base64.b64encode(buffer)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameEncoders.encode_sendable_jpg","title":"<code>encode_sendable_jpg(frame, quality=80)</code>  <code>staticmethod</code>","text":"<p>Encode an OpenCV Mat to a <code>SingleFrameSendable</code> using JPEG encoding</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>MatLike</code> <p>The Mat to encode</p> required <code>quality</code> <code>int</code> <p>The JPEG quality level. Defaults to 80.</p> <code>80</code> <p>Returns:</p> Name Type Description <code>SingleFrameSendable</code> <code>SingleFrameSendable</code> <p>A sendable to be sent over the network</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@staticmethod\ndef encode_sendable_jpg(frame: MatLike, quality: int = 80) -&gt; SingleFrameSendable:\n    \"\"\"Encode an OpenCV Mat to a `SingleFrameSendable` using JPEG encoding\n\n    Args:\n        frame (MatLike): The Mat to encode\n        quality (int, optional): The JPEG quality level. Defaults to 80.\n\n    Returns:\n        SingleFrameSendable: A sendable to be sent over the network\n    \"\"\"\n    _, buffer = cv2.imencode(\".jpg\", frame, [cv2.IMWRITE_JPEG_QUALITY, quality])\n    return SingleFrameSendable(value=base64.b64encode(buffer), encoding=\"JPG\")\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameEncoders.encode_sendable_png","title":"<code>encode_sendable_png(frame, compression=3)</code>  <code>staticmethod</code>","text":"<p>Encode an OpenCV Mat to a <code>SingleFrameSendable</code> using PNG encoding</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>MatLike</code> <p>The Mat to encode</p> required <code>compression</code> <code>int</code> <p>The PNG compression level. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>SingleFrameSendable</code> <code>SingleFrameSendable</code> <p>A sendable to be sent over the network</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@staticmethod\ndef encode_sendable_png(frame: MatLike, compression: int = 3) -&gt; SingleFrameSendable:\n    \"\"\"Encode an OpenCV Mat to a `SingleFrameSendable` using PNG encoding\n\n    Args:\n        frame (MatLike): The Mat to encode\n        compression (int, optional): The PNG compression level. Defaults to 3.\n\n    Returns:\n        SingleFrameSendable: A sendable to be sent over the network\n    \"\"\"\n    _, buffer = cv2.imencode(\".png\", frame, [cv2.IMWRITE_PNG_COMPRESSION, compression])\n    return SingleFrameSendable(value=base64.b64encode(buffer), encoding=\"PNG\")\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameEncoders.encode_jpg","title":"<code>encode_jpg(frame, quality=80)</code>  <code>staticmethod</code>","text":"<p>Encode an OpenCV Mat to raw bytes using JPEG encoding</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>MatLike</code> <p>The Mat to encode</p> required <code>quality</code> <code>int</code> <p>The JPEG quality level. Defaults to 80.</p> <code>80</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Raw data</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@staticmethod\ndef encode_jpg(frame: MatLike, quality: int = 80) -&gt; bytes:\n    \"\"\"Encode an OpenCV Mat to raw bytes using JPEG encoding\n\n    Args:\n        frame (MatLike): The Mat to encode\n        quality (int, optional): The JPEG quality level. Defaults to 80.\n\n    Returns:\n        bytes: Raw data\n    \"\"\"\n    _, buffer = cv2.imencode(\".jpg\", frame, [cv2.IMWRITE_JPEG_QUALITY, quality])\n    return base64.b64encode(buffer)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameEncoders.encode_png","title":"<code>encode_png(frame, compression=3)</code>  <code>staticmethod</code>","text":"<p>Encode an OpenCV Mat to raw bytes using PNG encoding</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>MatLike</code> <p>The Mat to encode</p> required <code>compression</code> <code>int</code> <p>The PNG compression level. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Raw data</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@staticmethod\ndef encode_png(frame: MatLike, compression: int = 3) -&gt; bytes:\n    \"\"\"Encode an OpenCV Mat to raw bytes using PNG encoding\n\n    Args:\n        frame (MatLike): The Mat to encode\n        compression (int, optional): The PNG compression level. Defaults to 3.\n\n    Returns:\n        bytes: Raw data\n    \"\"\"\n    _, buffer = cv2.imencode(\".png\", frame, [cv2.IMWRITE_PNG_COMPRESSION, compression])\n    return base64.b64encode(buffer)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameDecoders","title":"<code>kevinbotlib.vision.FrameDecoders</code>","text":"<p>Decoders from Base64 or network sendables to OpenCV Mats</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class FrameDecoders:\n    \"\"\"\n    Decoders from Base64 or network sendables to OpenCV Mats\n    \"\"\"\n\n    @staticmethod\n    def decode_sendable(sendable: SingleFrameSendable) -&gt; MatLike:\n        \"\"\"Decode a SingleFrameSendable into an OpenCV Mat\n\n        Args:\n            sendable (SingleFrameSendable): The sendable to decode\n\n        Raises:\n            ValueError: If the encoding type isn't recognized\n\n        Returns:\n            MatLike: An OpenCV Mat\n        \"\"\"\n        buffer = base64.b64decode(sendable.value)\n        if sendable.encoding == \"JPG\":\n            return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_COLOR)\n        if sendable.encoding == \"PNG\":\n            return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_UNCHANGED)\n        msg = f\"Unsupported encoding: {sendable.encoding}\"\n        raise ValueError(msg)\n\n    @staticmethod\n    def decode_base64(data: str, encoding: str) -&gt; MatLike:\n        \"\"\"Decode a base64 string into an OpenCV Mat\n\n        Args:\n            data (str): The base64 data to decode\n            encoding (str): The encoding format. Can be JPG or \"PNG\"\n\n        Raises:\n            ValueError: If the encoding type isn't recognized\n\n        Returns:\n            MatLike: An OpenCV Mat\n        \"\"\"\n        buffer = base64.b64decode(data)\n        if encoding == \"JPG\":\n            return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_COLOR)\n        if encoding == \"PNG\":\n            return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_UNCHANGED)\n        msg = f\"Unsupported encoding: {encoding}\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameDecoders.decode_sendable","title":"<code>decode_sendable(sendable)</code>  <code>staticmethod</code>","text":"<p>Decode a SingleFrameSendable into an OpenCV Mat</p> <p>Parameters:</p> Name Type Description Default <code>sendable</code> <code>SingleFrameSendable</code> <p>The sendable to decode</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the encoding type isn't recognized</p> <p>Returns:</p> Name Type Description <code>MatLike</code> <code>MatLike</code> <p>An OpenCV Mat</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@staticmethod\ndef decode_sendable(sendable: SingleFrameSendable) -&gt; MatLike:\n    \"\"\"Decode a SingleFrameSendable into an OpenCV Mat\n\n    Args:\n        sendable (SingleFrameSendable): The sendable to decode\n\n    Raises:\n        ValueError: If the encoding type isn't recognized\n\n    Returns:\n        MatLike: An OpenCV Mat\n    \"\"\"\n    buffer = base64.b64decode(sendable.value)\n    if sendable.encoding == \"JPG\":\n        return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_COLOR)\n    if sendable.encoding == \"PNG\":\n        return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_UNCHANGED)\n    msg = f\"Unsupported encoding: {sendable.encoding}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameDecoders.decode_base64","title":"<code>decode_base64(data, encoding)</code>  <code>staticmethod</code>","text":"<p>Decode a base64 string into an OpenCV Mat</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The base64 data to decode</p> required <code>encoding</code> <code>str</code> <p>The encoding format. Can be JPG or \"PNG\"</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the encoding type isn't recognized</p> <p>Returns:</p> Name Type Description <code>MatLike</code> <code>MatLike</code> <p>An OpenCV Mat</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@staticmethod\ndef decode_base64(data: str, encoding: str) -&gt; MatLike:\n    \"\"\"Decode a base64 string into an OpenCV Mat\n\n    Args:\n        data (str): The base64 data to decode\n        encoding (str): The encoding format. Can be JPG or \"PNG\"\n\n    Raises:\n        ValueError: If the encoding type isn't recognized\n\n    Returns:\n        MatLike: An OpenCV Mat\n    \"\"\"\n    buffer = base64.b64decode(data)\n    if encoding == \"JPG\":\n        return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_COLOR)\n    if encoding == \"PNG\":\n        return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_UNCHANGED)\n    msg = f\"Unsupported encoding: {encoding}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.VisionCommUtils","title":"<code>kevinbotlib.vision.VisionCommUtils</code>","text":"<p>Various utilities to integrate vision data with networking</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class VisionCommUtils:\n    \"\"\"\n    Various utilities to integrate vision data with networking\n    \"\"\"\n\n    @staticmethod\n    def init_comms_types(client: KevinbotCommClient) -&gt; None:\n        \"\"\"Allows the use of frame data over the communication client\n\n        Args:\n            client (KevinbotCommClient): The communication client to integrate with\n        \"\"\"\n        client.register_type(SingleFrameSendable)\n        client.register_type(MjpegStreamSendable)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.VisionCommUtils.init_comms_types","title":"<code>init_comms_types(client)</code>  <code>staticmethod</code>","text":"<p>Allows the use of frame data over the communication client</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>KevinbotCommClient</code> <p>The communication client to integrate with</p> required Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@staticmethod\ndef init_comms_types(client: KevinbotCommClient) -&gt; None:\n    \"\"\"Allows the use of frame data over the communication client\n\n    Args:\n        client (KevinbotCommClient): The communication client to integrate with\n    \"\"\"\n    client.register_type(SingleFrameSendable)\n    client.register_type(MjpegStreamSendable)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.BaseCamera","title":"<code>kevinbotlib.vision.BaseCamera</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for creating Vision Cameras</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class BaseCamera(ABC):\n    \"\"\"Abstract class for creating Vision Cameras\"\"\"\n\n    @abstractmethod\n    def get_frame(self) -&gt; tuple[bool, MatLike]:\n        \"\"\"Get the current frame from the camera\n\n        Returns:\n            tuple[bool, MatLike]: Frame retrieval success and an OpenCV Mat\n        \"\"\"\n\n    @abstractmethod\n    def set_resolution(self, width: int, height: int) -&gt; None:\n        \"\"\"Attempt to set the current camera resolution\n\n        Args:\n            width (int): Frame width in px\n            height (int): Frame height in px\n        \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.BaseCamera.get_frame","title":"<code>get_frame()</code>  <code>abstractmethod</code>","text":"<p>Get the current frame from the camera</p> <p>Returns:</p> Type Description <code>tuple[bool, MatLike]</code> <p>tuple[bool, MatLike]: Frame retrieval success and an OpenCV Mat</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@abstractmethod\ndef get_frame(self) -&gt; tuple[bool, MatLike]:\n    \"\"\"Get the current frame from the camera\n\n    Returns:\n        tuple[bool, MatLike]: Frame retrieval success and an OpenCV Mat\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.BaseCamera.set_resolution","title":"<code>set_resolution(width, height)</code>  <code>abstractmethod</code>","text":"<p>Attempt to set the current camera resolution</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Frame width in px</p> required <code>height</code> <code>int</code> <p>Frame height in px</p> required Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@abstractmethod\ndef set_resolution(self, width: int, height: int) -&gt; None:\n    \"\"\"Attempt to set the current camera resolution\n\n    Args:\n        width (int): Frame width in px\n        height (int): Frame height in px\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.CameraByIndex","title":"<code>kevinbotlib.vision.CameraByIndex</code>","text":"<p>               Bases: <code>BaseCamera</code></p> <p>Create an OpenCV camera from a device index</p> <p>Not recommended if you have more than one camera on a system</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class CameraByIndex(BaseCamera):\n    \"\"\"Create an OpenCV camera from a device index\n\n    Not recommended if you have more than one camera on a system\n    \"\"\"\n\n    def __init__(self, index: int):\n        \"\"\"Initialize the camera\n\n        Args:\n            index (int): Index of the camera\n        \"\"\"\n        self.capture = cv2.VideoCapture(index)\n        self.capture.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter.fourcc(*\"MJPG\"))\n        self.capture.set(cv2.CAP_PROP_FPS, 60)\n\n    def get_frame(self) -&gt; tuple[bool, MatLike]:\n        return self.capture.read()\n\n    def set_resolution(self, width: int, height: int) -&gt; None:\n        self.capture.set(cv2.CAP_PROP_FRAME_WIDTH, width)\n        self.capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.CameraByIndex.__init__","title":"<code>__init__(index)</code>","text":"<p>Initialize the camera</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the camera</p> required Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>def __init__(self, index: int):\n    \"\"\"Initialize the camera\n\n    Args:\n        index (int): Index of the camera\n    \"\"\"\n    self.capture = cv2.VideoCapture(index)\n    self.capture.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter.fourcc(*\"MJPG\"))\n    self.capture.set(cv2.CAP_PROP_FPS, 60)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.CameraByDevicePath","title":"<code>kevinbotlib.vision.CameraByDevicePath</code>","text":"<p>               Bases: <code>BaseCamera</code></p> <p>Create an OpenCV camera from a device path</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class CameraByDevicePath(BaseCamera):\n    \"\"\"Create an OpenCV camera from a device path\"\"\"\n\n    def __init__(self, path: str):\n        \"\"\"Initialize the camera\n\n        Args:\n            path (str): Device path of the camera ex: `/dev/video0`\n        \"\"\"\n        self.capture = cv2.VideoCapture(path)\n\n    def get_frame(self) -&gt; tuple[bool, MatLike]:\n        return self.capture.read()\n\n    def set_resolution(self, width: int, height: int) -&gt; None:\n        self.capture.set(cv2.CAP_PROP_FRAME_WIDTH, width)\n        self.capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.CameraByDevicePath.__init__","title":"<code>__init__(path)</code>","text":"<p>Initialize the camera</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Device path of the camera ex: <code>/dev/video0</code></p> required Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>def __init__(self, path: str):\n    \"\"\"Initialize the camera\n\n    Args:\n        path (str): Device path of the camera ex: `/dev/video0`\n    \"\"\"\n    self.capture = cv2.VideoCapture(path)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.VisionPipeline","title":"<code>kevinbotlib.vision.VisionPipeline</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract vision processing pipeline</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class VisionPipeline(ABC):\n    \"\"\"\n    An abstract vision processing pipeline\n    \"\"\"\n\n    def __init__(self, source: Callable[[], tuple[bool, MatLike]]) -&gt; None:\n        \"\"\"Pipeline initialization\n\n        Args:\n            source (Callable[[], tuple[bool, MatLike]]): Getter for the frame to process\n        \"\"\"\n        self.source = source\n\n    @abstractmethod\n    def run(*args, **kwargs) -&gt; tuple[bool, MatLike | None]:\n        \"\"\"Runs the vision pipeline\n\n        Returns:\n            tuple[bool, MatLike | None]: An OpenCV Mat for pipeline visualization purposes. Can be ignored depending on the use case.\n        \"\"\"\n\n    def return_values(self) -&gt; Any:\n        \"\"\"Retrieves the calculations from the latest pipeline iteration\n\n        Returns:\n            Any: Pipeline calculations\n        \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.VisionPipeline.__init__","title":"<code>__init__(source)</code>","text":"<p>Pipeline initialization</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Callable[[], tuple[bool, MatLike]]</code> <p>Getter for the frame to process</p> required Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>def __init__(self, source: Callable[[], tuple[bool, MatLike]]) -&gt; None:\n    \"\"\"Pipeline initialization\n\n    Args:\n        source (Callable[[], tuple[bool, MatLike]]): Getter for the frame to process\n    \"\"\"\n    self.source = source\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.VisionPipeline.run","title":"<code>run(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Runs the vision pipeline</p> <p>Returns:</p> Type Description <code>tuple[bool, MatLike | None]</code> <p>tuple[bool, MatLike | None]: An OpenCV Mat for pipeline visualization purposes. Can be ignored depending on the use case.</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>@abstractmethod\ndef run(*args, **kwargs) -&gt; tuple[bool, MatLike | None]:\n    \"\"\"Runs the vision pipeline\n\n    Returns:\n        tuple[bool, MatLike | None]: An OpenCV Mat for pipeline visualization purposes. Can be ignored depending on the use case.\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.VisionPipeline.return_values","title":"<code>return_values()</code>","text":"<p>Retrieves the calculations from the latest pipeline iteration</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Pipeline calculations</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>def return_values(self) -&gt; Any:\n    \"\"\"Retrieves the calculations from the latest pipeline iteration\n\n    Returns:\n        Any: Pipeline calculations\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.EmptyPipeline","title":"<code>kevinbotlib.vision.EmptyPipeline</code>","text":"<p>               Bases: <code>VisionPipeline</code></p> <p>A dummy vision pipeline returning the original frame</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class EmptyPipeline(VisionPipeline):\n    \"\"\"\n    A dummy vision pipeline returning the original frame\n    \"\"\"\n\n    def run(self) -&gt; tuple[bool, MatLike]:\n        return self.source()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick","title":"<code>kevinbotlib.joystick</code>","text":""},{"location":"reference/#kevinbotlib.joystick.XboxControllerAxis","title":"<code>kevinbotlib.joystick.XboxControllerAxis</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Axis identifiers for Xbox controller.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class XboxControllerAxis(IntEnum):\n    \"\"\"Axis identifiers for Xbox controller.\"\"\"\n\n    LeftX = 0\n    LeftY = 1\n    RightX = 3\n    RightY = 4\n    LeftTrigger = 2\n    RightTrigger = 5\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.POVDirection","title":"<code>kevinbotlib.joystick.POVDirection</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>D-pad directions in degrees.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class POVDirection(IntEnum):\n    \"\"\"D-pad directions in degrees.\"\"\"\n\n    UP = 0\n    UP_RIGHT = 45\n    RIGHT = 90\n    DOWN_RIGHT = 135\n    DOWN = 180\n    DOWN_LEFT = 225\n    LEFT = 270\n    UP_LEFT = 315\n    NONE = -1\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalJoystickIdentifiers","title":"<code>kevinbotlib.joystick.LocalJoystickIdentifiers</code>","text":"<p>Static class to handle joystick identification queries.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class LocalJoystickIdentifiers:\n    \"\"\"Static class to handle joystick identification queries.\"\"\"\n\n    @staticmethod\n    def get_count() -&gt; int:\n        \"\"\"Returns the number of connected joysticks.\"\"\"\n        sdl2.SDL_JoystickUpdate()\n        return sdl2.SDL_NumJoysticks()\n\n    @staticmethod\n    def get_names() -&gt; dict[int, str]:\n        \"\"\"Returns a dictionary of joystick indices and their corresponding names.\"\"\"\n        sdl2.SDL_JoystickUpdate()\n        num_joysticks = sdl2.SDL_NumJoysticks()\n        joystick_names = {}\n        for index in range(num_joysticks):\n            joystick_names[index] = sdl2.SDL_JoystickNameForIndex(index).decode(\"utf-8\")\n        return joystick_names\n\n    @staticmethod\n    def get_guids() -&gt; dict[int, bytes]:\n        \"\"\"Returns a dictionary of joystick indices and their corresponding GUIDs.\"\"\"\n        sdl2.SDL_JoystickUpdate()\n        num_joysticks = sdl2.SDL_NumJoysticks()\n        joystick_guids = {}\n        for index in range(num_joysticks):\n            joystick_guids[index] = bytes(sdl2.SDL_JoystickGetGUID(sdl2.SDL_JoystickOpen(index)).data)\n        return joystick_guids\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalJoystickIdentifiers.get_count","title":"<code>get_count()</code>  <code>staticmethod</code>","text":"<p>Returns the number of connected joysticks.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>@staticmethod\ndef get_count() -&gt; int:\n    \"\"\"Returns the number of connected joysticks.\"\"\"\n    sdl2.SDL_JoystickUpdate()\n    return sdl2.SDL_NumJoysticks()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalJoystickIdentifiers.get_names","title":"<code>get_names()</code>  <code>staticmethod</code>","text":"<p>Returns a dictionary of joystick indices and their corresponding names.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>@staticmethod\ndef get_names() -&gt; dict[int, str]:\n    \"\"\"Returns a dictionary of joystick indices and their corresponding names.\"\"\"\n    sdl2.SDL_JoystickUpdate()\n    num_joysticks = sdl2.SDL_NumJoysticks()\n    joystick_names = {}\n    for index in range(num_joysticks):\n        joystick_names[index] = sdl2.SDL_JoystickNameForIndex(index).decode(\"utf-8\")\n    return joystick_names\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalJoystickIdentifiers.get_guids","title":"<code>get_guids()</code>  <code>staticmethod</code>","text":"<p>Returns a dictionary of joystick indices and their corresponding GUIDs.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>@staticmethod\ndef get_guids() -&gt; dict[int, bytes]:\n    \"\"\"Returns a dictionary of joystick indices and their corresponding GUIDs.\"\"\"\n    sdl2.SDL_JoystickUpdate()\n    num_joysticks = sdl2.SDL_NumJoysticks()\n    joystick_guids = {}\n    for index in range(num_joysticks):\n        joystick_guids[index] = bytes(sdl2.SDL_JoystickGetGUID(sdl2.SDL_JoystickOpen(index)).data)\n    return joystick_guids\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice","title":"<code>kevinbotlib.joystick.RawLocalJoystickDevice</code>","text":"<p>               Bases: <code>AbstractJoystickInterface</code></p> <p>Gamepad-agnostic polling and event-based joystick input with disconnect detection.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class RawLocalJoystickDevice(AbstractJoystickInterface):\n    \"\"\"Gamepad-agnostic polling and event-based joystick input with disconnect detection.\"\"\"\n\n    def __init__(self, index: int, polling_hz: int = 100):\n        self.index = index\n        self._sdl_joystick: sdl2.joystick.SDL_Joystick = sdl2.SDL_JoystickOpen(index)\n        self._logger = _Logger()\n\n        if not self._sdl_joystick:\n            msg = f\"No joystick of index {index} present\"\n            raise JoystickMissingException(msg)\n\n        self._logger.info(f\"Init joystick {index} of name: {sdl2.SDL_JoystickName(self._sdl_joystick).decode('utf-8')}\")\n        self._logger.info(\n            f\"Init joystick {index} of GUID: {''.join(f'{b:02x}' for b in sdl2.SDL_JoystickGetGUID(self._sdl_joystick).data)}\"\n        )\n\n        self.running = False\n        self.connected = False\n        self.polling_hz = polling_hz\n        self._button_states = {}\n        self._button_callbacks = {}\n        self._pov_state = POVDirection.NONE\n        self._pov_callbacks: list[Callable[[POVDirection], Any]] = []\n        self._axis_states = {}\n        self._axis_callbacks = {}\n\n        self.on_disconnect: Callable[[], Any] | None = None\n\n        num_axes = sdl2.SDL_JoystickNumAxes(self._sdl_joystick)\n        for i in range(num_axes):\n            self._axis_states[i] = 0.0\n\n    def is_connected(self) -&gt; bool:\n        return self.connected\n\n    def get_button_state(self, button_id: int) -&gt; bool:\n        \"\"\"Returns the state of a button (pressed: True, released: False).\"\"\"\n        return self._button_states.get(button_id, False)\n\n    def get_axis_value(self, axis_id: int, precision: int = 3) -&gt; float:\n        \"\"\"Returns the current value of the specified axis (-1.0 to 1.0).\"\"\"\n        return round(max(min(self._axis_states.get(axis_id, 0.0), 1), -1), precision)\n\n    def get_buttons(self) -&gt; list[int]:\n        \"\"\"Returns a list of currently pressed buttons.\"\"\"\n        buttons = [key for key, value in self._button_states.items() if value]\n        buttons.sort()\n        return buttons\n\n    def get_axes(self, precision: int = 3):\n        return [round(float(max(min(self._axis_states[axis_id], 1), -1)), precision) for axis_id in self._axis_states]\n\n    def get_pov_direction(self) -&gt; POVDirection:\n        \"\"\"Returns the current POV (D-pad) direction.\"\"\"\n        return self._pov_state\n\n    def register_button_callback(self, button_id: int, callback: Callable[[bool], Any]) -&gt; None:\n        \"\"\"Registers a callback function for button press/release events.\"\"\"\n        self._button_callbacks[button_id] = callback\n\n    def register_pov_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n        \"\"\"Registers a callback function for POV (D-pad) direction changes.\"\"\"\n        self._pov_callbacks.append(callback)\n\n    def _handle_event(self, event) -&gt; None:\n        \"\"\"Handles SDL events and triggers registered callbacks.\"\"\"\n        if event.type == sdl2.SDL_JOYBUTTONDOWN:\n            button = event.jbutton.button\n            self._button_states[button] = True\n            if button in self._button_callbacks:\n                self._button_callbacks[button](True)\n\n        elif event.type == sdl2.SDL_JOYBUTTONUP:\n            button = event.jbutton.button\n            self._button_states[button] = False\n            if button in self._button_callbacks:\n                self._button_callbacks[button](False)\n\n        elif event.type == sdl2.SDL_JOYHATMOTION:\n            # Convert SDL hat values to angles\n            hat_value = event.jhat.value\n            new_direction = self._convert_hat_to_direction(hat_value)\n\n            if new_direction != self._pov_state:\n                self._pov_state = new_direction\n                for callback in self._pov_callbacks:\n                    callback(new_direction)\n\n        elif event.type == sdl2.SDL_JOYAXISMOTION:\n            axis = event.jaxis.axis\n            # Convert SDL axis value (-32768 to 32767) to float (-1.0 to 1.0)\n            value = event.jaxis.value / 32767.0\n\n            # For triggers, convert range from [-1.0, 1.0] to [0.0, 1.0]\n            if axis in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n                value = (value + 1.0) / 2.0\n\n            # Update state and trigger callback if value changed significantly\n            self._axis_states[axis] = value\n            if axis in self._axis_callbacks:\n                self._axis_callbacks[axis](value)\n\n    @staticmethod\n    def _convert_hat_to_direction(hat_value: int) -&gt; POVDirection:\n        \"\"\"Converts SDL hat value to POVDirection enum.\"\"\"\n        hat_to_direction = {\n            0x00: POVDirection.NONE,  # centered\n            0x01: POVDirection.UP,  # up\n            0x02: POVDirection.RIGHT,  # right\n            0x04: POVDirection.DOWN,  # down\n            0x08: POVDirection.LEFT,  # left\n            0x03: POVDirection.UP_RIGHT,  # up + right\n            0x06: POVDirection.DOWN_RIGHT,  # down + right\n            0x0C: POVDirection.DOWN_LEFT,  # down + left\n            0x09: POVDirection.UP_LEFT,  # up + left\n        }\n        return hat_to_direction.get(hat_value, POVDirection.NONE)\n\n    def _event_loop(self):\n        \"\"\"Internal loop for processing SDL events synchronously.\"\"\"\n        while self.running:\n            if not sdl2.SDL_JoystickGetAttached(self._sdl_joystick):\n                self.connected = False\n                for key in self._axis_states:\n                    self._axis_states[key] = 0.0\n\n                self._button_states = {}\n                self._pov_state = POVDirection.NONE\n                self._handle_disconnect()\n                self._logger.debug(f\"Polling paused, controller {self.index} is disconnected\")\n            else:\n                self.connected = True\n\n            events = sdl2.ext.get_events()\n            for event in events:\n                if event.type == sdl2.SDL_QUIT:\n                    self.running = False\n                    break\n                self._handle_event(event)\n\n            time.sleep(1 / self.polling_hz)\n\n    def _check_connection(self):\n        \"\"\"Thread to monitor joystick connection state.\"\"\"\n        while self.running:\n            if not sdl2.SDL_JoystickGetAttached(self._sdl_joystick):\n                self._handle_disconnect()\n                return\n            time.sleep(0.5)\n\n    def _handle_disconnect(self):\n        \"\"\"Handles joystick disconnection.\"\"\"\n        self._logger.warning(f\"Joystick {self.index} disconnected.\")\n        if self.on_disconnect:\n            self.on_disconnect()\n        self._attempt_reconnect()\n\n    def _attempt_reconnect(self):\n        \"\"\"Attempts to reconnect the joystick.\"\"\"\n        self._logger.info(\"Attempting to reconnect...\")\n\n        self.connected = False\n        time.sleep(1)\n\n        num_joysticks = sdl2.SDL_NumJoysticks()\n        if self.index &lt; num_joysticks:\n            self._sdl_joystick = sdl2.SDL_JoystickOpen(self.index)\n            if self._sdl_joystick and sdl2.SDL_JoystickGetAttached(self._sdl_joystick):\n                self._logger.info(f\"Reconnected joystick {self.index} successfully\")\n                return\n\n        time.sleep(1)\n\n    def start_polling(self):\n        \"\"\"Starts the polling loop in a separate thread.\"\"\"\n        if not self.running:\n            self.running = True\n            threading.Thread(\n                target=self._event_loop, daemon=True, name=f\"KevinbotLib.Joystick.EvLoop.{self.index}\"\n            ).start()\n            threading.Thread(\n                target=self._check_connection, daemon=True, name=f\"KevinbotLib.Joystick.ConnCheck.{self.index}\"\n            ).start()\n\n    def stop(self):\n        \"\"\"Stops event handling and releases resources.\"\"\"\n        self.running = False\n        sdl2.SDL_JoystickClose(self._sdl_joystick)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.get_button_state","title":"<code>get_button_state(button_id)</code>","text":"<p>Returns the state of a button (pressed: True, released: False).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_button_state(self, button_id: int) -&gt; bool:\n    \"\"\"Returns the state of a button (pressed: True, released: False).\"\"\"\n    return self._button_states.get(button_id, False)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.get_axis_value","title":"<code>get_axis_value(axis_id, precision=3)</code>","text":"<p>Returns the current value of the specified axis (-1.0 to 1.0).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_axis_value(self, axis_id: int, precision: int = 3) -&gt; float:\n    \"\"\"Returns the current value of the specified axis (-1.0 to 1.0).\"\"\"\n    return round(max(min(self._axis_states.get(axis_id, 0.0), 1), -1), precision)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.get_buttons","title":"<code>get_buttons()</code>","text":"<p>Returns a list of currently pressed buttons.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_buttons(self) -&gt; list[int]:\n    \"\"\"Returns a list of currently pressed buttons.\"\"\"\n    buttons = [key for key, value in self._button_states.items() if value]\n    buttons.sort()\n    return buttons\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.get_pov_direction","title":"<code>get_pov_direction()</code>","text":"<p>Returns the current POV (D-pad) direction.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_pov_direction(self) -&gt; POVDirection:\n    \"\"\"Returns the current POV (D-pad) direction.\"\"\"\n    return self._pov_state\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.register_button_callback","title":"<code>register_button_callback(button_id, callback)</code>","text":"<p>Registers a callback function for button press/release events.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_button_callback(self, button_id: int, callback: Callable[[bool], Any]) -&gt; None:\n    \"\"\"Registers a callback function for button press/release events.\"\"\"\n    self._button_callbacks[button_id] = callback\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.register_pov_callback","title":"<code>register_pov_callback(callback)</code>","text":"<p>Registers a callback function for POV (D-pad) direction changes.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_pov_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n    \"\"\"Registers a callback function for POV (D-pad) direction changes.\"\"\"\n    self._pov_callbacks.append(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.start_polling","title":"<code>start_polling()</code>","text":"<p>Starts the polling loop in a separate thread.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def start_polling(self):\n    \"\"\"Starts the polling loop in a separate thread.\"\"\"\n    if not self.running:\n        self.running = True\n        threading.Thread(\n            target=self._event_loop, daemon=True, name=f\"KevinbotLib.Joystick.EvLoop.{self.index}\"\n        ).start()\n        threading.Thread(\n            target=self._check_connection, daemon=True, name=f\"KevinbotLib.Joystick.ConnCheck.{self.index}\"\n        ).start()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.stop","title":"<code>stop()</code>","text":"<p>Stops event handling and releases resources.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def stop(self):\n    \"\"\"Stops event handling and releases resources.\"\"\"\n    self.running = False\n    sdl2.SDL_JoystickClose(self._sdl_joystick)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController","title":"<code>kevinbotlib.joystick.LocalXboxController</code>","text":"<p>               Bases: <code>RawLocalJoystickDevice</code></p> <p>Xbox-specific controller with button name mappings.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class LocalXboxController(RawLocalJoystickDevice):\n    \"\"\"Xbox-specific controller with button name mappings.\"\"\"\n\n    def get_button_state(self, button: XboxControllerButtons) -&gt; bool:\n        \"\"\"Returns the state of a button using its friendly name.\"\"\"\n        return super().get_button_state(button)\n\n    def get_buttons(self) -&gt; list[XboxControllerButtons]:\n        return [XboxControllerButtons(x) for x in super().get_buttons()]\n\n    def register_button_callback(self, button: XboxControllerButtons, callback: Callable[[bool], Any]) -&gt; None:\n        \"\"\"Registers a callback using the friendly button name.\"\"\"\n        super().register_button_callback(button, callback)\n\n    def get_dpad_direction(self) -&gt; POVDirection:\n        \"\"\"Returns the current D-pad direction using Xbox terminology.\"\"\"\n        return self.get_pov_direction()\n\n    def get_trigger_value(self, trigger: XboxControllerAxis, precision: int = 3) -&gt; float:\n        \"\"\"Returns the current value of the specified trigger (0.0 to 1.0).\"\"\"\n        if trigger not in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n            msg = \"Invalid trigger specified\"\n            raise ValueError(msg)\n        return max(self.get_axis_value(trigger, precision), 0)\n\n    def get_axis_value(self, axis_id: int, precision: int = 3) -&gt; float:\n        return super().get_axis_value(axis_id, precision)\n\n    def get_triggers(self, precision: int = 3):\n        return [\n            self.get_trigger_value(XboxControllerAxis.LeftTrigger, precision),\n            self.get_trigger_value(XboxControllerAxis.RightTrigger, precision),\n        ]\n\n    def get_left_stick(self, precision: int = 3):\n        return [\n            self.get_axis_value(XboxControllerAxis.LeftX, precision),\n            self.get_axis_value(XboxControllerAxis.LeftY, precision),\n        ]\n\n    def get_right_stick(self, precision: int = 3):\n        return [\n            self.get_axis_value(XboxControllerAxis.RightX, precision),\n            self.get_axis_value(XboxControllerAxis.RightY, precision),\n        ]\n\n    def register_dpad_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n        \"\"\"Registers a callback for D-pad direction changes using Xbox terminology.\"\"\"\n        self.register_pov_callback(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.get_button_state","title":"<code>get_button_state(button)</code>","text":"<p>Returns the state of a button using its friendly name.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_button_state(self, button: XboxControllerButtons) -&gt; bool:\n    \"\"\"Returns the state of a button using its friendly name.\"\"\"\n    return super().get_button_state(button)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.register_button_callback","title":"<code>register_button_callback(button, callback)</code>","text":"<p>Registers a callback using the friendly button name.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_button_callback(self, button: XboxControllerButtons, callback: Callable[[bool], Any]) -&gt; None:\n    \"\"\"Registers a callback using the friendly button name.\"\"\"\n    super().register_button_callback(button, callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.get_dpad_direction","title":"<code>get_dpad_direction()</code>","text":"<p>Returns the current D-pad direction using Xbox terminology.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_dpad_direction(self) -&gt; POVDirection:\n    \"\"\"Returns the current D-pad direction using Xbox terminology.\"\"\"\n    return self.get_pov_direction()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.get_trigger_value","title":"<code>get_trigger_value(trigger, precision=3)</code>","text":"<p>Returns the current value of the specified trigger (0.0 to 1.0).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_trigger_value(self, trigger: XboxControllerAxis, precision: int = 3) -&gt; float:\n    \"\"\"Returns the current value of the specified trigger (0.0 to 1.0).\"\"\"\n    if trigger not in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n        msg = \"Invalid trigger specified\"\n        raise ValueError(msg)\n    return max(self.get_axis_value(trigger, precision), 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.register_dpad_callback","title":"<code>register_dpad_callback(callback)</code>","text":"<p>Registers a callback for D-pad direction changes using Xbox terminology.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_dpad_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n    \"\"\"Registers a callback for D-pad direction changes using Xbox terminology.\"\"\"\n    self.register_pov_callback(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice","title":"<code>kevinbotlib.joystick.RemoteRawJoystickDevice</code>","text":"<p>               Bases: <code>AbstractJoystickInterface</code></p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class RemoteRawJoystickDevice(AbstractJoystickInterface):\n    def __init__(self, client: KevinbotCommClient, key: str, callback_polling_hz: int = 100) -&gt; None:\n        super().__init__()\n        self._client: KevinbotCommClient = client\n        self._client_key: str = key.rstrip(\"/\")\n        self.polling_hz = callback_polling_hz\n\n        # Callback storage\n        self._button_callbacks = {}\n        self._pov_callbacks: list[Callable[[POVDirection], Any]] = []\n        self._axis_callbacks = {}\n\n        # State tracking for callback triggering\n        self._last_button_states = {}\n        self._last_pov_state = POVDirection.NONE\n        self._last_axis_states = {}\n\n        self.connected = False\n        self.running = False\n\n        # Start polling thread\n        self.start_polling()\n\n    @property\n    def client(self) -&gt; KevinbotCommClient:\n        return self._client\n\n    @property\n    def key(self) -&gt; str:\n        return self._client_key\n\n    def is_connected(self) -&gt; bool:\n        sendable = self.client.get(f\"{self._client_key}/connected\", BooleanSendable)\n        if not sendable:\n            return False\n        return sendable.value\n\n    def get_button_state(self, button_id: int | Enum | IntEnum) -&gt; bool:\n        sendable = self.client.get(f\"{self._client_key}/buttons\", AnyListSendable)\n        if not sendable:\n            return False\n        return button_id in sendable.value\n\n    def get_axis_value(self, axis_id: int, precision: int = 3) -&gt; float:\n        sendable = self.client.get(f\"{self._client_key}/axes\", AnyListSendable)\n        if not sendable:\n            return 0.0\n        return round(sendable.value[axis_id], precision) if axis_id &lt; len(sendable.value) else 0.0\n\n    def get_buttons(self) -&gt; list[int | Enum | IntEnum]:\n        sendable = self.client.get(f\"{self._client_key}/buttons\", AnyListSendable)\n        if not sendable:\n            return []\n        return sendable.value\n\n    def get_axes(self) -&gt; list[float]:\n        sendable = self.client.get(f\"{self._client_key}/axes\", AnyListSendable)\n        if not sendable:\n            return []\n        return sendable.value\n\n    def get_pov_direction(self) -&gt; POVDirection:\n        sendable = self.client.get(f\"{self._client_key}/pov\", IntegerSendable)\n        if not sendable:\n            return POVDirection.NONE\n        return POVDirection(sendable.value)\n\n    def register_button_callback(self, button_id: int | Enum | IntEnum, callback: Callable[[bool], Any]) -&gt; None:\n        \"\"\"Registers a callback function for button press/release events.\"\"\"\n        self._button_callbacks[button_id] = callback\n\n    def register_pov_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n        \"\"\"Registers a callback function for POV (D-pad) direction changes.\"\"\"\n        self._pov_callbacks.append(callback)\n\n    def _poll_loop(self):\n        \"\"\"Polling loop that checks for state changes and triggers callbacks.\"\"\"\n        while self.running:\n            # Check connection status\n            conn_sendable = self.client.get(f\"{self._client_key}/connected\", BooleanSendable)\n            self.connected = conn_sendable.value if conn_sendable else False\n\n            if self.connected:\n                # Check buttons\n                buttons = self.get_buttons()\n                current_button_states = {btn: True for btn in buttons}\n\n                # Check for button state changes\n                for button in set(self._last_button_states.keys()) | set(current_button_states.keys()):\n                    old_state = self._last_button_states.get(button, False)\n                    new_state = current_button_states.get(button, False)\n\n                    if old_state != new_state and button in self._button_callbacks:\n                        self._button_callbacks[button](new_state)\n\n                self._last_button_states = current_button_states\n\n                # Check POV\n                current_pov = self.get_pov_direction()\n                if current_pov != self._last_pov_state:\n                    for callback in self._pov_callbacks:\n                        callback(current_pov)\n                self._last_pov_state = current_pov\n\n            time.sleep(1 / self.polling_hz)\n\n    def start_polling(self):\n        \"\"\"Starts the polling loop in a separate thread.\"\"\"\n        if not self.running:\n            self.running = True\n            threading.Thread(target=self._poll_loop, daemon=True, name=\"KevinbotLib.Joystick.Remote.Poll\").start()\n\n    def stop(self):\n        \"\"\"Stops the polling thread.\"\"\"\n        self.running = False\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice.register_button_callback","title":"<code>register_button_callback(button_id, callback)</code>","text":"<p>Registers a callback function for button press/release events.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_button_callback(self, button_id: int | Enum | IntEnum, callback: Callable[[bool], Any]) -&gt; None:\n    \"\"\"Registers a callback function for button press/release events.\"\"\"\n    self._button_callbacks[button_id] = callback\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice.register_pov_callback","title":"<code>register_pov_callback(callback)</code>","text":"<p>Registers a callback function for POV (D-pad) direction changes.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_pov_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n    \"\"\"Registers a callback function for POV (D-pad) direction changes.\"\"\"\n    self._pov_callbacks.append(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice.start_polling","title":"<code>start_polling()</code>","text":"<p>Starts the polling loop in a separate thread.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def start_polling(self):\n    \"\"\"Starts the polling loop in a separate thread.\"\"\"\n    if not self.running:\n        self.running = True\n        threading.Thread(target=self._poll_loop, daemon=True, name=\"KevinbotLib.Joystick.Remote.Poll\").start()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice.stop","title":"<code>stop()</code>","text":"<p>Stops the polling thread.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def stop(self):\n    \"\"\"Stops the polling thread.\"\"\"\n    self.running = False\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController","title":"<code>kevinbotlib.joystick.RemoteXboxController</code>","text":"<p>               Bases: <code>RemoteRawJoystickDevice</code></p> <p>Xbox-specific remote controller with button name mappings.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class RemoteXboxController(RemoteRawJoystickDevice):\n    \"\"\"Xbox-specific remote controller with button name mappings.\"\"\"\n\n    def __init__(self, client: KevinbotCommClient, key: str, callback_polling_hz: int = 100) -&gt; None:\n        super().__init__(client, key, callback_polling_hz)\n\n    def get_button_state(self, button: XboxControllerButtons) -&gt; bool:\n        \"\"\"Returns the state of a button using its friendly Xbox name.\"\"\"\n        return super().get_button_state(button)\n\n    def get_buttons(self) -&gt; list[XboxControllerButtons]:\n        \"\"\"Returns a list of currently pressed buttons using Xbox button enums.\"\"\"\n        return [XboxControllerButtons(x) for x in super().get_buttons()]\n\n    def get_axes(self, precision: int = 3) -&gt; list[float]:\n        \"\"\"Returns a list of axis values with Xbox-specific ordering.\"\"\"\n        axes = super().get_axes()\n        if not axes:\n            return [0.0] * len(XboxControllerAxis)  # Return default zeroed axes if no data\n        return [round(x, precision) for x in axes]  # Convert to float and apply precision\n\n    def register_button_callback(self, button: XboxControllerButtons, callback: Callable[[bool], Any]) -&gt; None:\n        \"\"\"Registers a callback using the friendly Xbox button name.\"\"\"\n        super().register_button_callback(button, callback)\n\n    def register_dpad_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n        \"\"\"Registers a callback for D-pad direction changes using Xbox terminology.\"\"\"\n        super().register_pov_callback(callback)\n\n    def get_dpad_direction(self) -&gt; POVDirection:\n        \"\"\"Returns the current D-pad direction using Xbox terminology.\"\"\"\n        return super().get_pov_direction()\n\n    def get_trigger_value(self, trigger: XboxControllerAxis, precision: int = 3) -&gt; float:\n        \"\"\"Returns the current value of the specified trigger (0.0 to 1.0).\"\"\"\n        if trigger not in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n            msg = \"Invalid trigger specified\"\n            raise ValueError(msg)\n        value = super().get_axis_value(trigger, precision)\n        return max(value, 0.0)  # Ensure triggers are 0.0 to 1.0\n\n    def get_triggers(self, precision: int = 3) -&gt; list[float]:\n        \"\"\"Returns the current values of both triggers.\"\"\"\n        return [\n            self.get_trigger_value(XboxControllerAxis.LeftTrigger, precision),\n            self.get_trigger_value(XboxControllerAxis.RightTrigger, precision),\n        ]\n\n    def get_left_stick(self, precision: int = 3) -&gt; list[float]:\n        \"\"\"Returns the current values of the left stick (x, y).\"\"\"\n        return [\n            super().get_axis_value(XboxControllerAxis.LeftX, precision),\n            super().get_axis_value(XboxControllerAxis.LeftY, precision),\n        ]\n\n    def get_right_stick(self, precision: int = 3) -&gt; list[float]:\n        \"\"\"Returns the current values of the right stick (x, y).\"\"\"\n        return [\n            super().get_axis_value(XboxControllerAxis.RightX, precision),\n            super().get_axis_value(XboxControllerAxis.RightY, precision),\n        ]\n\n    def _poll_loop(self):\n        \"\"\"Xbox-specific polling loop that checks for state changes and triggers callbacks.\"\"\"\n        while self.running:\n            # Check connection status\n            conn_sendable = self.client.get(f\"{self._client_key}/connected\", BooleanSendable)\n            self.connected = conn_sendable.value if conn_sendable else False\n\n            if self.connected:\n                # Check buttons\n                buttons = self.get_buttons()\n                current_button_states = {btn: True for btn in buttons}\n\n                # Check for button state changes\n                for button in set(self._last_button_states.keys()) | set(current_button_states.keys()):\n                    old_state = self._last_button_states.get(button, False)\n                    new_state = current_button_states.get(button, False)\n\n                    if old_state != new_state and button in self._button_callbacks:\n                        self._button_callbacks[button](new_state)\n\n                self._last_button_states = current_button_states\n\n                # Check POV/D-pad\n                current_pov = self.get_dpad_direction()\n                if current_pov != self._last_pov_state:\n                    for callback in self._pov_callbacks:\n                        callback(current_pov)\n                self._last_pov_state = current_pov\n\n                # Check axes (only update states here, specific methods handle formatting)\n                current_axes = super().get_axes()\n                for axis_id in range(len(current_axes)):\n                    self._last_axis_states[axis_id] = current_axes[axis_id]\n\n            time.sleep(1 / self.polling_hz)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_button_state","title":"<code>get_button_state(button)</code>","text":"<p>Returns the state of a button using its friendly Xbox name.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_button_state(self, button: XboxControllerButtons) -&gt; bool:\n    \"\"\"Returns the state of a button using its friendly Xbox name.\"\"\"\n    return super().get_button_state(button)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_buttons","title":"<code>get_buttons()</code>","text":"<p>Returns a list of currently pressed buttons using Xbox button enums.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_buttons(self) -&gt; list[XboxControllerButtons]:\n    \"\"\"Returns a list of currently pressed buttons using Xbox button enums.\"\"\"\n    return [XboxControllerButtons(x) for x in super().get_buttons()]\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_axes","title":"<code>get_axes(precision=3)</code>","text":"<p>Returns a list of axis values with Xbox-specific ordering.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_axes(self, precision: int = 3) -&gt; list[float]:\n    \"\"\"Returns a list of axis values with Xbox-specific ordering.\"\"\"\n    axes = super().get_axes()\n    if not axes:\n        return [0.0] * len(XboxControllerAxis)  # Return default zeroed axes if no data\n    return [round(x, precision) for x in axes]  # Convert to float and apply precision\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.register_button_callback","title":"<code>register_button_callback(button, callback)</code>","text":"<p>Registers a callback using the friendly Xbox button name.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_button_callback(self, button: XboxControllerButtons, callback: Callable[[bool], Any]) -&gt; None:\n    \"\"\"Registers a callback using the friendly Xbox button name.\"\"\"\n    super().register_button_callback(button, callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.register_dpad_callback","title":"<code>register_dpad_callback(callback)</code>","text":"<p>Registers a callback for D-pad direction changes using Xbox terminology.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_dpad_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n    \"\"\"Registers a callback for D-pad direction changes using Xbox terminology.\"\"\"\n    super().register_pov_callback(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_dpad_direction","title":"<code>get_dpad_direction()</code>","text":"<p>Returns the current D-pad direction using Xbox terminology.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_dpad_direction(self) -&gt; POVDirection:\n    \"\"\"Returns the current D-pad direction using Xbox terminology.\"\"\"\n    return super().get_pov_direction()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_trigger_value","title":"<code>get_trigger_value(trigger, precision=3)</code>","text":"<p>Returns the current value of the specified trigger (0.0 to 1.0).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_trigger_value(self, trigger: XboxControllerAxis, precision: int = 3) -&gt; float:\n    \"\"\"Returns the current value of the specified trigger (0.0 to 1.0).\"\"\"\n    if trigger not in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n        msg = \"Invalid trigger specified\"\n        raise ValueError(msg)\n    value = super().get_axis_value(trigger, precision)\n    return max(value, 0.0)  # Ensure triggers are 0.0 to 1.0\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_triggers","title":"<code>get_triggers(precision=3)</code>","text":"<p>Returns the current values of both triggers.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_triggers(self, precision: int = 3) -&gt; list[float]:\n    \"\"\"Returns the current values of both triggers.\"\"\"\n    return [\n        self.get_trigger_value(XboxControllerAxis.LeftTrigger, precision),\n        self.get_trigger_value(XboxControllerAxis.RightTrigger, precision),\n    ]\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_left_stick","title":"<code>get_left_stick(precision=3)</code>","text":"<p>Returns the current values of the left stick (x, y).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_left_stick(self, precision: int = 3) -&gt; list[float]:\n    \"\"\"Returns the current values of the left stick (x, y).\"\"\"\n    return [\n        super().get_axis_value(XboxControllerAxis.LeftX, precision),\n        super().get_axis_value(XboxControllerAxis.LeftY, precision),\n    ]\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_right_stick","title":"<code>get_right_stick(precision=3)</code>","text":"<p>Returns the current values of the right stick (x, y).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_right_stick(self, precision: int = 3) -&gt; list[float]:\n    \"\"\"Returns the current values of the right stick (x, y).\"\"\"\n    return [\n        super().get_axis_value(XboxControllerAxis.RightX, precision),\n        super().get_axis_value(XboxControllerAxis.RightY, precision),\n    ]\n</code></pre>"},{"location":"reference/#kevinbotlib.logger","title":"<code>kevinbotlib.logger</code>","text":""},{"location":"reference/#kevinbotlib.logger.LoggerDirectories","title":"<code>kevinbotlib.logger.LoggerDirectories</code>","text":"Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>class LoggerDirectories:\n    @staticmethod\n    def get_logger_directory(*, ensure_exists=True) -&gt; str:\n        \"\"\"Returns the log directory path and ensures its existence if needed.\"\"\"\n        log_dir = platformdirs.user_data_dir(\"kevinbotlib/logging\", ensure_exists=ensure_exists)\n        os.makedirs(log_dir, exist_ok=True)\n        return log_dir\n\n    @staticmethod\n    def cleanup_logs(directory: str, max_size_mb: int = 500):\n        \"\"\"Deletes oldest log files if the total log directory exceeds max_size_mb.\"\"\"\n        log_files = sorted(glob.glob(os.path.join(directory, \"*.log\")), key=os.path.getctime)\n\n        while log_files and LoggerDirectories.get_directory_size(directory) &gt; max_size_mb:\n            os.remove(log_files.pop(0))  # Delete oldest file\n\n    @staticmethod\n    def get_directory_size(directory: str) -&gt; float:\n        \"\"\"Returns the size of the directory in MB.\"\"\"\n        return sum(os.path.getsize(f) for f in glob.glob(os.path.join(directory, \"*.log\"))) / (1024 * 1024)\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.LoggerDirectories.get_logger_directory","title":"<code>get_logger_directory(*, ensure_exists=True)</code>  <code>staticmethod</code>","text":"<p>Returns the log directory path and ensures its existence if needed.</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>@staticmethod\ndef get_logger_directory(*, ensure_exists=True) -&gt; str:\n    \"\"\"Returns the log directory path and ensures its existence if needed.\"\"\"\n    log_dir = platformdirs.user_data_dir(\"kevinbotlib/logging\", ensure_exists=ensure_exists)\n    os.makedirs(log_dir, exist_ok=True)\n    return log_dir\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.LoggerDirectories.cleanup_logs","title":"<code>cleanup_logs(directory, max_size_mb=500)</code>  <code>staticmethod</code>","text":"<p>Deletes oldest log files if the total log directory exceeds max_size_mb.</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>@staticmethod\ndef cleanup_logs(directory: str, max_size_mb: int = 500):\n    \"\"\"Deletes oldest log files if the total log directory exceeds max_size_mb.\"\"\"\n    log_files = sorted(glob.glob(os.path.join(directory, \"*.log\")), key=os.path.getctime)\n\n    while log_files and LoggerDirectories.get_directory_size(directory) &gt; max_size_mb:\n        os.remove(log_files.pop(0))  # Delete oldest file\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.LoggerDirectories.get_directory_size","title":"<code>get_directory_size(directory)</code>  <code>staticmethod</code>","text":"<p>Returns the size of the directory in MB.</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>@staticmethod\ndef get_directory_size(directory: str) -&gt; float:\n    \"\"\"Returns the size of the directory in MB.\"\"\"\n    return sum(os.path.getsize(f) for f in glob.glob(os.path.join(directory, \"*.log\"))) / (1024 * 1024)\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.Level","title":"<code>kevinbotlib.logger.Level</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Logging levels</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>class Level(Enum):\n    \"\"\"Logging levels\"\"\"\n\n    TRACE = _internal_logger.level(\"TRACE\")\n    \"Trace level logging - used for more detailed info than DEBUG - level no. 5\"\n\n    DEBUG = _internal_logger.level(\"DEBUG\")\n    \"Debug level logging - used for debugging info - level no. 10\"\n\n    INFO = _internal_logger.level(\"INFO\")\n    \"Debug level logging - used for regular info - level no. 20\"\n\n    WARNING = _internal_logger.level(\"WARNING\")\n    \"Warnng level logging - used for warnings and recommended fixes - level no. 30\"\n\n    ERROR = _internal_logger.level(\"ERROR\")\n    \"Error level logging - used for non-critical and recoverable errors - level no. 40\"\n\n    SECURITY = _internal_logger.level(\"SECURITY\", 45, \"&lt;bg 202&gt;&lt;bold&gt;\")\n    \"Security level logging - used for non-application-breaking secutiry issues/threats - level no. 45\"\n\n    CRITICAL = _internal_logger.level(\"CRITICAL\")\n    \"Error level logging - used for critical and non-recoverable errors - level no. 50\"\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.Level.TRACE","title":"<code>TRACE = _internal_logger.level('TRACE')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Trace level logging - used for more detailed info than DEBUG - level no. 5</p>"},{"location":"reference/#kevinbotlib.logger.Level.DEBUG","title":"<code>DEBUG = _internal_logger.level('DEBUG')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Debug level logging - used for debugging info - level no. 10</p>"},{"location":"reference/#kevinbotlib.logger.Level.INFO","title":"<code>INFO = _internal_logger.level('INFO')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Debug level logging - used for regular info - level no. 20</p>"},{"location":"reference/#kevinbotlib.logger.Level.WARNING","title":"<code>WARNING = _internal_logger.level('WARNING')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Warnng level logging - used for warnings and recommended fixes - level no. 30</p>"},{"location":"reference/#kevinbotlib.logger.Level.ERROR","title":"<code>ERROR = _internal_logger.level('ERROR')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error level logging - used for non-critical and recoverable errors - level no. 40</p>"},{"location":"reference/#kevinbotlib.logger.Level.SECURITY","title":"<code>SECURITY = _internal_logger.level('SECURITY', 45, '&lt;bg 202&gt;&lt;bold&gt;')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Security level logging - used for non-application-breaking secutiry issues/threats - level no. 45</p>"},{"location":"reference/#kevinbotlib.logger.Level.CRITICAL","title":"<code>CRITICAL = _internal_logger.level('CRITICAL')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error level logging - used for critical and non-recoverable errors - level no. 50</p>"},{"location":"reference/#kevinbotlib.logger.Logger","title":"<code>kevinbotlib.logger.Logger</code>","text":"Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>class Logger:\n    is_configured = False\n\n    def __init__(self) -&gt; None:\n        self._internal_logger = _internal_logger\n\n    @property\n    def loguru_logger(self):\n        return self._internal_logger\n\n    def configure(self, config: LoggerConfiguration):\n        Logger.is_configured = True\n        \"\"\"Configures file-based logging with rotation and cleanup.\"\"\"\n        self._internal_logger.remove()\n        self._internal_logger.add(sys.stderr, level=config.level.value.no)\n\n        if config.file_logger:\n            timestamp = datetime.now(tz=timezone.utc).strftime(\"%Y-%m-%d_%H-%M-%S-%f\")[:-3]  # Trim to ms\n            log_file = os.path.join(config.file_logger.directory, f\"{timestamp}.log\")\n\n            self._internal_logger.add(\n                log_file,\n                rotation=config.file_logger.rotation_size,\n                enqueue=True,\n                serialize=True,\n                level=config.file_logger.level.value.no if config.file_logger.level else config.level.value.no,\n            )\n            return log_file\n        return None\n\n    def log(self, level: Level, message: str | BaseException, opts: LoggerWriteOpts | None = None):\n        \"\"\"Log a message with a specified level\"\"\"\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        opts = opts or LoggerWriteOpts()\n        self._internal_logger.opt(depth=opts.depth, colors=opts.colors, ansi=opts.ansi, exception=opts.exception).log(\n            level.name, message\n        )\n\n    def trace(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.TRACE.name, message)\n\n    def debug(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.DEBUG.name, message)\n\n    def info(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.INFO.name, message)\n\n    def warning(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.WARNING.name, message)\n\n    def warn(self, message: str):\n        self.warning(message)\n\n    def error(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.ERROR.name, message)\n\n    def security(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.SECURITY.name, message)\n\n    def critical(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.CRITICAL.name, message)\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.Logger.log","title":"<code>log(level, message, opts=None)</code>","text":"<p>Log a message with a specified level</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>def log(self, level: Level, message: str | BaseException, opts: LoggerWriteOpts | None = None):\n    \"\"\"Log a message with a specified level\"\"\"\n    if not Logger.is_configured:\n        raise LoggerNotConfiguredException\n\n    opts = opts or LoggerWriteOpts()\n    self._internal_logger.opt(depth=opts.depth, colors=opts.colors, ansi=opts.ansi, exception=opts.exception).log(\n        level.name, message\n    )\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.StreamRedirector","title":"<code>kevinbotlib.logger.StreamRedirector</code>","text":"<p>               Bases: <code>IO</code></p> <p>Redirect a stream to logging</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>class StreamRedirector(IO):\n    \"\"\"Redirect a stream to logging\"\"\"\n\n    def __init__(self, logger: Logger, level: Level = Level.INFO):\n        self._level = level\n        self._logger = logger\n\n    def write(self, buffer):\n        for line in buffer.rstrip().splitlines():\n            self._logger.log(self._level, line.rstrip(), LoggerWriteOpts(depth=2))\n\n    def flush(self):\n        pass\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver","title":"<code>kevinbotlib.fileserver</code>","text":""},{"location":"reference/#kevinbotlib.fileserver.FileServer","title":"<code>kevinbotlib.fileserver.FileServer</code>","text":"<p>Combined FTP and HTTP file server for KevinBot.</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>class FileServer:\n    \"\"\"Combined FTP and HTTP file server for KevinBot.\"\"\"\n\n    def __init__(\n        self, directory=\".\", ftp_port=2121, http_port=8000, host=\"127.0.0.1\", *, enable_ftp_server: bool = False\n    ):\n        self.directory = os.path.abspath(directory)\n        self.ftp_port = ftp_port\n        self._ftp_enabled = enable_ftp_server\n        self.http_port = http_port\n        self.host = host\n        self.ftp_thread = None\n        self.http_thread = None\n\n        self.logger = Logger()\n\n    def start_ftp_server(self):\n        \"\"\"Start the FTP server in a separate thread.\"\"\"\n\n        ftp_logger = logging.getLogger(\"pyftpdlib\")\n        ftp_logger.addHandler(logging.StreamHandler())\n        ftp_logger.setLevel(Level.DEBUG.value.no)\n\n        def logging_redirect(record):\n            log_level = next(key for key, val in logging.getLevelNamesMapping().items() if val == record.levelno)\n            logger_opt = self.logger.loguru_logger.opt(depth=6, exception=record.exc_info)\n            logger_opt.log(log_level, record.getMessage())\n\n            return False\n\n        ftp_logger.addFilter(logging_redirect)\n\n        authorizer = DummyAuthorizer()\n        authorizer.add_anonymous(self.directory, perm=\"elradfmwMT\")\n\n        handler = FTPHandler\n        handler.authorizer = authorizer\n        handler.banner = \"Welcome to KevinbotLib FTP Server\"\n\n        self.ftpserver = FTPServer((self.host, self.ftp_port), handler)\n\n        self.logger.info(f\"FTP server starting on {self.host}:{self.ftp_port}\")\n        self.logger.info(f\"Serving directory: {self.directory}\")\n\n        self.ftpserver.serve_forever()\n\n    def start_http_server(self):\n        \"\"\"Start the HTTP server.\"\"\"\n        os.chdir(self.directory)\n\n        def handler(*args):\n            return FileserverHTTPHandler(*args, directory=self.directory)\n\n        self.httpserver = HTTPServer((self.host, self.http_port), handler)\n\n        self.logger.info(f\"HTTP server starting on {self.host}:{self.http_port}\")\n        self.logger.info(f\"Serving directory: {self.directory}\")\n\n        self.httpserver.serve_forever()\n\n    def start(self, name: str = \"KevinbotLib.FileServer.Serve\"):\n        \"\"\"Start both FTP and HTTP servers.\"\"\"\n        if not os.path.exists(self.directory):\n            msg = f\"Directory does not exist: {self.directory}\"\n            raise ValueError(msg)\n\n        # Start FTP server in a thread\n        if self._ftp_enabled:\n            self.ftp_thread = threading.Thread(target=self.start_ftp_server)\n            self.ftp_thread.daemon = True\n            self.ftp_thread.start()\n            self.logger.security(\n                \"You have the FTP fileserver enabled. The ftp server is a security vunerability that can allow unauthorized access to system files. It is deprecated and will be removed in a future version\"\n            )\n\n        # Start HTTP server in a thread\n        self.http_thread = threading.Thread(target=self.start_http_server, name=name)\n        self.http_thread.daemon = True\n        self.http_thread.start()\n\n    def stop(self):\n        \"\"\"Stop the servers\"\"\"\n        self.ftpserver.close()\n        self.httpserver.shutdown()\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver.FileServer.start_ftp_server","title":"<code>start_ftp_server()</code>","text":"<p>Start the FTP server in a separate thread.</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>def start_ftp_server(self):\n    \"\"\"Start the FTP server in a separate thread.\"\"\"\n\n    ftp_logger = logging.getLogger(\"pyftpdlib\")\n    ftp_logger.addHandler(logging.StreamHandler())\n    ftp_logger.setLevel(Level.DEBUG.value.no)\n\n    def logging_redirect(record):\n        log_level = next(key for key, val in logging.getLevelNamesMapping().items() if val == record.levelno)\n        logger_opt = self.logger.loguru_logger.opt(depth=6, exception=record.exc_info)\n        logger_opt.log(log_level, record.getMessage())\n\n        return False\n\n    ftp_logger.addFilter(logging_redirect)\n\n    authorizer = DummyAuthorizer()\n    authorizer.add_anonymous(self.directory, perm=\"elradfmwMT\")\n\n    handler = FTPHandler\n    handler.authorizer = authorizer\n    handler.banner = \"Welcome to KevinbotLib FTP Server\"\n\n    self.ftpserver = FTPServer((self.host, self.ftp_port), handler)\n\n    self.logger.info(f\"FTP server starting on {self.host}:{self.ftp_port}\")\n    self.logger.info(f\"Serving directory: {self.directory}\")\n\n    self.ftpserver.serve_forever()\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver.FileServer.start_http_server","title":"<code>start_http_server()</code>","text":"<p>Start the HTTP server.</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>def start_http_server(self):\n    \"\"\"Start the HTTP server.\"\"\"\n    os.chdir(self.directory)\n\n    def handler(*args):\n        return FileserverHTTPHandler(*args, directory=self.directory)\n\n    self.httpserver = HTTPServer((self.host, self.http_port), handler)\n\n    self.logger.info(f\"HTTP server starting on {self.host}:{self.http_port}\")\n    self.logger.info(f\"Serving directory: {self.directory}\")\n\n    self.httpserver.serve_forever()\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver.FileServer.start","title":"<code>start(name='KevinbotLib.FileServer.Serve')</code>","text":"<p>Start both FTP and HTTP servers.</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>def start(self, name: str = \"KevinbotLib.FileServer.Serve\"):\n    \"\"\"Start both FTP and HTTP servers.\"\"\"\n    if not os.path.exists(self.directory):\n        msg = f\"Directory does not exist: {self.directory}\"\n        raise ValueError(msg)\n\n    # Start FTP server in a thread\n    if self._ftp_enabled:\n        self.ftp_thread = threading.Thread(target=self.start_ftp_server)\n        self.ftp_thread.daemon = True\n        self.ftp_thread.start()\n        self.logger.security(\n            \"You have the FTP fileserver enabled. The ftp server is a security vunerability that can allow unauthorized access to system files. It is deprecated and will be removed in a future version\"\n        )\n\n    # Start HTTP server in a thread\n    self.http_thread = threading.Thread(target=self.start_http_server, name=name)\n    self.http_thread.daemon = True\n    self.http_thread.start()\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver.FileServer.stop","title":"<code>stop()</code>","text":"<p>Stop the servers</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the servers\"\"\"\n    self.ftpserver.close()\n    self.httpserver.shutdown()\n</code></pre>"},{"location":"reference/#kevinbotlib.util","title":"<code>kevinbotlib.util</code>","text":""},{"location":"reference/#kevinbotlib.util.fullclassname","title":"<code>kevinbotlib.util.fullclassname(o)</code>","text":"<p>Get the full name of a class</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>object</code> <p>The class to retrieve the full name of</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the module and class</p> Source code in <code>src/kevinbotlib/util.py</code> <pre><code>def fullclassname(o: object) -&gt; str:\n    \"\"\"Get the full name of a class\n\n    Args:\n        o (object): The class to retrieve the full name of\n\n    Returns:\n        str: The name of the module and class\n    \"\"\"\n    module = o.__module__\n    if module == \"builtins\":\n        return o.__qualname__  # avoid outputs like 'builtins.str'\n    return module + \".\" + o.__qualname__\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions","title":"<code>kevinbotlib.exceptions</code>","text":""},{"location":"reference/#kevinbotlib.exceptions.HandshakeTimeoutException","title":"<code>kevinbotlib.exceptions.HandshakeTimeoutException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when the server-up wait times out</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class HandshakeTimeoutException(BaseException):\n    \"\"\"Exception that is produced when the server-up wait times out\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.ServerTimeoutException","title":"<code>kevinbotlib.exceptions.ServerTimeoutException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when the connection handshake times out</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class ServerTimeoutException(BaseException):\n    \"\"\"Exception that is produced when the connection handshake times out\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.JoystickMissingException","title":"<code>kevinbotlib.exceptions.JoystickMissingException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when a requested gamepad is missing</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class JoystickMissingException(BaseException):\n    \"\"\"Exception that is produced when a requested gamepad is missing\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.CommandSchedulerAlreadyExistsException","title":"<code>kevinbotlib.exceptions.CommandSchedulerAlreadyExistsException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when an attempt to create more than one command scheduler was made</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class CommandSchedulerAlreadyExistsException(BaseException):\n    \"\"\"Exception that is produced when an attempt to create more than one command scheduler was made\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.CommandSchedulerDoesNotExistException","title":"<code>kevinbotlib.exceptions.CommandSchedulerDoesNotExistException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when an attempt to get the current scheduler instance before creating a CommandScheduler</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class CommandSchedulerDoesNotExistException(BaseException):\n    \"\"\"Exception that is produced when an attempt to get the current scheduler instance before creating a CommandScheduler\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.LoggerNotConfiguredException","title":"<code>kevinbotlib.exceptions.LoggerNotConfiguredException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when trying to log to a non-configured logger</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class LoggerNotConfiguredException(BaseException):\n    \"\"\"Exception that is produced when trying to log to a non-configured logger\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.RobotStoppedException","title":"<code>kevinbotlib.exceptions.RobotStoppedException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Used when a non-urgent robot stop is triggered</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class RobotStoppedException(BaseException):\n    \"\"\"Used when a non-urgent robot stop is triggered\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.RobotEmergencyStoppedException","title":"<code>kevinbotlib.exceptions.RobotEmergencyStoppedException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Used when an urgent robot stop is triggered</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class RobotEmergencyStoppedException(BaseException):\n    \"\"\"Used when an urgent robot stop is triggered\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.RobotLockedException","title":"<code>kevinbotlib.exceptions.RobotLockedException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when another instance of a robot is running</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class RobotLockedException(BaseException):\n    \"\"\"Exception that is produced when another instance of a robot is running\"\"\"\n</code></pre>"},{"location":"robot/","title":"The Robot Class","text":"<p>Note</p> <p>The main robot class can only be used once within your project</p> <p>Danger</p> <p>The safety features included within KevinbotLib are not guaranteed to always function.</p> <p>It is always recommended to add a physical emergency stop system to your robot.</p> <p>The KevinbotLib main robot class is the starting point for your robotics project. It integrates many components of KevinbotLib together to make it easy to design your own robot.</p>"},{"location":"robot/#features","title":"Features","text":"<p>The KevinbotLib Robot class sets up some components of KevinbotLib to make designing a robot easier. The components are listed below.</p> <ul> <li>Communication Server</li> <li>Communication Client</li> <li>Logging Configuration</li> <li>Periodic log file rotations</li> <li>Logging to HTML Server</li> <li>Control Console communication and management</li> <li>Robot operational mode management</li> <li>Safety features</li> <li>Signal shutdown support (POSIX only)</li> </ul>"},{"location":"robot/#usage","title":"Usage","text":"<ul> <li>Extend the BaseRobot class and add your own code.</li> <li>Call <code>YourRobotClassName().run()</code> to start the robot's execution</li> <li>All of the components listed above will be started up automatically \ud83d\ude00</li> </ul> <p>Warning</p> <p>It is not recommended to override the <code>run</code> method, or any other private method marked with the <code>@final</code> decorator.</p>"},{"location":"robot/#shutdown-signals","title":"Shutdown signals","text":"<p>Note</p> <p>The shutdown signals are only supported on POSIX OSes (like Linux or macOS). They are not supported on Windows due to the lack of user signals in the NT kernel.</p>"},{"location":"robot/#sigusr1","title":"<code>SIGUSR1</code>","text":"<p>This will trigger a graceful system shutdown similar to <code>CTRL-C</code> on the console</p> <p>This should leave the robot in a state where it's ready for a code restart</p>"},{"location":"robot/#sigusr2","title":"<code>SIGUSR2</code>","text":"<p>This will trigger an emergency shutdown similar to hitting space on the Control Console</p> <p>Example</p> <p>If the robot code's PID (process id) is 1234, you can run the following command to gracefully shut it down:</p> <pre><code>kill -SIGUSR1 1234\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>All examples can be found on the project's repo - here</p>"},{"location":"examples/comm/","title":"Communication Examples","text":""},{"location":"examples/comm/#server","title":"Server","text":"examples/comm/server.py<pre><code>from kevinbotlib.comm import KevinbotCommServer\nfrom kevinbotlib.logger import Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration())\n\nserver = KevinbotCommServer()\nserver.serve()\n</code></pre>"},{"location":"examples/comm/#sender","title":"Sender","text":"examples/comm/sending.py<pre><code>import time\n\nfrom kevinbotlib.comm import IntegerSendable, KevinbotCommClient, StringSendable\nfrom kevinbotlib.logger import Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration())\n\nclient = KevinbotCommClient()\nclient.connect()\nclient.wait_until_connected()\n\ni = 0\ntry:\n    while True:\n        client.send(\"example/hierarchy/test\", IntegerSendable(value=i, timeout=None))\n        client.send(\"example/hierarchy/tes2\", StringSendable(value=f\"demo {i}\", timeout=None))\n        time.sleep(0.5)\n        i += 1\nexcept KeyboardInterrupt:\n    client.disconnect()\n</code></pre>"},{"location":"examples/comm/#receiver","title":"Receiver","text":"examples/comm/rx.py<pre><code>import time\n\nfrom kevinbotlib.comm import IntegerSendable, KevinbotCommClient, StringSendable\nfrom kevinbotlib.logger import Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration())\n\nclient = KevinbotCommClient(on_update=None)\nclient.connect()\nclient.wait_until_connected()\n\ntry:\n    while True:\n        print(client.get(\"example/hierarchy/test\", IntegerSendable))\n        print(client.get(\"example/hierarchy/test2\", StringSendable))\n        time.sleep(0.1)\nexcept KeyboardInterrupt:\n    client.disconnect()\n</code></pre>"},{"location":"examples/comm/#sendable-generator","title":"Sendable Generator","text":"examples/comm/sendable_generator.py<pre><code>import random\nimport time\n\nfrom kevinbotlib.comm import BaseSendable, IntegerSendable, KevinbotCommClient, SendableGenerator\nfrom kevinbotlib.logger import Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration())\n\nclient = KevinbotCommClient()\nclient.connect()\nclient.wait_until_connected()\n\n\nclass TestGenerator(SendableGenerator):\n    def generate_sendable(self) -&gt; BaseSendable:\n        return IntegerSendable(value=random.randint(0, 100))\n\n\ngenerator = TestGenerator()\n\ntry:\n    while True:\n        client.send(\"example/hierarchy/test\", generator)\n        time.sleep(0.5)\nexcept KeyboardInterrupt:\n    client.disconnect()\n</code></pre>"},{"location":"examples/fileserver/","title":"Fileserver Examples","text":""},{"location":"examples/fileserver/#basic-server","title":"Basic Server","text":"examples/fileserver/serve.py<pre><code>import time\n\nfrom kevinbotlib.fileserver import FileServer\n\nserver = FileServer(\n    ftp_port=2121,  # ftp\n    http_port=8000,  # http\n    directory=\"./\",  # serve directory\n)\n\ntry:\n    server.start()\n\n    while True:\n        time.sleep(1)\nexcept KeyboardInterrupt:\n    server.stop()\n</code></pre>"},{"location":"examples/joystick/","title":"Joystick Examples","text":""},{"location":"examples/joystick/#local-controller-query","title":"Local Controller Query","text":"examples/joystick/local_query.py<pre><code>import time\n\nfrom kevinbotlib.joystick import LocalJoystickIdentifiers\n\nwhile True:\n    count = LocalJoystickIdentifiers.get_count()\n    names = LocalJoystickIdentifiers.get_names()\n    guids = LocalJoystickIdentifiers.get_guids()\n    print(f\"{count} joysticks present\")\n    print(f\"Joystick Names: {names}\")\n    print(f\"Joystick GUIDs: {guids}\")\n    time.sleep(1)\n</code></pre>"},{"location":"examples/joystick/#local-raw-polling","title":"Local Raw Polling","text":"examples/joystick/local_polling.py<pre><code>import time\n\nfrom kevinbotlib.joystick import RawLocalJoystickDevice\nfrom kevinbotlib.logger import Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration())\n\ncontroller = RawLocalJoystickDevice(0)\ncontroller.start_polling()\n\ntry:\n    while True:\n        print(\"Buttons:\", controller.get_buttons())\n        print(\"POV:\", controller.get_pov_direction())\n        print(\"Axes:\", controller.get_axes())\n        time.sleep(0.1)\nexcept KeyboardInterrupt:\n    controller.stop()\n</code></pre>"},{"location":"examples/joystick/#local-xbox-polling","title":"Local Xbox Polling","text":"examples/joystick/local_xbox_polling.py<pre><code>import time\n\nfrom kevinbotlib.joystick import LocalXboxController\nfrom kevinbotlib.logger import Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration())\n\ncontroller = LocalXboxController(0)\ncontroller.start_polling()\n\ntry:\n    while True:\n        print(\"Held buttons:\", [btn.name for btn in controller.get_buttons()])\n        print(\"POV Direction:\", controller.get_pov_direction())\n        print(\"Trigger Values:\", controller.get_triggers())\n        print(\"Left Stick Values:\", controller.get_left_stick())\n        print(\"Right Stick Values:\", controller.get_right_stick())\n        time.sleep(0.1)\nexcept KeyboardInterrupt:\n    controller.stop()\n</code></pre>"},{"location":"examples/joystick/#sending-joystick-data-with-a-kevinbotcommclient","title":"Sending Joystick Data with a <code>KevinbotCommClient</code>","text":"examples/joystick/sender.py<pre><code>import time\n\nfrom kevinbotlib.comm import KevinbotCommClient\nfrom kevinbotlib.joystick import JoystickSender, LocalXboxController\nfrom kevinbotlib.logger import Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration())\n\ncontroller = LocalXboxController(\n    0\n)  # it doesn't matter what type of controller is being sent - all values will be converted to raw anyway\ncontroller.start_polling()\n\nclient = KevinbotCommClient()\nclient.connect()\nclient.wait_until_connected()\n\nsender = JoystickSender(client, controller, \"joysticks/0\")\nsender.start()\n\nwhile True:\n    time.sleep(1)\n</code></pre>"},{"location":"examples/joystick/#receiving-raw-joystick-data-with-a-kevinbotcommclient","title":"Receiving Raw Joystick Data with a <code>KevinbotCommClient</code>","text":"examples/joystick/rw_raw.py<pre><code>import time\n\nfrom kevinbotlib.comm import KevinbotCommClient\nfrom kevinbotlib.joystick import RemoteRawJoystickDevice\nfrom kevinbotlib.logger import Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration())\n\nclient = KevinbotCommClient(on_update=None)\nclient.connect()\nclient.wait_until_connected()\n\ncontroller = RemoteRawJoystickDevice(client, \"joysticks/0\")\ncontroller.start_polling()\n\ntry:\n    while True:\n        print(\"Buttons:\", controller.get_buttons())\n        print(\"POV:\", controller.get_pov_direction())\n        print(\"Axes:\", controller.get_axes())\n        print(\"Connected:\", controller.is_connected())\n        time.sleep(0.1)\nexcept KeyboardInterrupt:\n    controller.stop()\n</code></pre>"},{"location":"examples/joystick/#receiving-xbox-joystick-data-with-a-kevinbotcommclient","title":"Receiving Xbox Joystick Data with a <code>KevinbotCommClient</code>","text":"examples/joystick/rw_xbox.py<pre><code>import time\n\nfrom kevinbotlib.comm import KevinbotCommClient\nfrom kevinbotlib.joystick import RemoteXboxController\nfrom kevinbotlib.logger import Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration())\n\nclient = KevinbotCommClient(on_update=None)\nclient.connect()\nclient.wait_until_connected()\n\ncontroller = RemoteXboxController(client, \"joysticks/0\")\ncontroller.start_polling()\n\ntry:\n    while True:\n        print(\"Buttons:\", controller.get_buttons())\n        print(\"POV:\", controller.get_pov_direction())\n        print(\"Trigger Values:\", controller.get_triggers())\n        print(\"Left Stick Values:\", controller.get_left_stick())\n        print(\"Right Stick Values:\", controller.get_right_stick())\n        print(\"Connected:\", controller.is_connected())\n        time.sleep(0.1)\nexcept KeyboardInterrupt:\n    controller.stop()\n</code></pre>"},{"location":"examples/logger/","title":"Logging Examples","text":""},{"location":"examples/logger/#logging-levels","title":"Logging Levels","text":"examples/logger/logger_levels.py<pre><code>from kevinbotlib.logger import Level, Logger, LoggerConfiguration\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration(Level.TRACE))  # lowest available level\n\nlogger.trace(\"A trace message\")\nlogger.debug(\"A debug message\")\nlogger.info(\"An info message\")\nlogger.warning(\"A warning message\")\nlogger.error(\"An error message\")\nlogger.security(\"A secutity warning or error\")\nlogger.critical(\"A critical message\")\n</code></pre>"},{"location":"examples/logger/#file-logger","title":"File Logger","text":"examples/logger/file_logger.py<pre><code>import time\n\nfrom kevinbotlib.fileserver import FileServer\nfrom kevinbotlib.logger import FileLoggerConfig, Level, Logger, LoggerConfiguration, LoggerDirectories\n\nprint(f\"Logging to {LoggerDirectories.get_logger_directory()}\")\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration(Level.DEBUG, FileLoggerConfig()))\n\nfileserver = FileServer(LoggerDirectories.get_logger_directory())\nfileserver.start()\n\nLoggerDirectories.cleanup_logs(LoggerDirectories.get_logger_directory())\n\nlogger.trace(\"A trace message\")\nlogger.debug(\"A debug message\")\nlogger.info(\"An info message\")\nlogger.warning(\"A warning message\")\nlogger.error(\"An error message\")\nlogger.critical(\"A critical message\")\n\nwhile True:\n    time.sleep(1)  # keep the fileserver up\n</code></pre>"},{"location":"examples/logger/#stdout-redirector","title":"Stdout Redirector","text":"examples/logger/stdout_redirector.py<pre><code>import contextlib\n\nfrom kevinbotlib.logger import Level, Logger, LoggerConfiguration, StreamRedirector\n\nlogger = Logger()\nlogger.configure(LoggerConfiguration(Level.DEBUG))\nstream = StreamRedirector(logger)\n\nwith contextlib.redirect_stdout(stream):\n    print(\"Hello from KevinbotLib!\")\n    print(\"This will be converted to a logging entry\")\n</code></pre>"},{"location":"examples/robot/","title":"Robot Examples","text":""},{"location":"examples/robot/#robot-controller","title":"Robot Controller","text":"examples/robot/robot.py<pre><code>from kevinbotlib.logger import Level\nfrom kevinbotlib.robot import BaseRobot\n\n\nclass DemoRobot(BaseRobot):\n    def __init__(self):\n        super().__init__(\n            opmodes=[\"TestOp1\", \"TestOp2\", \"TestOp3\", \"TestOp4\"],  # robot's operational modes\n            log_level=Level.TRACE,  # lowset logging level\n            cycle_time=20,  # loop our robot code 20x per second - it is recommended to run much higher in practice\n        )\n\n    def robot_start(self) -&gt; None:  # runs once as the robot starts\n        super().robot_start()\n        print(\n            \"Starting robot...\"\n        )  # print statements are redirected to the KevinbotLib logging system - please don't do this in production\n\n    def opmode_periodic(self, opmode: str, enabled: bool) -&gt; None:\n        super().opmode_periodic(opmode, enabled)\n\n        print(f\"OpMode {'enabled' if enabled else 'disabled'}... {opmode}\")\n\n    def opmode_init(self, opmode: str, enabled: bool) -&gt; None:\n        super().opmode_init(opmode, enabled)\n\n        print(f\"OpMode {'enabled' if enabled else 'disabled'} init... {opmode}\")\n\n    def opmode_exit(self, opmode: str, enabled: bool) -&gt; None:\n        super().opmode_exit(opmode, enabled)\n\n        print(f\"OpMode {'enabled' if enabled else 'disabled'} exit... {opmode}\")\n\n    def robot_end(self) -&gt; None:  # runs as the robot propares to shutdown\n        super().robot_end()\n        print(\"Ending robot...\")\n\n\nif __name__ == \"__main__\":\n    DemoRobot().run()\n</code></pre>"}]}