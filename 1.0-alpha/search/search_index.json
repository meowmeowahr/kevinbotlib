{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KevinbotLib","text":"<p>KevinbotLib is a modular robot control system integrating a high-speed server-client communication system, robust logging, gamepad inputs, and more.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>The Command Scheduler<ul> <li>A way to asyncronously run robot tasks</li> <li>Commands can be grouped to run sequentially, or in parallel if desired</li> <li>Commands can be executed at a set interval</li> </ul> </li> <li>The Communication System<ul> <li>Based on websockets</li> <li>Data can be easily sent from robot to client or vise-versa</li> <li>Data is syncronized between all clients</li> <li>Out-of-the-box ready-made sendables for builtin primitive types</li> <li>Easy to create custom sendables based on pydantic models</li> </ul> </li> <li>The Vision Pipeline System<ul> <li>Create vision pipelines based on OpenCV</li> <li>Pre-made sendables for video frames</li> <li>Pre-made encoders and decoders for the communication system</li> </ul> </li> <li>Robust Logging<ul> <li>Logging is based on loguru</li> <li>Automatic file rotations</li> <li>Logs to <code>stdout</code>, an inbuilt file server over HTTP, and/or an inbuilt FTP server (deprecated)</li> </ul> </li> <li>Gamepad Inputs<ul> <li>Based on SDL2</li> <li>Builtin-support for Raw devices and Xbox One and Xbox Series controllers</li> <li>Joystick data sender and reciever through the communication system</li> </ul> </li> </ul> <p>Development</p> <p>This project is in the early stage of development. There are many missing functions that will be supported in the future.</p>"},{"location":"commandscheduler/","title":"The Command Scheduler","text":""},{"location":"examples/","title":"Examples","text":"<p>All examples can be found on the project's repo - here</p>"},{"location":"examples/#comm","title":"Comm","text":""},{"location":"examples/#fileserver","title":"Fileserver","text":""},{"location":"examples/#joystick","title":"Joystick","text":""},{"location":"examples/#logger","title":"Logger","text":""},{"location":"examples/#robot","title":"Robot","text":""},{"location":"examples/#command-scheduler","title":"Command Scheduler","text":""},{"location":"examples/#vision","title":"Vision","text":""},{"location":"installation/","title":"Installation","text":"<p>Info</p> <p>KevinbotLib requires Python 3.10 or newer.</p>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"<p>Run the following in a virtual environment for the base version. <pre><code>pip install kevinbotlib\n</code></pre></p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#kevinbotlib.robot.InstanceLocker","title":"<code>InstanceLocker</code>","text":"Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>class InstanceLocker:\n    def __init__(self, lockfile_name: str):\n        \"\"\"Initialize the InstanceLocker\n\n        Args:\n            lockfile_name (str): The name of the lockfile (e.g., 'robot.lock').\n        \"\"\"\n        self.lockfile_name = lockfile_name\n        self.pid = os.getpid()\n        self._locked = False\n\n    def lock(self) -&gt; bool:\n        \"\"\"Attempt to acquire the lock by creating a lockfile with the current PID.\n\n        Returns:\n            bool: True if the lock was successfully acquired, False if another instance is running.\n        \"\"\"\n        if self._locked:\n            return True  # Already locked by this instance\n\n        # Check if another instance is running\n        if self.is_locked(self.lockfile_name):\n            return False\n\n        # Try to create the lockfile\n        try:\n            with open(os.path.join(tempfile.gettempdir(), self.lockfile_name), \"w\") as f:\n                f.write(str(self.pid))\n            self._locked = True\n        except FileExistsError:\n            # Double-check in case of race condition\n            if self.is_locked(self.lockfile_name):\n                return False\n            # If the process is gone, overwrite the lockfile\n            with open(os.path.join(tempfile.gettempdir(), self.lockfile_name), \"w\") as f:\n                f.write(str(self.pid))\n            self._locked = True\n            return True\n        except OSError as e:\n            Logger().error(f\"Failed to create lockfile: {e!r}\")\n            return False\n        else:\n            return True\n\n    def unlock(self) -&gt; None:\n        \"\"\"Release the lock by removing the lockfile.\"\"\"\n        if not self._locked:\n            return\n\n        try:\n            if os.path.exists(os.path.join(tempfile.gettempdir(), self.lockfile_name)):\n                with open(os.path.join(tempfile.gettempdir(), self.lockfile_name)) as f:\n                    pid = f.read().strip()\n                if pid == str(self.pid):  # Only remove if this process owns the lock\n                    os.remove(os.path.join(tempfile.gettempdir(), self.lockfile_name))\n            self._locked = False\n        except OSError as e:\n            Logger().error(f\"Failed to remove lockfile: {e!r}\")\n\n    @staticmethod\n    def is_locked(lockfile_name: str) -&gt; int:\n        \"\"\"Check if the lockfile exists and corresponds to a running process.\n\n        Args:\n            lockfile_name (str): The name of the lockfile to check.\n\n        Returns:\n            int: -1 if not locked, PID of locking process\n        \"\"\"\n        if not os.path.exists(os.path.join(tempfile.gettempdir(), lockfile_name)):\n            return False\n\n        try:\n            with open(os.path.join(tempfile.gettempdir(), lockfile_name)) as f:\n                pid_str = f.read().strip()\n                pid = int(pid_str)\n        except (OSError, ValueError):\n            # If the file is corrupt or unreadable, assume it's stale and not locked\n            return False\n        return pid in [p.info[\"pid\"] for p in psutil.process_iter(attrs=[\"pid\", \"name\"])]\n\n    def __enter__(self) -&gt; \"InstanceLocker\":\n        \"\"\"Context manager support: acquire the lock.\"\"\"\n        self.lock()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Context manager support: release the lock.\"\"\"\n        self.unlock()\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.__init__","title":"<code>__init__(lockfile_name)</code>","text":"<p>Initialize the InstanceLocker</p> <p>Parameters:</p> Name Type Description Default <code>lockfile_name</code> <code>str</code> <p>The name of the lockfile (e.g., 'robot.lock').</p> required Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def __init__(self, lockfile_name: str):\n    \"\"\"Initialize the InstanceLocker\n\n    Args:\n        lockfile_name (str): The name of the lockfile (e.g., 'robot.lock').\n    \"\"\"\n    self.lockfile_name = lockfile_name\n    self.pid = os.getpid()\n    self._locked = False\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.lock","title":"<code>lock()</code>","text":"<p>Attempt to acquire the lock by creating a lockfile with the current PID.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the lock was successfully acquired, False if another instance is running.</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def lock(self) -&gt; bool:\n    \"\"\"Attempt to acquire the lock by creating a lockfile with the current PID.\n\n    Returns:\n        bool: True if the lock was successfully acquired, False if another instance is running.\n    \"\"\"\n    if self._locked:\n        return True  # Already locked by this instance\n\n    # Check if another instance is running\n    if self.is_locked(self.lockfile_name):\n        return False\n\n    # Try to create the lockfile\n    try:\n        with open(os.path.join(tempfile.gettempdir(), self.lockfile_name), \"w\") as f:\n            f.write(str(self.pid))\n        self._locked = True\n    except FileExistsError:\n        # Double-check in case of race condition\n        if self.is_locked(self.lockfile_name):\n            return False\n        # If the process is gone, overwrite the lockfile\n        with open(os.path.join(tempfile.gettempdir(), self.lockfile_name), \"w\") as f:\n            f.write(str(self.pid))\n        self._locked = True\n        return True\n    except OSError as e:\n        Logger().error(f\"Failed to create lockfile: {e!r}\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.unlock","title":"<code>unlock()</code>","text":"<p>Release the lock by removing the lockfile.</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def unlock(self) -&gt; None:\n    \"\"\"Release the lock by removing the lockfile.\"\"\"\n    if not self._locked:\n        return\n\n    try:\n        if os.path.exists(os.path.join(tempfile.gettempdir(), self.lockfile_name)):\n            with open(os.path.join(tempfile.gettempdir(), self.lockfile_name)) as f:\n                pid = f.read().strip()\n            if pid == str(self.pid):  # Only remove if this process owns the lock\n                os.remove(os.path.join(tempfile.gettempdir(), self.lockfile_name))\n        self._locked = False\n    except OSError as e:\n        Logger().error(f\"Failed to remove lockfile: {e!r}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.is_locked","title":"<code>is_locked(lockfile_name)</code>  <code>staticmethod</code>","text":"<p>Check if the lockfile exists and corresponds to a running process.</p> <p>Parameters:</p> Name Type Description Default <code>lockfile_name</code> <code>str</code> <p>The name of the lockfile to check.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>-1 if not locked, PID of locking process</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>@staticmethod\ndef is_locked(lockfile_name: str) -&gt; int:\n    \"\"\"Check if the lockfile exists and corresponds to a running process.\n\n    Args:\n        lockfile_name (str): The name of the lockfile to check.\n\n    Returns:\n        int: -1 if not locked, PID of locking process\n    \"\"\"\n    if not os.path.exists(os.path.join(tempfile.gettempdir(), lockfile_name)):\n        return False\n\n    try:\n        with open(os.path.join(tempfile.gettempdir(), lockfile_name)) as f:\n            pid_str = f.read().strip()\n            pid = int(pid_str)\n    except (OSError, ValueError):\n        # If the file is corrupt or unreadable, assume it's stale and not locked\n        return False\n    return pid in [p.info[\"pid\"] for p in psutil.process_iter(attrs=[\"pid\", \"name\"])]\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager support: acquire the lock.</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def __enter__(self) -&gt; \"InstanceLocker\":\n    \"\"\"Context manager support: acquire the lock.\"\"\"\n    self.lock()\n    return self\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.InstanceLocker.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager support: release the lock.</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Context manager support: release the lock.\"\"\"\n    self.unlock()\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot","title":"<code>BaseRobot</code>","text":"Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>class BaseRobot:\n    def __init__(\n        self,\n        opmodes: list[str],\n        serve_port: int = 8765,\n        log_level: Level = Level.INFO,\n        print_level: Level = Level.INFO,\n        default_opmode: str | None = None,\n        cycle_time: float = 250,\n        log_cleanup_timer: float = 10.0,\n    ):\n        \"\"\"\n        Initialize the robot\n\n        Args:\n            opmodes (list[str]): List of operational mode names.\n            serve_port (int, optional): Port for comm server. Shouldn't have to be changed in most cases. Defaults to 8765.\n            log_level (Level, optional): Level to logging. Defaults to Level.INFO.\n            print_level (Level, optional): Level for print statement redirector. Defaults to Level.INFO.\n            default_opmode (str, optional): Default Operational Mode to start in. Defaults to the first item of `opmodes`.\n            cycle_time (float, optional): How fast to run periodic functions in Hz. Defaults to 250.\n            log_cleanup_timer (float, optional): How often to cleanup logs in seconds Set to 0 to disable log cleanup. Defaults to 10.0.\n        \"\"\"\n\n        self.telemetry = Logger()\n        self.telemetry.configure(LoggerConfiguration(level=log_level, file_logger=FileLoggerConfig()))\n\n        sys.excepthook = self._exc_hook\n        threading.excepthook = self._thread_exc_hook\n\n        self.fileserver = FileServer(LoggerDirectories.get_logger_directory())\n\n        self._instance_locker = InstanceLocker(f\"{self.__class__.__name__}.lock\")\n        atexit.register(self._instance_locker.unlock)\n\n        self._opmodes = opmodes\n\n        self.comm_server = KevinbotCommServer(port=serve_port)\n        self.comm_client = KevinbotCommClient(port=serve_port)\n\n        self._print_log_level = print_level\n        self._log_timer_interval = log_cleanup_timer\n\n        self._ctrl_sendable: ControlConsoleSendable = ControlConsoleSendable(\n            opmode=default_opmode or opmodes[0], opmodes=opmodes\n        )\n        self._ctrl_sendable_key = \"%ControlConsole\"\n\n        self._signal_stop = False\n        self._signal_estop = False\n\n        self._ready_for_periodic = False\n        self._cycle_hz = cycle_time\n\n        # Track the previous state for opmode transitions\n        self._prev_enabled = None  # Was the robot previously enabled?\n\n    @final\n    def _signal_usr1_capture(self, _, __):\n        self.telemetry.critical(\"Signal stop detected... Stopping now\")\n        self._signal_stop = True\n\n    @final\n    def _signal_usr2_capture(self, _, __):\n        \"\"\"Internal method used for the *EMERGENCY STOP* system **DO NOT OVERRIDE**\"\"\"\n        self.telemetry.critical(\"Signal EMERGENCY STOP detected... Stopping now\")\n        self._signal_estop = True\n\n    @final\n    def _thread_exc_hook(self, args):\n        self._exc_hook(*args)\n\n    @final\n    def _exc_hook(self, _: type, exc_value: BaseException, __: TracebackType, *_args):\n        if isinstance(exc_value, RobotEmergencyStoppedException | RobotStoppedException):\n            return\n        self.telemetry.log(\n            Level.CRITICAL, \"The robot stopped due to an exception\", LoggerWriteOpts(exception=exc_value)\n        )\n\n    @final\n    def _log_cleanup_internal(self):\n        LoggerDirectories.cleanup_logs(LoggerDirectories.get_logger_directory())\n        self.telemetry.trace(\"Cleaned up logs\")\n        if self._log_timer_interval != 0:\n            timer = threading.Timer(self._log_timer_interval, self._log_cleanup_internal)\n            timer.setDaemon(True)\n            timer.setName(\"KevinbotLib.Cleanup.LogCleanup\")\n            timer.start()\n\n    @final\n    def run(self) -&gt; NoReturn:\n        \"\"\"Run the robot loop. Method is **final**.\"\"\"\n        if InstanceLocker.is_locked(f\"{self.__class__.__name__}.lock\"):\n            msg = f\"Another robot with the class name {self.__class__.__name__} is already running\"\n            raise RobotLockedException(msg)\n        self._instance_locker.lock()\n\n        if platform.system() != \"Linux\":\n            self.telemetry.warning(\n                \"Non-Linux OSes are not fully supported. Features such as signal shutdown may be broken\"\n            )\n\n        signal.signal(signal.SIGUSR1, self._signal_usr1_capture)\n        signal.signal(signal.SIGUSR2, self._signal_usr2_capture)\n        self.telemetry.debug(f\"{self.__class__.__name__}'s process id is {os.getpid()}\")\n\n        Thread(\n            target=self.comm_server.serve,\n            daemon=True,\n            name=f\"KevinbotLib.Robot.{self.__class__.__name__}.CommServer\",\n        ).start()\n        self.comm_server.wait_until_serving()\n        self.comm_client.connect()\n\n        self.fileserver.start()\n\n        if self._log_timer_interval != 0:\n            timer = threading.Timer(self._log_timer_interval, self._log_cleanup_internal)\n            timer.setDaemon(True)\n            timer.setName(\"KevinbotLib.Cleanup.LogCleanup\")\n            timer.start()\n\n        with contextlib.redirect_stdout(StreamRedirector(self.telemetry, self._print_log_level)):\n            self.comm_client.wait_until_connected()\n            self.comm_client.send(self._ctrl_sendable_key, self._ctrl_sendable)\n            try:\n                self.robot_start()\n                self._ready_for_periodic = True\n                self.telemetry.log(Level.INFO, \"Robot started\")\n\n                while True:\n                    sendable: ControlConsoleSendable | None = self.comm_client.get(\n                        self._ctrl_sendable_key, ControlConsoleSendable\n                    )\n                    if sendable:\n                        self._ctrl_sendable: ControlConsoleSendable = sendable\n                    else:\n                        self._ctrl_sendable.enabled = False\n                        self.comm_client.send(self._ctrl_sendable_key, self._ctrl_sendable)\n\n                    if self._signal_stop:\n                        msg = \"Robot signal stopped\"\n                        raise RobotStoppedException(msg)\n                    if self._signal_estop:\n                        msg = \"Robot signal e-stopped\"\n                        raise RobotEmergencyStoppedException(msg)\n\n                    if self._ctrl_sendable.opmodes != self._opmodes:\n                        self._ctrl_sendable.opmodes = self._opmodes\n                        self.comm_client.send(self._ctrl_sendable_key, self._ctrl_sendable)\n\n                    if self._ctrl_sendable.opmode not in self._opmodes:\n                        self.telemetry.error(\n                            f\"Got incorrect OpMode: {self._ctrl_sendable.opmode} from {self._ctrl_sendable.opmodes}\"\n                        )\n                        self._ctrl_sendable.opmode = self._opmodes[0]  # Fallback to default opmode\n                        self._ctrl_sendable.enabled = False\n                        self.comm_client.send(self._ctrl_sendable_key, self._ctrl_sendable)\n\n                    if self._ready_for_periodic:\n                        current_enabled: bool = self._ctrl_sendable.enabled\n                        if self._ctrl_sendable:\n                            current_opmode = self._ctrl_sendable.opmode\n\n                        if self._prev_enabled != current_enabled:\n                            if current_enabled:\n                                self.opmode_enabled_init(current_opmode)\n                            else:\n                                self.opmode_disabled_init(current_opmode)\n\n                        if current_enabled:\n                            self.opmode_enabled_periodic(current_opmode)\n                        else:\n                            self.opmode_disabled_periodic(current_opmode)\n\n                        self._prev_enabled = current_enabled\n                        self._prev_opmode = current_opmode\n\n                    time.sleep(1 / self._cycle_hz)\n            finally:\n                self.robot_end()\n\n    def robot_start(self) -&gt; None:\n        \"\"\"Run after the robot is initialized\"\"\"\n\n    def robot_end(self) -&gt; None:\n        \"\"\"Runs before the robot is requested to stop via service or keyboard interrupt\"\"\"\n\n    def opmode_enabled_init(self, opmode: str) -&gt; None:\n        \"\"\"Runs once when the robot is enabled\n\n        Args:\n            opmode (str): The OpMode the robot was enabled in. Default opmodes are `\"Teleoperated\"` and `\"Test\"`\n        \"\"\"\n\n    def opmode_enabled_periodic(self, opmode: str) -&gt; None:\n        \"\"\"Loops when the robot is enabled\n\n        Args:\n            opmode (str): The OpMode the robot is currently in. Default opmodes are `\"Teleoperated\"` and `\"Test\"`\n        \"\"\"\n\n    def opmode_disabled_init(self, opmode: str) -&gt; None:\n        \"\"\"Runs once when the robot is disabled\n\n        Args:\n            opmode (str): The OpMode the robot was disabled in. Default opmodes are `\"Teleoperated\"` and `\"Test\"`\n        \"\"\"\n\n    def opmode_disabled_periodic(self, opmode: str) -&gt; None:\n        \"\"\"Loops when the robot is disabled\n\n        Args:\n            opmode (str): The OpMode the robot is currently in. Default opmodes are `\"Teleoperated\"` and `\"Test\"`\n        \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.__init__","title":"<code>__init__(opmodes, serve_port=8765, log_level=Level.INFO, print_level=Level.INFO, default_opmode=None, cycle_time=250, log_cleanup_timer=10.0)</code>","text":"<p>Initialize the robot</p> <p>Parameters:</p> Name Type Description Default <code>opmodes</code> <code>list[str]</code> <p>List of operational mode names.</p> required <code>serve_port</code> <code>int</code> <p>Port for comm server. Shouldn't have to be changed in most cases. Defaults to 8765.</p> <code>8765</code> <code>log_level</code> <code>Level</code> <p>Level to logging. Defaults to Level.INFO.</p> <code>INFO</code> <code>print_level</code> <code>Level</code> <p>Level for print statement redirector. Defaults to Level.INFO.</p> <code>INFO</code> <code>default_opmode</code> <code>str</code> <p>Default Operational Mode to start in. Defaults to the first item of <code>opmodes</code>.</p> <code>None</code> <code>cycle_time</code> <code>float</code> <p>How fast to run periodic functions in Hz. Defaults to 250.</p> <code>250</code> <code>log_cleanup_timer</code> <code>float</code> <p>How often to cleanup logs in seconds Set to 0 to disable log cleanup. Defaults to 10.0.</p> <code>10.0</code> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def __init__(\n    self,\n    opmodes: list[str],\n    serve_port: int = 8765,\n    log_level: Level = Level.INFO,\n    print_level: Level = Level.INFO,\n    default_opmode: str | None = None,\n    cycle_time: float = 250,\n    log_cleanup_timer: float = 10.0,\n):\n    \"\"\"\n    Initialize the robot\n\n    Args:\n        opmodes (list[str]): List of operational mode names.\n        serve_port (int, optional): Port for comm server. Shouldn't have to be changed in most cases. Defaults to 8765.\n        log_level (Level, optional): Level to logging. Defaults to Level.INFO.\n        print_level (Level, optional): Level for print statement redirector. Defaults to Level.INFO.\n        default_opmode (str, optional): Default Operational Mode to start in. Defaults to the first item of `opmodes`.\n        cycle_time (float, optional): How fast to run periodic functions in Hz. Defaults to 250.\n        log_cleanup_timer (float, optional): How often to cleanup logs in seconds Set to 0 to disable log cleanup. Defaults to 10.0.\n    \"\"\"\n\n    self.telemetry = Logger()\n    self.telemetry.configure(LoggerConfiguration(level=log_level, file_logger=FileLoggerConfig()))\n\n    sys.excepthook = self._exc_hook\n    threading.excepthook = self._thread_exc_hook\n\n    self.fileserver = FileServer(LoggerDirectories.get_logger_directory())\n\n    self._instance_locker = InstanceLocker(f\"{self.__class__.__name__}.lock\")\n    atexit.register(self._instance_locker.unlock)\n\n    self._opmodes = opmodes\n\n    self.comm_server = KevinbotCommServer(port=serve_port)\n    self.comm_client = KevinbotCommClient(port=serve_port)\n\n    self._print_log_level = print_level\n    self._log_timer_interval = log_cleanup_timer\n\n    self._ctrl_sendable: ControlConsoleSendable = ControlConsoleSendable(\n        opmode=default_opmode or opmodes[0], opmodes=opmodes\n    )\n    self._ctrl_sendable_key = \"%ControlConsole\"\n\n    self._signal_stop = False\n    self._signal_estop = False\n\n    self._ready_for_periodic = False\n    self._cycle_hz = cycle_time\n\n    # Track the previous state for opmode transitions\n    self._prev_enabled = None  # Was the robot previously enabled?\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot._signal_usr2_capture","title":"<code>_signal_usr2_capture(_, __)</code>","text":"<p>Internal method used for the EMERGENCY STOP system DO NOT OVERRIDE</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>@final\ndef _signal_usr2_capture(self, _, __):\n    \"\"\"Internal method used for the *EMERGENCY STOP* system **DO NOT OVERRIDE**\"\"\"\n    self.telemetry.critical(\"Signal EMERGENCY STOP detected... Stopping now\")\n    self._signal_estop = True\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.run","title":"<code>run()</code>","text":"<p>Run the robot loop. Method is final.</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>@final\ndef run(self) -&gt; NoReturn:\n    \"\"\"Run the robot loop. Method is **final**.\"\"\"\n    if InstanceLocker.is_locked(f\"{self.__class__.__name__}.lock\"):\n        msg = f\"Another robot with the class name {self.__class__.__name__} is already running\"\n        raise RobotLockedException(msg)\n    self._instance_locker.lock()\n\n    if platform.system() != \"Linux\":\n        self.telemetry.warning(\n            \"Non-Linux OSes are not fully supported. Features such as signal shutdown may be broken\"\n        )\n\n    signal.signal(signal.SIGUSR1, self._signal_usr1_capture)\n    signal.signal(signal.SIGUSR2, self._signal_usr2_capture)\n    self.telemetry.debug(f\"{self.__class__.__name__}'s process id is {os.getpid()}\")\n\n    Thread(\n        target=self.comm_server.serve,\n        daemon=True,\n        name=f\"KevinbotLib.Robot.{self.__class__.__name__}.CommServer\",\n    ).start()\n    self.comm_server.wait_until_serving()\n    self.comm_client.connect()\n\n    self.fileserver.start()\n\n    if self._log_timer_interval != 0:\n        timer = threading.Timer(self._log_timer_interval, self._log_cleanup_internal)\n        timer.setDaemon(True)\n        timer.setName(\"KevinbotLib.Cleanup.LogCleanup\")\n        timer.start()\n\n    with contextlib.redirect_stdout(StreamRedirector(self.telemetry, self._print_log_level)):\n        self.comm_client.wait_until_connected()\n        self.comm_client.send(self._ctrl_sendable_key, self._ctrl_sendable)\n        try:\n            self.robot_start()\n            self._ready_for_periodic = True\n            self.telemetry.log(Level.INFO, \"Robot started\")\n\n            while True:\n                sendable: ControlConsoleSendable | None = self.comm_client.get(\n                    self._ctrl_sendable_key, ControlConsoleSendable\n                )\n                if sendable:\n                    self._ctrl_sendable: ControlConsoleSendable = sendable\n                else:\n                    self._ctrl_sendable.enabled = False\n                    self.comm_client.send(self._ctrl_sendable_key, self._ctrl_sendable)\n\n                if self._signal_stop:\n                    msg = \"Robot signal stopped\"\n                    raise RobotStoppedException(msg)\n                if self._signal_estop:\n                    msg = \"Robot signal e-stopped\"\n                    raise RobotEmergencyStoppedException(msg)\n\n                if self._ctrl_sendable.opmodes != self._opmodes:\n                    self._ctrl_sendable.opmodes = self._opmodes\n                    self.comm_client.send(self._ctrl_sendable_key, self._ctrl_sendable)\n\n                if self._ctrl_sendable.opmode not in self._opmodes:\n                    self.telemetry.error(\n                        f\"Got incorrect OpMode: {self._ctrl_sendable.opmode} from {self._ctrl_sendable.opmodes}\"\n                    )\n                    self._ctrl_sendable.opmode = self._opmodes[0]  # Fallback to default opmode\n                    self._ctrl_sendable.enabled = False\n                    self.comm_client.send(self._ctrl_sendable_key, self._ctrl_sendable)\n\n                if self._ready_for_periodic:\n                    current_enabled: bool = self._ctrl_sendable.enabled\n                    if self._ctrl_sendable:\n                        current_opmode = self._ctrl_sendable.opmode\n\n                    if self._prev_enabled != current_enabled:\n                        if current_enabled:\n                            self.opmode_enabled_init(current_opmode)\n                        else:\n                            self.opmode_disabled_init(current_opmode)\n\n                    if current_enabled:\n                        self.opmode_enabled_periodic(current_opmode)\n                    else:\n                        self.opmode_disabled_periodic(current_opmode)\n\n                    self._prev_enabled = current_enabled\n                    self._prev_opmode = current_opmode\n\n                time.sleep(1 / self._cycle_hz)\n        finally:\n            self.robot_end()\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.robot_start","title":"<code>robot_start()</code>","text":"<p>Run after the robot is initialized</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def robot_start(self) -&gt; None:\n    \"\"\"Run after the robot is initialized\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.robot_end","title":"<code>robot_end()</code>","text":"<p>Runs before the robot is requested to stop via service or keyboard interrupt</p> Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def robot_end(self) -&gt; None:\n    \"\"\"Runs before the robot is requested to stop via service or keyboard interrupt\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.opmode_enabled_init","title":"<code>opmode_enabled_init(opmode)</code>","text":"<p>Runs once when the robot is enabled</p> <p>Parameters:</p> Name Type Description Default <code>opmode</code> <code>str</code> <p>The OpMode the robot was enabled in. Default opmodes are <code>\"Teleoperated\"</code> and <code>\"Test\"</code></p> required Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def opmode_enabled_init(self, opmode: str) -&gt; None:\n    \"\"\"Runs once when the robot is enabled\n\n    Args:\n        opmode (str): The OpMode the robot was enabled in. Default opmodes are `\"Teleoperated\"` and `\"Test\"`\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.opmode_enabled_periodic","title":"<code>opmode_enabled_periodic(opmode)</code>","text":"<p>Loops when the robot is enabled</p> <p>Parameters:</p> Name Type Description Default <code>opmode</code> <code>str</code> <p>The OpMode the robot is currently in. Default opmodes are <code>\"Teleoperated\"</code> and <code>\"Test\"</code></p> required Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def opmode_enabled_periodic(self, opmode: str) -&gt; None:\n    \"\"\"Loops when the robot is enabled\n\n    Args:\n        opmode (str): The OpMode the robot is currently in. Default opmodes are `\"Teleoperated\"` and `\"Test\"`\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.opmode_disabled_init","title":"<code>opmode_disabled_init(opmode)</code>","text":"<p>Runs once when the robot is disabled</p> <p>Parameters:</p> Name Type Description Default <code>opmode</code> <code>str</code> <p>The OpMode the robot was disabled in. Default opmodes are <code>\"Teleoperated\"</code> and <code>\"Test\"</code></p> required Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def opmode_disabled_init(self, opmode: str) -&gt; None:\n    \"\"\"Runs once when the robot is disabled\n\n    Args:\n        opmode (str): The OpMode the robot was disabled in. Default opmodes are `\"Teleoperated\"` and `\"Test\"`\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.robot.BaseRobot.opmode_disabled_periodic","title":"<code>opmode_disabled_periodic(opmode)</code>","text":"<p>Loops when the robot is disabled</p> <p>Parameters:</p> Name Type Description Default <code>opmode</code> <code>str</code> <p>The OpMode the robot is currently in. Default opmodes are <code>\"Teleoperated\"</code> and <code>\"Test\"</code></p> required Source code in <code>src/kevinbotlib/robot.py</code> <pre><code>def opmode_disabled_periodic(self, opmode: str) -&gt; None:\n    \"\"\"Loops when the robot is disabled\n\n    Args:\n        opmode (str): The OpMode the robot is currently in. Default opmodes are `\"Teleoperated\"` and `\"Test\"`\n    \"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer","title":"<code>KevinbotCommServer</code>","text":"<p>WebSocket-based server for handling real-time data synchronization.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class KevinbotCommServer:\n    \"\"\"WebSocket-based server for handling real-time data synchronization.\"\"\"\n\n    def __init__(self, host: str = \"localhost\", port: int = 8765) -&gt; None:\n        self.host: str = host\n        self.port: int = port\n\n        self.logger = _Logger()\n\n        self.data_store: dict[str, dict[str, Any]] = {}\n        self.clients: set[websockets.ServerConnection] = set()\n        self.tasks = set()\n\n        self.serving = False\n\n    async def remove_expired_data(self) -&gt; None:\n        \"\"\"Periodically removes expired data based on timeouts.\"\"\"\n        while True:\n            current_time = time.time()\n            expired_keys = [\n                key\n                for key, entry in self.data_store.items()\n                if entry[\"data\"][\"timeout\"] and entry[\"tsu\"] + entry[\"data\"][\"timeout\"] &lt; current_time\n            ]\n            for key in expired_keys:\n                del self.data_store[key]\n                await self.broadcast({\"action\": \"delete\", \"key\": key})\n            await asyncio.sleep(1)\n\n    async def broadcast(self, message: dict[str, Any]) -&gt; None:\n        \"\"\"Broadcasts a message to all connected clients.\"\"\"\n        if self.clients:\n            msg = orjson.dumps(message)\n            await asyncio.gather(*(client.send(msg) for client in self.clients))\n\n    async def handle_client(self, websocket: websockets.ServerConnection) -&gt; None:\n        \"\"\"Handles incoming WebSocket connections.\"\"\"\n        self.clients.add(websocket)\n        self.logger.info(f\"New client connected: {websocket.id}\")\n        try:\n            await websocket.send(orjson.dumps({\"action\": \"sync\", \"data\": self.data_store}))\n            async for message in websocket:\n                msg = orjson.loads(message)\n                if msg[\"action\"] == \"publish\":\n                    key = msg[\"key\"]\n                    tsc = time.time() if key not in self.data_store else self.data_store[key][\"tsc\"]\n                    self.data_store[key] = {\n                        \"data\": msg[\"data\"],\n                        \"tsu\": time.time(),\n                        \"tsc\": tsc,\n                    }\n                    await self.broadcast({\"action\": \"update\", \"key\": key, \"data\": self.data_store[key]})\n                elif msg[\"action\"] == \"delete\" and msg[\"key\"] in self.data_store:\n                    del self.data_store[msg[\"key\"]]\n                    await self.broadcast({\"action\": \"delete\", \"key\": msg[\"key\"]})\n        except websockets.ConnectionClosed:\n            pass\n        finally:\n            self.logger.info(f\"Client disconnected: {websocket.id}\")\n            self.clients.remove(websocket)\n\n    async def serve_async(self) -&gt; None:\n        \"\"\"Starts the WebSocket server.\"\"\"\n        self.logger.info(\"Starting a new KevinbotCommServer\")\n        server = await websockets.serve(self.handle_client, self.host, self.port, max_size=2**48 - 1)\n        task = asyncio.create_task(self.remove_expired_data())\n        self.tasks.add(task)\n        task.add_done_callback(self.tasks.discard)\n        self.serving = True\n        await server.wait_closed()\n        self.serving = False\n\n    def serve(self):\n        asyncio.run(self.serve_async())\n\n    def wait_until_serving(self, timeout: float = 5.0):\n        start_time = time.time()\n        while not self.serving:\n            if time.time() &gt; start_time + timeout:\n                msg = \"The server is not serving. You most likely called `wait_until_serving` before starting the server, or the server failed to start\"\n                raise kevinbotlib.exceptions.ServerTimeoutException(msg)\n            time.sleep(0.02)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer.remove_expired_data","title":"<code>remove_expired_data()</code>  <code>async</code>","text":"<p>Periodically removes expired data based on timeouts.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def remove_expired_data(self) -&gt; None:\n    \"\"\"Periodically removes expired data based on timeouts.\"\"\"\n    while True:\n        current_time = time.time()\n        expired_keys = [\n            key\n            for key, entry in self.data_store.items()\n            if entry[\"data\"][\"timeout\"] and entry[\"tsu\"] + entry[\"data\"][\"timeout\"] &lt; current_time\n        ]\n        for key in expired_keys:\n            del self.data_store[key]\n            await self.broadcast({\"action\": \"delete\", \"key\": key})\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer.broadcast","title":"<code>broadcast(message)</code>  <code>async</code>","text":"<p>Broadcasts a message to all connected clients.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def broadcast(self, message: dict[str, Any]) -&gt; None:\n    \"\"\"Broadcasts a message to all connected clients.\"\"\"\n    if self.clients:\n        msg = orjson.dumps(message)\n        await asyncio.gather(*(client.send(msg) for client in self.clients))\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer.handle_client","title":"<code>handle_client(websocket)</code>  <code>async</code>","text":"<p>Handles incoming WebSocket connections.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def handle_client(self, websocket: websockets.ServerConnection) -&gt; None:\n    \"\"\"Handles incoming WebSocket connections.\"\"\"\n    self.clients.add(websocket)\n    self.logger.info(f\"New client connected: {websocket.id}\")\n    try:\n        await websocket.send(orjson.dumps({\"action\": \"sync\", \"data\": self.data_store}))\n        async for message in websocket:\n            msg = orjson.loads(message)\n            if msg[\"action\"] == \"publish\":\n                key = msg[\"key\"]\n                tsc = time.time() if key not in self.data_store else self.data_store[key][\"tsc\"]\n                self.data_store[key] = {\n                    \"data\": msg[\"data\"],\n                    \"tsu\": time.time(),\n                    \"tsc\": tsc,\n                }\n                await self.broadcast({\"action\": \"update\", \"key\": key, \"data\": self.data_store[key]})\n            elif msg[\"action\"] == \"delete\" and msg[\"key\"] in self.data_store:\n                del self.data_store[msg[\"key\"]]\n                await self.broadcast({\"action\": \"delete\", \"key\": msg[\"key\"]})\n    except websockets.ConnectionClosed:\n        pass\n    finally:\n        self.logger.info(f\"Client disconnected: {websocket.id}\")\n        self.clients.remove(websocket)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommServer.serve_async","title":"<code>serve_async()</code>  <code>async</code>","text":"<p>Starts the WebSocket server.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def serve_async(self) -&gt; None:\n    \"\"\"Starts the WebSocket server.\"\"\"\n    self.logger.info(\"Starting a new KevinbotCommServer\")\n    server = await websockets.serve(self.handle_client, self.host, self.port, max_size=2**48 - 1)\n    task = asyncio.create_task(self.remove_expired_data())\n    self.tasks.add(task)\n    task.add_done_callback(self.tasks.discard)\n    self.serving = True\n    await server.wait_closed()\n    self.serving = False\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient","title":"<code>KevinbotCommClient</code>","text":"<p>KevinbotLib WebSocket-based client for real-time data synchronization and communication.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>class KevinbotCommClient:\n    \"\"\"KevinbotLib WebSocket-based client for real-time data synchronization and communication.\"\"\"\n\n    def __init__(\n        self,\n        host: str = \"localhost\",\n        port: int = 8765,\n        on_update: Callable[[str, Any], None] | None = None,\n        on_delete: Callable[[str], None] | None = None,\n        on_connect: Callable[[], None] | None = None,\n        on_disconnect: Callable[[], None] | None = None,\n        *,\n        auto_reconnect: bool = True,\n        register_basic_types: bool = True,\n    ) -&gt; None:\n        self._host = host\n        self._port = port\n        self.auto_reconnect = auto_reconnect\n\n        self.logger = _Logger()\n\n        self.data_store: dict[str, Any] = {}\n        self.data_types: dict[str, type[BaseSendable]] = {}\n\n        self.running = False\n        self.websocket: websockets.ClientConnection | None = None\n        self.loop = asyncio.get_event_loop()\n        self.thread: threading.Thread | None = None\n\n        self.on_update = on_update\n        self.on_delete = on_delete\n        self.on_connect = on_connect\n        self.on_disconnect = on_disconnect\n\n        if register_basic_types:\n            self.register_type(BaseSendable)\n            self.register_type(IntegerSendable)\n            self.register_type(BooleanSendable)\n            self.register_type(StringSendable)\n            self.register_type(FloatSendable)\n            self.register_type(AnyListSendable)\n            self.register_type(DictSendable)\n            self.register_type(ControlConsoleSendable)\n\n    @property\n    def host(self):\n        return self._host\n\n    @host.setter\n    def host(self, value: str):\n        self._host = value\n        if self.is_connected():\n            self.disconnect()\n            self.connect()\n\n    @property\n    def port(self):\n        return self._port\n\n    @port.setter\n    def port(self, value: str):\n        self._port = value\n        if self.is_connected():\n            self.disconnect()\n            self.connect()\n\n    def get_latency(self) -&gt; float:\n        return self.websocket.latency if self.websocket else float(\"inf\")\n\n    def register_type(self, data_type: type[BaseSendable]):\n        self.data_types[data_type.model_fields[\"data_id\"].default] = data_type\n        self.logger.debug(\n            f\"Registered data type of id {data_type.model_fields['data_id'].default} as {data_type.__name__}\"\n        )\n\n    def connect(self) -&gt; None:\n        \"\"\"Starts the client in a background thread.\"\"\"\n        if self.running:\n            self.logger.warning(\"Client is already running\")\n            return\n\n        self.running = True\n        self.thread = threading.Thread(\n            target=self._run_async_loop, daemon=True, name=\"KevinbotLib.CommClient.AsyncLoop\"\n        )\n        self.thread.start()\n\n    def wait_until_connected(self, timeout: float = 5.0):\n        start_time = time.time()\n        while not self.websocket:\n            if time.time() &gt; start_time + timeout:\n                msg = \"The connection timed out\"\n                raise kevinbotlib.exceptions.HandshakeTimeoutException(msg)\n            time.sleep(0.02)\n\n    def is_connected(self):\n        return bool(self.websocket)\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Stops the client and closes the connection gracefully.\"\"\"\n        self.running = False\n        if self.loop and self.loop.is_running():\n            asyncio.run_coroutine_threadsafe(self._close_connection(), self.loop)\n\n    def _run_async_loop(self) -&gt; None:\n        \"\"\"Runs the async event loop in a separate thread.\"\"\"\n        asyncio.set_event_loop(self.loop)\n        if not self.loop.is_running():\n            self.loop.run_until_complete(self._connect_and_listen())\n        else:\n            asyncio.run_coroutine_threadsafe(self._connect_and_listen(), self.loop)\n\n    async def _connect_and_listen(self) -&gt; None:\n        \"\"\"Handles connection and message listening.\"\"\"\n        while self.running:\n            try:\n                async with websockets.connect(\n                    f\"ws://{self._host}:{self._port}\", max_size=2**48 - 1, ping_interval=1\n                ) as ws:\n                    self.websocket = ws\n                    self.logger.info(\"Connected to the server\")\n                    if self.on_connect:\n                        self.on_connect()\n                    await self._handle_messages()\n            except (websockets.ConnectionClosed, ConnectionError, OSError) as e:\n                self.logger.error(f\"Unexpected error: {e!r}\")\n                self.websocket = None\n                if self.auto_reconnect and self.running:\n                    self.logger.warning(\"Can't connect to server, retrying...\")\n                    await asyncio.sleep(1)\n                else:\n                    break\n\n    async def _handle_messages(self) -&gt; None:\n        \"\"\"Processes incoming messages.\"\"\"\n        if not self.websocket:\n            return\n        try:\n            async for message in self.websocket:\n                data = orjson.loads(message)\n\n                if data[\"action\"] == \"sync\":\n                    self.data_store = data[\"data\"]\n                elif data[\"action\"] == \"update\":\n                    key, value = data[\"key\"], data[\"data\"]\n                    self.data_store[key] = value\n                    if self.on_update:\n                        self.on_update(key, value)\n                elif data[\"action\"] == \"delete\":\n                    key = data[\"key\"]\n                    self.data_store.pop(key, None)\n                    if self.on_delete:\n                        self.on_delete(key)\n        except orjson.JSONDecodeError as e:\n            self.logger.error(f\"Error processing messages: {e}\")\n\n    async def _close_connection(self) -&gt; None:\n        \"\"\"Closes the WebSocket connection.\"\"\"\n        if self.websocket:\n            await self.websocket.close()\n            self.logger.info(\"Connection closed\")\n            if self.on_disconnect:\n                self.on_disconnect()\n            self.websocket = None\n\n    def send(self, key: str, data: BaseSendable | SendableGenerator) -&gt; None:\n        \"\"\"Publishes data to the server.\"\"\"\n        if not self.running or not self.websocket:\n            self.logger.error(f\"Cannot publish to {key}: client is not connected\")\n            return\n\n        if isinstance(data, SendableGenerator):\n            data = data.generate_sendable()\n\n        async def _publish() -&gt; None:\n            if not self.websocket:\n                return\n            message = orjson.dumps({\"action\": \"publish\", \"key\": key, \"data\": data.get_dict()})\n            await self.websocket.send(message)\n\n        asyncio.run_coroutine_threadsafe(_publish(), self.loop)\n\n    def get(self, key: str, data_type: type[T], default: Any = None) -&gt; T | None:\n        \"\"\"Retrieves stored data.\"\"\"\n        if key not in self.data_store:\n            return None\n        if self.data_store.get(key, default)[\"data\"][\"did\"] != data_type.model_fields[\"data_id\"].default:\n            self.logger.error(\n                f\"Couldn't get value of {key}, requested value of id {data_type.model_fields['data_id'].default}, got one of {self.data_store.get(key, default)['data']['did']}\"\n            )\n            return None\n\n        return data_type(**self.data_store.get(key, default)[\"data\"])\n\n    def get_raw(self, key: str) -&gt; dict | None:\n        if key not in self.data_store:\n            return None\n\n        return self.data_store.get(key, None)[\"data\"]\n\n    def get_keys(self):\n        return list(self.data_store.keys())\n\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Deletes data from the server.\"\"\"\n        if not self.running or not self.websocket:\n            self.logger.error(\"Cannot delete: client is not connected\")\n            return\n\n        async def _delete() -&gt; None:\n            if not self.websocket:\n                return\n            message = orjson.dumps({\"action\": \"delete\", \"key\": key})\n            await self.websocket.send(message)\n\n        asyncio.run_coroutine_threadsafe(_delete(), self.loop)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.connect","title":"<code>connect()</code>","text":"<p>Starts the client in a background thread.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def connect(self) -&gt; None:\n    \"\"\"Starts the client in a background thread.\"\"\"\n    if self.running:\n        self.logger.warning(\"Client is already running\")\n        return\n\n    self.running = True\n    self.thread = threading.Thread(\n        target=self._run_async_loop, daemon=True, name=\"KevinbotLib.CommClient.AsyncLoop\"\n    )\n    self.thread.start()\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.disconnect","title":"<code>disconnect()</code>","text":"<p>Stops the client and closes the connection gracefully.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Stops the client and closes the connection gracefully.\"\"\"\n    self.running = False\n    if self.loop and self.loop.is_running():\n        asyncio.run_coroutine_threadsafe(self._close_connection(), self.loop)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient._run_async_loop","title":"<code>_run_async_loop()</code>","text":"<p>Runs the async event loop in a separate thread.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def _run_async_loop(self) -&gt; None:\n    \"\"\"Runs the async event loop in a separate thread.\"\"\"\n    asyncio.set_event_loop(self.loop)\n    if not self.loop.is_running():\n        self.loop.run_until_complete(self._connect_and_listen())\n    else:\n        asyncio.run_coroutine_threadsafe(self._connect_and_listen(), self.loop)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient._connect_and_listen","title":"<code>_connect_and_listen()</code>  <code>async</code>","text":"<p>Handles connection and message listening.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def _connect_and_listen(self) -&gt; None:\n    \"\"\"Handles connection and message listening.\"\"\"\n    while self.running:\n        try:\n            async with websockets.connect(\n                f\"ws://{self._host}:{self._port}\", max_size=2**48 - 1, ping_interval=1\n            ) as ws:\n                self.websocket = ws\n                self.logger.info(\"Connected to the server\")\n                if self.on_connect:\n                    self.on_connect()\n                await self._handle_messages()\n        except (websockets.ConnectionClosed, ConnectionError, OSError) as e:\n            self.logger.error(f\"Unexpected error: {e!r}\")\n            self.websocket = None\n            if self.auto_reconnect and self.running:\n                self.logger.warning(\"Can't connect to server, retrying...\")\n                await asyncio.sleep(1)\n            else:\n                break\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient._handle_messages","title":"<code>_handle_messages()</code>  <code>async</code>","text":"<p>Processes incoming messages.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def _handle_messages(self) -&gt; None:\n    \"\"\"Processes incoming messages.\"\"\"\n    if not self.websocket:\n        return\n    try:\n        async for message in self.websocket:\n            data = orjson.loads(message)\n\n            if data[\"action\"] == \"sync\":\n                self.data_store = data[\"data\"]\n            elif data[\"action\"] == \"update\":\n                key, value = data[\"key\"], data[\"data\"]\n                self.data_store[key] = value\n                if self.on_update:\n                    self.on_update(key, value)\n            elif data[\"action\"] == \"delete\":\n                key = data[\"key\"]\n                self.data_store.pop(key, None)\n                if self.on_delete:\n                    self.on_delete(key)\n    except orjson.JSONDecodeError as e:\n        self.logger.error(f\"Error processing messages: {e}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient._close_connection","title":"<code>_close_connection()</code>  <code>async</code>","text":"<p>Closes the WebSocket connection.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>async def _close_connection(self) -&gt; None:\n    \"\"\"Closes the WebSocket connection.\"\"\"\n    if self.websocket:\n        await self.websocket.close()\n        self.logger.info(\"Connection closed\")\n        if self.on_disconnect:\n            self.on_disconnect()\n        self.websocket = None\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.send","title":"<code>send(key, data)</code>","text":"<p>Publishes data to the server.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def send(self, key: str, data: BaseSendable | SendableGenerator) -&gt; None:\n    \"\"\"Publishes data to the server.\"\"\"\n    if not self.running or not self.websocket:\n        self.logger.error(f\"Cannot publish to {key}: client is not connected\")\n        return\n\n    if isinstance(data, SendableGenerator):\n        data = data.generate_sendable()\n\n    async def _publish() -&gt; None:\n        if not self.websocket:\n            return\n        message = orjson.dumps({\"action\": \"publish\", \"key\": key, \"data\": data.get_dict()})\n        await self.websocket.send(message)\n\n    asyncio.run_coroutine_threadsafe(_publish(), self.loop)\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.get","title":"<code>get(key, data_type, default=None)</code>","text":"<p>Retrieves stored data.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def get(self, key: str, data_type: type[T], default: Any = None) -&gt; T | None:\n    \"\"\"Retrieves stored data.\"\"\"\n    if key not in self.data_store:\n        return None\n    if self.data_store.get(key, default)[\"data\"][\"did\"] != data_type.model_fields[\"data_id\"].default:\n        self.logger.error(\n            f\"Couldn't get value of {key}, requested value of id {data_type.model_fields['data_id'].default}, got one of {self.data_store.get(key, default)['data']['did']}\"\n        )\n        return None\n\n    return data_type(**self.data_store.get(key, default)[\"data\"])\n</code></pre>"},{"location":"reference/#kevinbotlib.comm.KevinbotCommClient.delete","title":"<code>delete(key)</code>","text":"<p>Deletes data from the server.</p> Source code in <code>src/kevinbotlib/comm.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Deletes data from the server.\"\"\"\n    if not self.running or not self.websocket:\n        self.logger.error(\"Cannot delete: client is not connected\")\n        return\n\n    async def _delete() -&gt; None:\n        if not self.websocket:\n            return\n        message = orjson.dumps({\"action\": \"delete\", \"key\": key})\n        await self.websocket.send(message)\n\n    asyncio.run_coroutine_threadsafe(_delete(), self.loop)\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Synchronous command interface that users will implement</p> Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>class Command(ABC):\n    \"\"\"Synchronous command interface that users will implement\"\"\"\n\n    @abstractmethod\n    def init(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def execute(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def end(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def finished(self) -&gt; bool:\n        return False\n\n    def then(self, next_command: \"Command\"):\n        \"\"\"Chain commands to run sequentially\"\"\"\n        commands = self.startup_commands if isinstance(self, SequentialCommand) else [self]\n        commands.append(next_command)\n        return SequentialCommand(commands)\n\n    def alongside(self, next_command: \"Command\"):\n        \"\"\"Chain commands to run sequentially\"\"\"\n        commands = self.startup_commands if isinstance(self, ParallelCommand) else [self]\n        commands.append(next_command)\n        return ParallelCommand(commands)\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler.Command.then","title":"<code>then(next_command)</code>","text":"<p>Chain commands to run sequentially</p> Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>def then(self, next_command: \"Command\"):\n    \"\"\"Chain commands to run sequentially\"\"\"\n    commands = self.startup_commands if isinstance(self, SequentialCommand) else [self]\n    commands.append(next_command)\n    return SequentialCommand(commands)\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler.Command.alongside","title":"<code>alongside(next_command)</code>","text":"<p>Chain commands to run sequentially</p> Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>def alongside(self, next_command: \"Command\"):\n    \"\"\"Chain commands to run sequentially\"\"\"\n    commands = self.startup_commands if isinstance(self, ParallelCommand) else [self]\n    commands.append(next_command)\n    return ParallelCommand(commands)\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler.CommandScheduler","title":"<code>CommandScheduler</code>","text":"Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>class CommandScheduler:\n    instance: Self | None = None\n\n    def __init__(self) -&gt; None:\n        if CommandScheduler.instance:\n            msg = \"Another instance of CommandScheduler is running\"\n            raise CommandSchedulerAlreadyExistsException(msg)\n\n        self._scheduled: list[_ScheduledCommand] = []\n        self._triggers: list[Trigger] = []\n\n    def get_instance(self):\n        if CommandScheduler.instance:\n            return CommandScheduler.instance\n        raise CommandSchedulerDoesNotExistException\n\n    def schedule(self, command: Command):\n        self._schedule(command, None)\n\n    def register_trigger(self, trigger: Trigger):\n        self._triggers.append(trigger)\n\n    def _schedule(self, command: Command, trigger: Trigger | None):\n        self._scheduled.append({\"command\": command, \"trigger\": trigger, \"has_init\": False})\n\n    def iterate(self):\n        \"\"\"\n        Executes one iteration of the command scheduler, processing all scheduled commands\n        and their triggers according to their current state and conditions.\n        \"\"\"\n        # Get trigger states, determine if command should be run\n        for trigger in self._triggers:\n            current_state, state_changed = trigger.check()\n\n            if current_state and state_changed and trigger.actions.on_true:\n                self._schedule(trigger.actions.on_true, trigger)\n\n            if not current_state and state_changed and trigger.actions.on_false:\n                self._schedule(trigger.actions.on_false, trigger)\n\n            if (\n                current_state\n                and trigger.actions.while_true\n                and state_changed\n                and not any(scheduled[\"command\"] is trigger.actions.while_true for scheduled in self._scheduled)\n            ):\n                self._schedule(trigger.actions.while_true, trigger)\n\n            if (\n                not current_state\n                and trigger.actions.while_false\n                and state_changed\n                and not any(scheduled[\"command\"] is trigger.actions.while_false for scheduled in self._scheduled)\n            ):\n                self._schedule(trigger.actions.while_false, trigger)\n\n        # Process all scheduled commands\n        i = 0\n        while i &lt; len(self._scheduled):\n            scheduled = self._scheduled[i]\n            command = scheduled[\"command\"]\n            trigger = scheduled[\"trigger\"]\n\n            # Initialize command if not already initialized\n            if not scheduled[\"has_init\"]:\n                command.init()\n                scheduled[\"has_init\"] = True\n\n            # Check if trigger conditions are still satisfied for while_* commands\n            if trigger:\n                current_state, _ = trigger.check()\n                is_while_command = (trigger.actions.while_true is command and not current_state) or (\n                    trigger.actions.while_false is command and current_state\n                )\n                if is_while_command:\n                    # End and remove the command if trigger conditions are no longer satisfied\n                    command.end()\n                    self._scheduled.pop(i)\n                    continue\n\n            # Execute command\n            command.execute()\n\n            # Check if command is finished\n            if command.finished():\n                command.end()\n                self._scheduled.pop(i)\n            else:\n                i += 1\n</code></pre>"},{"location":"reference/#kevinbotlib.scheduler.CommandScheduler.iterate","title":"<code>iterate()</code>","text":"<p>Executes one iteration of the command scheduler, processing all scheduled commands and their triggers according to their current state and conditions.</p> Source code in <code>src/kevinbotlib/scheduler.py</code> <pre><code>def iterate(self):\n    \"\"\"\n    Executes one iteration of the command scheduler, processing all scheduled commands\n    and their triggers according to their current state and conditions.\n    \"\"\"\n    # Get trigger states, determine if command should be run\n    for trigger in self._triggers:\n        current_state, state_changed = trigger.check()\n\n        if current_state and state_changed and trigger.actions.on_true:\n            self._schedule(trigger.actions.on_true, trigger)\n\n        if not current_state and state_changed and trigger.actions.on_false:\n            self._schedule(trigger.actions.on_false, trigger)\n\n        if (\n            current_state\n            and trigger.actions.while_true\n            and state_changed\n            and not any(scheduled[\"command\"] is trigger.actions.while_true for scheduled in self._scheduled)\n        ):\n            self._schedule(trigger.actions.while_true, trigger)\n\n        if (\n            not current_state\n            and trigger.actions.while_false\n            and state_changed\n            and not any(scheduled[\"command\"] is trigger.actions.while_false for scheduled in self._scheduled)\n        ):\n            self._schedule(trigger.actions.while_false, trigger)\n\n    # Process all scheduled commands\n    i = 0\n    while i &lt; len(self._scheduled):\n        scheduled = self._scheduled[i]\n        command = scheduled[\"command\"]\n        trigger = scheduled[\"trigger\"]\n\n        # Initialize command if not already initialized\n        if not scheduled[\"has_init\"]:\n            command.init()\n            scheduled[\"has_init\"] = True\n\n        # Check if trigger conditions are still satisfied for while_* commands\n        if trigger:\n            current_state, _ = trigger.check()\n            is_while_command = (trigger.actions.while_true is command and not current_state) or (\n                trigger.actions.while_false is command and current_state\n            )\n            if is_while_command:\n                # End and remove the command if trigger conditions are no longer satisfied\n                command.end()\n                self._scheduled.pop(i)\n                continue\n\n        # Execute command\n        command.execute()\n\n        # Check if command is finished\n        if command.finished():\n            command.end()\n            self._scheduled.pop(i)\n        else:\n            i += 1\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameEncoders","title":"<code>FrameEncoders</code>","text":"<p>Encoders from OpenCV Mats to Base64</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class FrameEncoders:\n    \"\"\"\n    Encoders from OpenCV Mats to Base64\n    \"\"\"\n\n    @staticmethod\n    def encode_sendable_jpg(frame: MatLike, quality: int = 80) -&gt; SingleFrameSendable:\n        _, buffer = cv2.imencode(\".jpg\", frame, [cv2.IMWRITE_JPEG_QUALITY, quality])\n        return SingleFrameSendable(value=base64.b64encode(buffer), encoding=\"JPG\")\n\n    @staticmethod\n    def encode_sendable_png(frame: MatLike, compression: int = 3) -&gt; SingleFrameSendable:\n        _, buffer = cv2.imencode(\".png\", frame, [cv2.IMWRITE_PNG_COMPRESSION, compression])\n        return SingleFrameSendable(value=base64.b64encode(buffer), encoding=\"PNG\")\n\n    @staticmethod\n    def encode_jpg(frame: MatLike, quality: int = 80) -&gt; bytes:\n        _, buffer = cv2.imencode(\".jpg\", frame, [cv2.IMWRITE_JPEG_QUALITY, quality])\n        return base64.b64encode(buffer)\n\n    @staticmethod\n    def encode_png(frame: MatLike, compression: int = 3) -&gt; bytes:\n        _, buffer = cv2.imencode(\".png\", frame, [cv2.IMWRITE_PNG_COMPRESSION, compression])\n        return base64.b64encode(buffer)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.FrameDecoders","title":"<code>FrameDecoders</code>","text":"<p>Decoders from Base64 to OpenCV Mats</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class FrameDecoders:\n    \"\"\"\n    Decoders from Base64 to OpenCV Mats\n    \"\"\"\n\n    @staticmethod\n    def decode_sendable(sendable: SingleFrameSendable) -&gt; MatLike:\n        buffer = base64.b64decode(sendable.value)\n        if sendable.encoding == \"JPG\":\n            return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_COLOR)\n        if sendable.encoding == \"PNG\":\n            return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_UNCHANGED)\n        msg = f\"Unsupported encoding: {sendable.encoding}\"\n        raise ValueError(msg)\n\n    @staticmethod\n    def decode_base64(data: str, encoding: str) -&gt; MatLike:\n        buffer = base64.b64decode(data)\n        if encoding == \"JPG\":\n            return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_COLOR)\n        if encoding == \"PNG\":\n            return cv2.imdecode(np.frombuffer(buffer, np.uint8), cv2.IMREAD_UNCHANGED)\n        msg = f\"Unsupported encoding: {encoding}\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.BaseCamera","title":"<code>BaseCamera</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for creating Vision Cameras</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class BaseCamera(ABC):\n    \"\"\"Abstract class for creating Vision Cameras\"\"\"\n\n    @abstractmethod\n    def get_frame(self) -&gt; tuple[bool, MatLike]:\n        pass\n\n    @abstractmethod\n    def set_resolution(self, width: int, height: int) -&gt; None:\n        pass\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.CameraByIndex","title":"<code>CameraByIndex</code>","text":"<p>               Bases: <code>BaseCamera</code></p> <p>Create an OpenCV camera from a device index</p> <p>Not recommended if you have more than one camera on a system</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class CameraByIndex(BaseCamera):\n    \"\"\"Create an OpenCV camera from a device index\n\n    Not recommended if you have more than one camera on a system\n    \"\"\"\n\n    def __init__(self, index: int):\n        self.capture = cv2.VideoCapture(index)\n        self.capture.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter.fourcc(*\"MJPG\"))\n        self.capture.set(cv2.CAP_PROP_FPS, 60)\n\n    def get_frame(self) -&gt; tuple[bool, MatLike]:\n        return self.capture.read()\n\n    def set_resolution(self, width: int, height: int) -&gt; None:\n        self.capture.set(cv2.CAP_PROP_FRAME_WIDTH, width)\n        self.capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height)\n</code></pre>"},{"location":"reference/#kevinbotlib.vision.CameraByDevicePath","title":"<code>CameraByDevicePath</code>","text":"<p>               Bases: <code>BaseCamera</code></p> <p>Create an OpenCV camera from a device path</p> Source code in <code>src/kevinbotlib/vision.py</code> <pre><code>class CameraByDevicePath(BaseCamera):\n    \"\"\"Create an OpenCV camera from a device path\"\"\"\n\n    def __init__(self, path: str):\n        self.capture = cv2.VideoCapture(path)\n\n    def get_frame(self) -&gt; tuple[bool, MatLike]:\n        return self.capture.read()\n\n    def set_resolution(self, width: int, height: int) -&gt; None:\n        self.capture.set(cv2.CAP_PROP_FRAME_WIDTH, width)\n        self.capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.XboxControllerAxis","title":"<code>XboxControllerAxis</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Axis identifiers for Xbox controller.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class XboxControllerAxis(IntEnum):\n    \"\"\"Axis identifiers for Xbox controller.\"\"\"\n\n    LeftX = 0\n    LeftY = 1\n    RightX = 3\n    RightY = 4\n    LeftTrigger = 2\n    RightTrigger = 5\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.POVDirection","title":"<code>POVDirection</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>D-pad directions in degrees.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class POVDirection(IntEnum):\n    \"\"\"D-pad directions in degrees.\"\"\"\n\n    UP = 0\n    UP_RIGHT = 45\n    RIGHT = 90\n    DOWN_RIGHT = 135\n    DOWN = 180\n    DOWN_LEFT = 225\n    LEFT = 270\n    UP_LEFT = 315\n    NONE = -1\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalJoystickIdentifiers","title":"<code>LocalJoystickIdentifiers</code>","text":"<p>Static class to handle joystick identification queries.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class LocalJoystickIdentifiers:\n    \"\"\"Static class to handle joystick identification queries.\"\"\"\n\n    @staticmethod\n    def get_count() -&gt; int:\n        \"\"\"Returns the number of connected joysticks.\"\"\"\n        sdl2.SDL_JoystickUpdate()\n        return sdl2.SDL_NumJoysticks()\n\n    @staticmethod\n    def get_names() -&gt; dict[int, str]:\n        \"\"\"Returns a dictionary of joystick indices and their corresponding names.\"\"\"\n        sdl2.SDL_JoystickUpdate()\n        num_joysticks = sdl2.SDL_NumJoysticks()\n        joystick_names = {}\n        for index in range(num_joysticks):\n            joystick_names[index] = sdl2.SDL_JoystickNameForIndex(index).decode(\"utf-8\")\n        return joystick_names\n\n    @staticmethod\n    def get_guids() -&gt; dict[int, bytes]:\n        \"\"\"Returns a dictionary of joystick indices and their corresponding GUIDs.\"\"\"\n        sdl2.SDL_JoystickUpdate()\n        num_joysticks = sdl2.SDL_NumJoysticks()\n        joystick_guids = {}\n        for index in range(num_joysticks):\n            joystick_guids[index] = bytes(sdl2.SDL_JoystickGetGUID(sdl2.SDL_JoystickOpen(index)).data)\n        return joystick_guids\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalJoystickIdentifiers.get_count","title":"<code>get_count()</code>  <code>staticmethod</code>","text":"<p>Returns the number of connected joysticks.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>@staticmethod\ndef get_count() -&gt; int:\n    \"\"\"Returns the number of connected joysticks.\"\"\"\n    sdl2.SDL_JoystickUpdate()\n    return sdl2.SDL_NumJoysticks()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalJoystickIdentifiers.get_names","title":"<code>get_names()</code>  <code>staticmethod</code>","text":"<p>Returns a dictionary of joystick indices and their corresponding names.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>@staticmethod\ndef get_names() -&gt; dict[int, str]:\n    \"\"\"Returns a dictionary of joystick indices and their corresponding names.\"\"\"\n    sdl2.SDL_JoystickUpdate()\n    num_joysticks = sdl2.SDL_NumJoysticks()\n    joystick_names = {}\n    for index in range(num_joysticks):\n        joystick_names[index] = sdl2.SDL_JoystickNameForIndex(index).decode(\"utf-8\")\n    return joystick_names\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalJoystickIdentifiers.get_guids","title":"<code>get_guids()</code>  <code>staticmethod</code>","text":"<p>Returns a dictionary of joystick indices and their corresponding GUIDs.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>@staticmethod\ndef get_guids() -&gt; dict[int, bytes]:\n    \"\"\"Returns a dictionary of joystick indices and their corresponding GUIDs.\"\"\"\n    sdl2.SDL_JoystickUpdate()\n    num_joysticks = sdl2.SDL_NumJoysticks()\n    joystick_guids = {}\n    for index in range(num_joysticks):\n        joystick_guids[index] = bytes(sdl2.SDL_JoystickGetGUID(sdl2.SDL_JoystickOpen(index)).data)\n    return joystick_guids\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice","title":"<code>RawLocalJoystickDevice</code>","text":"<p>               Bases: <code>AbstractJoystickInterface</code></p> <p>Gamepad-agnostic polling and event-based joystick input with disconnect detection.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class RawLocalJoystickDevice(AbstractJoystickInterface):\n    \"\"\"Gamepad-agnostic polling and event-based joystick input with disconnect detection.\"\"\"\n\n    def __init__(self, index: int, polling_hz: int = 100):\n        self.index = index\n        self._sdl_joystick: sdl2.joystick.SDL_Joystick = sdl2.SDL_JoystickOpen(index)\n        self._logger = _Logger()\n\n        if not self._sdl_joystick:\n            msg = f\"No joystick of index {index} present\"\n            raise JoystickMissingException(msg)\n\n        self._logger.info(f\"Init joystick {index} of name: {sdl2.SDL_JoystickName(self._sdl_joystick).decode('utf-8')}\")\n        self._logger.info(\n            f\"Init joystick {index} of GUID: {''.join(f'{b:02x}' for b in sdl2.SDL_JoystickGetGUID(self._sdl_joystick).data)}\"\n        )\n\n        self.running = False\n        self.connected = False\n        self.polling_hz = polling_hz\n        self._button_states = {}\n        self._button_callbacks = {}\n        self._pov_state = POVDirection.NONE\n        self._pov_callbacks: list[Callable[[POVDirection], Any]] = []\n        self._axis_states = {}\n        self._axis_callbacks = {}\n\n        self.on_disconnect: Callable[[], Any] | None = None\n\n        num_axes = sdl2.SDL_JoystickNumAxes(self._sdl_joystick)\n        for i in range(num_axes):\n            self._axis_states[i] = 0.0\n\n    def is_connected(self) -&gt; bool:\n        return self.connected\n\n    def get_button_state(self, button_id: int) -&gt; bool:\n        \"\"\"Returns the state of a button (pressed: True, released: False).\"\"\"\n        return self._button_states.get(button_id, False)\n\n    def get_axis_value(self, axis_id: int, precision: int = 3) -&gt; float:\n        \"\"\"Returns the current value of the specified axis (-1.0 to 1.0).\"\"\"\n        return round(max(min(self._axis_states.get(axis_id, 0.0), 1), -1), precision)\n\n    def get_buttons(self) -&gt; list[int]:\n        \"\"\"Returns a list of currently pressed buttons.\"\"\"\n        buttons = [key for key, value in self._button_states.items() if value]\n        buttons.sort()\n        return buttons\n\n    def get_axes(self, precision: int = 3):\n        return [round(float(max(min(self._axis_states[axis_id], 1), -1)), precision) for axis_id in self._axis_states]\n\n    def get_pov_direction(self) -&gt; POVDirection:\n        \"\"\"Returns the current POV (D-pad) direction.\"\"\"\n        return self._pov_state\n\n    def register_button_callback(self, button_id: int, callback: Callable[[bool], Any]) -&gt; None:\n        \"\"\"Registers a callback function for button press/release events.\"\"\"\n        self._button_callbacks[button_id] = callback\n\n    def register_pov_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n        \"\"\"Registers a callback function for POV (D-pad) direction changes.\"\"\"\n        self._pov_callbacks.append(callback)\n\n    def _handle_event(self, event) -&gt; None:\n        \"\"\"Handles SDL events and triggers registered callbacks.\"\"\"\n        if event.type == sdl2.SDL_JOYBUTTONDOWN:\n            button = event.jbutton.button\n            self._button_states[button] = True\n            if button in self._button_callbacks:\n                self._button_callbacks[button](True)\n\n        elif event.type == sdl2.SDL_JOYBUTTONUP:\n            button = event.jbutton.button\n            self._button_states[button] = False\n            if button in self._button_callbacks:\n                self._button_callbacks[button](False)\n\n        elif event.type == sdl2.SDL_JOYHATMOTION:\n            # Convert SDL hat values to angles\n            hat_value = event.jhat.value\n            new_direction = self._convert_hat_to_direction(hat_value)\n\n            if new_direction != self._pov_state:\n                self._pov_state = new_direction\n                for callback in self._pov_callbacks:\n                    callback(new_direction)\n\n        elif event.type == sdl2.SDL_JOYAXISMOTION:\n            axis = event.jaxis.axis\n            # Convert SDL axis value (-32768 to 32767) to float (-1.0 to 1.0)\n            value = event.jaxis.value / 32767.0\n\n            # For triggers, convert range from [-1.0, 1.0] to [0.0, 1.0]\n            if axis in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n                value = (value + 1.0) / 2.0\n\n            # Update state and trigger callback if value changed significantly\n            self._axis_states[axis] = value\n            if axis in self._axis_callbacks:\n                self._axis_callbacks[axis](value)\n\n    @staticmethod\n    def _convert_hat_to_direction(hat_value: int) -&gt; POVDirection:\n        \"\"\"Converts SDL hat value to POVDirection enum.\"\"\"\n        hat_to_direction = {\n            0x00: POVDirection.NONE,  # centered\n            0x01: POVDirection.UP,  # up\n            0x02: POVDirection.RIGHT,  # right\n            0x04: POVDirection.DOWN,  # down\n            0x08: POVDirection.LEFT,  # left\n            0x03: POVDirection.UP_RIGHT,  # up + right\n            0x06: POVDirection.DOWN_RIGHT,  # down + right\n            0x0C: POVDirection.DOWN_LEFT,  # down + left\n            0x09: POVDirection.UP_LEFT,  # up + left\n        }\n        return hat_to_direction.get(hat_value, POVDirection.NONE)\n\n    def _event_loop(self):\n        \"\"\"Internal loop for processing SDL events synchronously.\"\"\"\n        while self.running:\n            if not sdl2.SDL_JoystickGetAttached(self._sdl_joystick):\n                self.connected = False\n                for key in self._axis_states:\n                    self._axis_states[key] = 0.0\n\n                self._button_states = {}\n                self._pov_state = POVDirection.NONE\n                self._handle_disconnect()\n                self._logger.debug(f\"Polling paused, controller {self.index} is disconnected\")\n            else:\n                self.connected = True\n\n            events = sdl2.ext.get_events()\n            for event in events:\n                if event.type == sdl2.SDL_QUIT:\n                    self.running = False\n                    break\n                self._handle_event(event)\n\n            time.sleep(1 / self.polling_hz)\n\n    def _check_connection(self):\n        \"\"\"Thread to monitor joystick connection state.\"\"\"\n        while self.running:\n            if not sdl2.SDL_JoystickGetAttached(self._sdl_joystick):\n                self._handle_disconnect()\n                return\n            time.sleep(0.5)\n\n    def _handle_disconnect(self):\n        \"\"\"Handles joystick disconnection.\"\"\"\n        self._logger.warning(f\"Joystick {self.index} disconnected.\")\n        if self.on_disconnect:\n            self.on_disconnect()\n        self._attempt_reconnect()\n\n    def _attempt_reconnect(self):\n        \"\"\"Attempts to reconnect the joystick.\"\"\"\n        self._logger.info(\"Attempting to reconnect...\")\n\n        self.connected = False\n        time.sleep(1)\n\n        num_joysticks = sdl2.SDL_NumJoysticks()\n        if self.index &lt; num_joysticks:\n            self._sdl_joystick = sdl2.SDL_JoystickOpen(self.index)\n            if self._sdl_joystick and sdl2.SDL_JoystickGetAttached(self._sdl_joystick):\n                self._logger.info(f\"Reconnected joystick {self.index} successfully\")\n                return\n\n        time.sleep(1)\n\n    def start_polling(self):\n        \"\"\"Starts the polling loop in a separate thread.\"\"\"\n        if not self.running:\n            self.running = True\n            threading.Thread(\n                target=self._event_loop, daemon=True, name=f\"KevinbotLib.Joystick.EvLoop.{self.index}\"\n            ).start()\n            threading.Thread(\n                target=self._check_connection, daemon=True, name=f\"KevinbotLib.Joystick.ConnCheck.{self.index}\"\n            ).start()\n\n    def stop(self):\n        \"\"\"Stops event handling and releases resources.\"\"\"\n        self.running = False\n        sdl2.SDL_JoystickClose(self._sdl_joystick)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.get_button_state","title":"<code>get_button_state(button_id)</code>","text":"<p>Returns the state of a button (pressed: True, released: False).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_button_state(self, button_id: int) -&gt; bool:\n    \"\"\"Returns the state of a button (pressed: True, released: False).\"\"\"\n    return self._button_states.get(button_id, False)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.get_axis_value","title":"<code>get_axis_value(axis_id, precision=3)</code>","text":"<p>Returns the current value of the specified axis (-1.0 to 1.0).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_axis_value(self, axis_id: int, precision: int = 3) -&gt; float:\n    \"\"\"Returns the current value of the specified axis (-1.0 to 1.0).\"\"\"\n    return round(max(min(self._axis_states.get(axis_id, 0.0), 1), -1), precision)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.get_buttons","title":"<code>get_buttons()</code>","text":"<p>Returns a list of currently pressed buttons.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_buttons(self) -&gt; list[int]:\n    \"\"\"Returns a list of currently pressed buttons.\"\"\"\n    buttons = [key for key, value in self._button_states.items() if value]\n    buttons.sort()\n    return buttons\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.get_pov_direction","title":"<code>get_pov_direction()</code>","text":"<p>Returns the current POV (D-pad) direction.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_pov_direction(self) -&gt; POVDirection:\n    \"\"\"Returns the current POV (D-pad) direction.\"\"\"\n    return self._pov_state\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.register_button_callback","title":"<code>register_button_callback(button_id, callback)</code>","text":"<p>Registers a callback function for button press/release events.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_button_callback(self, button_id: int, callback: Callable[[bool], Any]) -&gt; None:\n    \"\"\"Registers a callback function for button press/release events.\"\"\"\n    self._button_callbacks[button_id] = callback\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.register_pov_callback","title":"<code>register_pov_callback(callback)</code>","text":"<p>Registers a callback function for POV (D-pad) direction changes.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_pov_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n    \"\"\"Registers a callback function for POV (D-pad) direction changes.\"\"\"\n    self._pov_callbacks.append(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice._handle_event","title":"<code>_handle_event(event)</code>","text":"<p>Handles SDL events and triggers registered callbacks.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def _handle_event(self, event) -&gt; None:\n    \"\"\"Handles SDL events and triggers registered callbacks.\"\"\"\n    if event.type == sdl2.SDL_JOYBUTTONDOWN:\n        button = event.jbutton.button\n        self._button_states[button] = True\n        if button in self._button_callbacks:\n            self._button_callbacks[button](True)\n\n    elif event.type == sdl2.SDL_JOYBUTTONUP:\n        button = event.jbutton.button\n        self._button_states[button] = False\n        if button in self._button_callbacks:\n            self._button_callbacks[button](False)\n\n    elif event.type == sdl2.SDL_JOYHATMOTION:\n        # Convert SDL hat values to angles\n        hat_value = event.jhat.value\n        new_direction = self._convert_hat_to_direction(hat_value)\n\n        if new_direction != self._pov_state:\n            self._pov_state = new_direction\n            for callback in self._pov_callbacks:\n                callback(new_direction)\n\n    elif event.type == sdl2.SDL_JOYAXISMOTION:\n        axis = event.jaxis.axis\n        # Convert SDL axis value (-32768 to 32767) to float (-1.0 to 1.0)\n        value = event.jaxis.value / 32767.0\n\n        # For triggers, convert range from [-1.0, 1.0] to [0.0, 1.0]\n        if axis in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n            value = (value + 1.0) / 2.0\n\n        # Update state and trigger callback if value changed significantly\n        self._axis_states[axis] = value\n        if axis in self._axis_callbacks:\n            self._axis_callbacks[axis](value)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice._convert_hat_to_direction","title":"<code>_convert_hat_to_direction(hat_value)</code>  <code>staticmethod</code>","text":"<p>Converts SDL hat value to POVDirection enum.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>@staticmethod\ndef _convert_hat_to_direction(hat_value: int) -&gt; POVDirection:\n    \"\"\"Converts SDL hat value to POVDirection enum.\"\"\"\n    hat_to_direction = {\n        0x00: POVDirection.NONE,  # centered\n        0x01: POVDirection.UP,  # up\n        0x02: POVDirection.RIGHT,  # right\n        0x04: POVDirection.DOWN,  # down\n        0x08: POVDirection.LEFT,  # left\n        0x03: POVDirection.UP_RIGHT,  # up + right\n        0x06: POVDirection.DOWN_RIGHT,  # down + right\n        0x0C: POVDirection.DOWN_LEFT,  # down + left\n        0x09: POVDirection.UP_LEFT,  # up + left\n    }\n    return hat_to_direction.get(hat_value, POVDirection.NONE)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice._event_loop","title":"<code>_event_loop()</code>","text":"<p>Internal loop for processing SDL events synchronously.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def _event_loop(self):\n    \"\"\"Internal loop for processing SDL events synchronously.\"\"\"\n    while self.running:\n        if not sdl2.SDL_JoystickGetAttached(self._sdl_joystick):\n            self.connected = False\n            for key in self._axis_states:\n                self._axis_states[key] = 0.0\n\n            self._button_states = {}\n            self._pov_state = POVDirection.NONE\n            self._handle_disconnect()\n            self._logger.debug(f\"Polling paused, controller {self.index} is disconnected\")\n        else:\n            self.connected = True\n\n        events = sdl2.ext.get_events()\n        for event in events:\n            if event.type == sdl2.SDL_QUIT:\n                self.running = False\n                break\n            self._handle_event(event)\n\n        time.sleep(1 / self.polling_hz)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice._check_connection","title":"<code>_check_connection()</code>","text":"<p>Thread to monitor joystick connection state.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def _check_connection(self):\n    \"\"\"Thread to monitor joystick connection state.\"\"\"\n    while self.running:\n        if not sdl2.SDL_JoystickGetAttached(self._sdl_joystick):\n            self._handle_disconnect()\n            return\n        time.sleep(0.5)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice._handle_disconnect","title":"<code>_handle_disconnect()</code>","text":"<p>Handles joystick disconnection.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def _handle_disconnect(self):\n    \"\"\"Handles joystick disconnection.\"\"\"\n    self._logger.warning(f\"Joystick {self.index} disconnected.\")\n    if self.on_disconnect:\n        self.on_disconnect()\n    self._attempt_reconnect()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice._attempt_reconnect","title":"<code>_attempt_reconnect()</code>","text":"<p>Attempts to reconnect the joystick.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def _attempt_reconnect(self):\n    \"\"\"Attempts to reconnect the joystick.\"\"\"\n    self._logger.info(\"Attempting to reconnect...\")\n\n    self.connected = False\n    time.sleep(1)\n\n    num_joysticks = sdl2.SDL_NumJoysticks()\n    if self.index &lt; num_joysticks:\n        self._sdl_joystick = sdl2.SDL_JoystickOpen(self.index)\n        if self._sdl_joystick and sdl2.SDL_JoystickGetAttached(self._sdl_joystick):\n            self._logger.info(f\"Reconnected joystick {self.index} successfully\")\n            return\n\n    time.sleep(1)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.start_polling","title":"<code>start_polling()</code>","text":"<p>Starts the polling loop in a separate thread.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def start_polling(self):\n    \"\"\"Starts the polling loop in a separate thread.\"\"\"\n    if not self.running:\n        self.running = True\n        threading.Thread(\n            target=self._event_loop, daemon=True, name=f\"KevinbotLib.Joystick.EvLoop.{self.index}\"\n        ).start()\n        threading.Thread(\n            target=self._check_connection, daemon=True, name=f\"KevinbotLib.Joystick.ConnCheck.{self.index}\"\n        ).start()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RawLocalJoystickDevice.stop","title":"<code>stop()</code>","text":"<p>Stops event handling and releases resources.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def stop(self):\n    \"\"\"Stops event handling and releases resources.\"\"\"\n    self.running = False\n    sdl2.SDL_JoystickClose(self._sdl_joystick)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController","title":"<code>LocalXboxController</code>","text":"<p>               Bases: <code>RawLocalJoystickDevice</code></p> <p>Xbox-specific controller with button name mappings.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class LocalXboxController(RawLocalJoystickDevice):\n    \"\"\"Xbox-specific controller with button name mappings.\"\"\"\n\n    def get_button_state(self, button: XboxControllerButtons) -&gt; bool:\n        \"\"\"Returns the state of a button using its friendly name.\"\"\"\n        return super().get_button_state(button)\n\n    def get_buttons(self) -&gt; list[XboxControllerButtons]:\n        return [XboxControllerButtons(x) for x in super().get_buttons()]\n\n    def register_button_callback(self, button: XboxControllerButtons, callback: Callable[[bool], Any]) -&gt; None:\n        \"\"\"Registers a callback using the friendly button name.\"\"\"\n        super().register_button_callback(button, callback)\n\n    def get_dpad_direction(self) -&gt; POVDirection:\n        \"\"\"Returns the current D-pad direction using Xbox terminology.\"\"\"\n        return self.get_pov_direction()\n\n    def get_trigger_value(self, trigger: XboxControllerAxis, precision: int = 3) -&gt; float:\n        \"\"\"Returns the current value of the specified trigger (0.0 to 1.0).\"\"\"\n        if trigger not in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n            msg = \"Invalid trigger specified\"\n            raise ValueError(msg)\n        return max(self.get_axis_value(trigger, precision), 0)\n\n    def get_axis_value(self, axis_id: int, precision: int = 3) -&gt; float:\n        return super().get_axis_value(axis_id, precision)\n\n    def get_triggers(self, precision: int = 3):\n        return [\n            self.get_trigger_value(XboxControllerAxis.LeftTrigger, precision),\n            self.get_trigger_value(XboxControllerAxis.RightTrigger, precision),\n        ]\n\n    def get_left_stick(self, precision: int = 3):\n        return [\n            self.get_axis_value(XboxControllerAxis.LeftX, precision),\n            self.get_axis_value(XboxControllerAxis.LeftY, precision),\n        ]\n\n    def get_right_stick(self, precision: int = 3):\n        return [\n            self.get_axis_value(XboxControllerAxis.RightX, precision),\n            self.get_axis_value(XboxControllerAxis.RightY, precision),\n        ]\n\n    def register_dpad_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n        \"\"\"Registers a callback for D-pad direction changes using Xbox terminology.\"\"\"\n        self.register_pov_callback(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.get_button_state","title":"<code>get_button_state(button)</code>","text":"<p>Returns the state of a button using its friendly name.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_button_state(self, button: XboxControllerButtons) -&gt; bool:\n    \"\"\"Returns the state of a button using its friendly name.\"\"\"\n    return super().get_button_state(button)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.register_button_callback","title":"<code>register_button_callback(button, callback)</code>","text":"<p>Registers a callback using the friendly button name.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_button_callback(self, button: XboxControllerButtons, callback: Callable[[bool], Any]) -&gt; None:\n    \"\"\"Registers a callback using the friendly button name.\"\"\"\n    super().register_button_callback(button, callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.get_dpad_direction","title":"<code>get_dpad_direction()</code>","text":"<p>Returns the current D-pad direction using Xbox terminology.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_dpad_direction(self) -&gt; POVDirection:\n    \"\"\"Returns the current D-pad direction using Xbox terminology.\"\"\"\n    return self.get_pov_direction()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.get_trigger_value","title":"<code>get_trigger_value(trigger, precision=3)</code>","text":"<p>Returns the current value of the specified trigger (0.0 to 1.0).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_trigger_value(self, trigger: XboxControllerAxis, precision: int = 3) -&gt; float:\n    \"\"\"Returns the current value of the specified trigger (0.0 to 1.0).\"\"\"\n    if trigger not in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n        msg = \"Invalid trigger specified\"\n        raise ValueError(msg)\n    return max(self.get_axis_value(trigger, precision), 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.LocalXboxController.register_dpad_callback","title":"<code>register_dpad_callback(callback)</code>","text":"<p>Registers a callback for D-pad direction changes using Xbox terminology.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_dpad_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n    \"\"\"Registers a callback for D-pad direction changes using Xbox terminology.\"\"\"\n    self.register_pov_callback(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice","title":"<code>RemoteRawJoystickDevice</code>","text":"<p>               Bases: <code>AbstractJoystickInterface</code></p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class RemoteRawJoystickDevice(AbstractJoystickInterface):\n    def __init__(self, client: KevinbotCommClient, key: str, callback_polling_hz: int = 100) -&gt; None:\n        super().__init__()\n        self._client: KevinbotCommClient = client\n        self._client_key: str = key.rstrip(\"/\")\n        self.polling_hz = callback_polling_hz\n\n        # Callback storage\n        self._button_callbacks = {}\n        self._pov_callbacks: list[Callable[[POVDirection], Any]] = []\n        self._axis_callbacks = {}\n\n        # State tracking for callback triggering\n        self._last_button_states = {}\n        self._last_pov_state = POVDirection.NONE\n        self._last_axis_states = {}\n\n        self.connected = False\n        self.running = False\n\n        # Start polling thread\n        self.start_polling()\n\n    @property\n    def client(self) -&gt; KevinbotCommClient:\n        return self._client\n\n    @property\n    def key(self) -&gt; str:\n        return self._client_key\n\n    def is_connected(self) -&gt; bool:\n        sendable = self.client.get(f\"{self._client_key}/connected\", BooleanSendable)\n        if not sendable:\n            return False\n        return sendable.value\n\n    def get_button_state(self, button_id: int | Enum | IntEnum) -&gt; bool:\n        sendable = self.client.get(f\"{self._client_key}/buttons\", AnyListSendable)\n        if not sendable:\n            return False\n        return button_id in sendable.value\n\n    def get_axis_value(self, axis_id: int, precision: int = 3) -&gt; float:\n        sendable = self.client.get(f\"{self._client_key}/axes\", AnyListSendable)\n        if not sendable:\n            return 0.0\n        return round(sendable.value[axis_id], precision) if axis_id &lt; len(sendable.value) else 0.0\n\n    def get_buttons(self) -&gt; list[int | Enum | IntEnum]:\n        sendable = self.client.get(f\"{self._client_key}/buttons\", AnyListSendable)\n        if not sendable:\n            return []\n        return sendable.value\n\n    def get_axes(self) -&gt; list[float]:\n        sendable = self.client.get(f\"{self._client_key}/axes\", AnyListSendable)\n        if not sendable:\n            return []\n        return sendable.value\n\n    def get_pov_direction(self) -&gt; POVDirection:\n        sendable = self.client.get(f\"{self._client_key}/pov\", IntegerSendable)\n        if not sendable:\n            return POVDirection.NONE\n        return POVDirection(sendable.value)\n\n    def register_button_callback(self, button_id: int | Enum | IntEnum, callback: Callable[[bool], Any]) -&gt; None:\n        \"\"\"Registers a callback function for button press/release events.\"\"\"\n        self._button_callbacks[button_id] = callback\n\n    def register_pov_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n        \"\"\"Registers a callback function for POV (D-pad) direction changes.\"\"\"\n        self._pov_callbacks.append(callback)\n\n    def _poll_loop(self):\n        \"\"\"Polling loop that checks for state changes and triggers callbacks.\"\"\"\n        while self.running:\n            # Check connection status\n            conn_sendable = self.client.get(f\"{self._client_key}/connected\", BooleanSendable)\n            self.connected = conn_sendable.value if conn_sendable else False\n\n            if self.connected:\n                # Check buttons\n                buttons = self.get_buttons()\n                current_button_states = {btn: True for btn in buttons}\n\n                # Check for button state changes\n                for button in set(self._last_button_states.keys()) | set(current_button_states.keys()):\n                    old_state = self._last_button_states.get(button, False)\n                    new_state = current_button_states.get(button, False)\n\n                    if old_state != new_state and button in self._button_callbacks:\n                        self._button_callbacks[button](new_state)\n\n                self._last_button_states = current_button_states\n\n                # Check POV\n                current_pov = self.get_pov_direction()\n                if current_pov != self._last_pov_state:\n                    for callback in self._pov_callbacks:\n                        callback(current_pov)\n                self._last_pov_state = current_pov\n\n            time.sleep(1 / self.polling_hz)\n\n    def start_polling(self):\n        \"\"\"Starts the polling loop in a separate thread.\"\"\"\n        if not self.running:\n            self.running = True\n            threading.Thread(target=self._poll_loop, daemon=True, name=\"KevinbotLib.Joystick.Remote.Poll\").start()\n\n    def stop(self):\n        \"\"\"Stops the polling thread.\"\"\"\n        self.running = False\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice.register_button_callback","title":"<code>register_button_callback(button_id, callback)</code>","text":"<p>Registers a callback function for button press/release events.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_button_callback(self, button_id: int | Enum | IntEnum, callback: Callable[[bool], Any]) -&gt; None:\n    \"\"\"Registers a callback function for button press/release events.\"\"\"\n    self._button_callbacks[button_id] = callback\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice.register_pov_callback","title":"<code>register_pov_callback(callback)</code>","text":"<p>Registers a callback function for POV (D-pad) direction changes.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_pov_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n    \"\"\"Registers a callback function for POV (D-pad) direction changes.\"\"\"\n    self._pov_callbacks.append(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice._poll_loop","title":"<code>_poll_loop()</code>","text":"<p>Polling loop that checks for state changes and triggers callbacks.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def _poll_loop(self):\n    \"\"\"Polling loop that checks for state changes and triggers callbacks.\"\"\"\n    while self.running:\n        # Check connection status\n        conn_sendable = self.client.get(f\"{self._client_key}/connected\", BooleanSendable)\n        self.connected = conn_sendable.value if conn_sendable else False\n\n        if self.connected:\n            # Check buttons\n            buttons = self.get_buttons()\n            current_button_states = {btn: True for btn in buttons}\n\n            # Check for button state changes\n            for button in set(self._last_button_states.keys()) | set(current_button_states.keys()):\n                old_state = self._last_button_states.get(button, False)\n                new_state = current_button_states.get(button, False)\n\n                if old_state != new_state and button in self._button_callbacks:\n                    self._button_callbacks[button](new_state)\n\n            self._last_button_states = current_button_states\n\n            # Check POV\n            current_pov = self.get_pov_direction()\n            if current_pov != self._last_pov_state:\n                for callback in self._pov_callbacks:\n                    callback(current_pov)\n            self._last_pov_state = current_pov\n\n        time.sleep(1 / self.polling_hz)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice.start_polling","title":"<code>start_polling()</code>","text":"<p>Starts the polling loop in a separate thread.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def start_polling(self):\n    \"\"\"Starts the polling loop in a separate thread.\"\"\"\n    if not self.running:\n        self.running = True\n        threading.Thread(target=self._poll_loop, daemon=True, name=\"KevinbotLib.Joystick.Remote.Poll\").start()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteRawJoystickDevice.stop","title":"<code>stop()</code>","text":"<p>Stops the polling thread.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def stop(self):\n    \"\"\"Stops the polling thread.\"\"\"\n    self.running = False\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController","title":"<code>RemoteXboxController</code>","text":"<p>               Bases: <code>RemoteRawJoystickDevice</code></p> <p>Xbox-specific remote controller with button name mappings.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>class RemoteXboxController(RemoteRawJoystickDevice):\n    \"\"\"Xbox-specific remote controller with button name mappings.\"\"\"\n\n    def __init__(self, client: KevinbotCommClient, key: str, callback_polling_hz: int = 100) -&gt; None:\n        super().__init__(client, key, callback_polling_hz)\n\n    def get_button_state(self, button: XboxControllerButtons) -&gt; bool:\n        \"\"\"Returns the state of a button using its friendly Xbox name.\"\"\"\n        return super().get_button_state(button)\n\n    def get_buttons(self) -&gt; list[XboxControllerButtons]:\n        \"\"\"Returns a list of currently pressed buttons using Xbox button enums.\"\"\"\n        return [XboxControllerButtons(x) for x in super().get_buttons()]\n\n    def get_axes(self, precision: int = 3) -&gt; list[float]:\n        \"\"\"Returns a list of axis values with Xbox-specific ordering.\"\"\"\n        axes = super().get_axes()\n        if not axes:\n            return [0.0] * len(XboxControllerAxis)  # Return default zeroed axes if no data\n        return [round(x, precision) for x in axes]  # Convert to float and apply precision\n\n    def register_button_callback(self, button: XboxControllerButtons, callback: Callable[[bool], Any]) -&gt; None:\n        \"\"\"Registers a callback using the friendly Xbox button name.\"\"\"\n        super().register_button_callback(button, callback)\n\n    def register_dpad_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n        \"\"\"Registers a callback for D-pad direction changes using Xbox terminology.\"\"\"\n        super().register_pov_callback(callback)\n\n    def get_dpad_direction(self) -&gt; POVDirection:\n        \"\"\"Returns the current D-pad direction using Xbox terminology.\"\"\"\n        return super().get_pov_direction()\n\n    def get_trigger_value(self, trigger: XboxControllerAxis, precision: int = 3) -&gt; float:\n        \"\"\"Returns the current value of the specified trigger (0.0 to 1.0).\"\"\"\n        if trigger not in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n            msg = \"Invalid trigger specified\"\n            raise ValueError(msg)\n        value = super().get_axis_value(trigger, precision)\n        return max(value, 0.0)  # Ensure triggers are 0.0 to 1.0\n\n    def get_triggers(self, precision: int = 3) -&gt; list[float]:\n        \"\"\"Returns the current values of both triggers.\"\"\"\n        return [\n            self.get_trigger_value(XboxControllerAxis.LeftTrigger, precision),\n            self.get_trigger_value(XboxControllerAxis.RightTrigger, precision),\n        ]\n\n    def get_left_stick(self, precision: int = 3) -&gt; list[float]:\n        \"\"\"Returns the current values of the left stick (x, y).\"\"\"\n        return [\n            super().get_axis_value(XboxControllerAxis.LeftX, precision),\n            super().get_axis_value(XboxControllerAxis.LeftY, precision),\n        ]\n\n    def get_right_stick(self, precision: int = 3) -&gt; list[float]:\n        \"\"\"Returns the current values of the right stick (x, y).\"\"\"\n        return [\n            super().get_axis_value(XboxControllerAxis.RightX, precision),\n            super().get_axis_value(XboxControllerAxis.RightY, precision),\n        ]\n\n    def _poll_loop(self):\n        \"\"\"Xbox-specific polling loop that checks for state changes and triggers callbacks.\"\"\"\n        while self.running:\n            # Check connection status\n            conn_sendable = self.client.get(f\"{self._client_key}/connected\", BooleanSendable)\n            self.connected = conn_sendable.value if conn_sendable else False\n\n            if self.connected:\n                # Check buttons\n                buttons = self.get_buttons()\n                current_button_states = {btn: True for btn in buttons}\n\n                # Check for button state changes\n                for button in set(self._last_button_states.keys()) | set(current_button_states.keys()):\n                    old_state = self._last_button_states.get(button, False)\n                    new_state = current_button_states.get(button, False)\n\n                    if old_state != new_state and button in self._button_callbacks:\n                        self._button_callbacks[button](new_state)\n\n                self._last_button_states = current_button_states\n\n                # Check POV/D-pad\n                current_pov = self.get_dpad_direction()\n                if current_pov != self._last_pov_state:\n                    for callback in self._pov_callbacks:\n                        callback(current_pov)\n                self._last_pov_state = current_pov\n\n                # Check axes (only update states here, specific methods handle formatting)\n                current_axes = super().get_axes()\n                for axis_id in range(len(current_axes)):\n                    self._last_axis_states[axis_id] = current_axes[axis_id]\n\n            time.sleep(1 / self.polling_hz)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_button_state","title":"<code>get_button_state(button)</code>","text":"<p>Returns the state of a button using its friendly Xbox name.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_button_state(self, button: XboxControllerButtons) -&gt; bool:\n    \"\"\"Returns the state of a button using its friendly Xbox name.\"\"\"\n    return super().get_button_state(button)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_buttons","title":"<code>get_buttons()</code>","text":"<p>Returns a list of currently pressed buttons using Xbox button enums.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_buttons(self) -&gt; list[XboxControllerButtons]:\n    \"\"\"Returns a list of currently pressed buttons using Xbox button enums.\"\"\"\n    return [XboxControllerButtons(x) for x in super().get_buttons()]\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_axes","title":"<code>get_axes(precision=3)</code>","text":"<p>Returns a list of axis values with Xbox-specific ordering.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_axes(self, precision: int = 3) -&gt; list[float]:\n    \"\"\"Returns a list of axis values with Xbox-specific ordering.\"\"\"\n    axes = super().get_axes()\n    if not axes:\n        return [0.0] * len(XboxControllerAxis)  # Return default zeroed axes if no data\n    return [round(x, precision) for x in axes]  # Convert to float and apply precision\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.register_button_callback","title":"<code>register_button_callback(button, callback)</code>","text":"<p>Registers a callback using the friendly Xbox button name.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_button_callback(self, button: XboxControllerButtons, callback: Callable[[bool], Any]) -&gt; None:\n    \"\"\"Registers a callback using the friendly Xbox button name.\"\"\"\n    super().register_button_callback(button, callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.register_dpad_callback","title":"<code>register_dpad_callback(callback)</code>","text":"<p>Registers a callback for D-pad direction changes using Xbox terminology.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def register_dpad_callback(self, callback: Callable[[POVDirection], Any]) -&gt; None:\n    \"\"\"Registers a callback for D-pad direction changes using Xbox terminology.\"\"\"\n    super().register_pov_callback(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_dpad_direction","title":"<code>get_dpad_direction()</code>","text":"<p>Returns the current D-pad direction using Xbox terminology.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_dpad_direction(self) -&gt; POVDirection:\n    \"\"\"Returns the current D-pad direction using Xbox terminology.\"\"\"\n    return super().get_pov_direction()\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_trigger_value","title":"<code>get_trigger_value(trigger, precision=3)</code>","text":"<p>Returns the current value of the specified trigger (0.0 to 1.0).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_trigger_value(self, trigger: XboxControllerAxis, precision: int = 3) -&gt; float:\n    \"\"\"Returns the current value of the specified trigger (0.0 to 1.0).\"\"\"\n    if trigger not in (XboxControllerAxis.LeftTrigger, XboxControllerAxis.RightTrigger):\n        msg = \"Invalid trigger specified\"\n        raise ValueError(msg)\n    value = super().get_axis_value(trigger, precision)\n    return max(value, 0.0)  # Ensure triggers are 0.0 to 1.0\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_triggers","title":"<code>get_triggers(precision=3)</code>","text":"<p>Returns the current values of both triggers.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_triggers(self, precision: int = 3) -&gt; list[float]:\n    \"\"\"Returns the current values of both triggers.\"\"\"\n    return [\n        self.get_trigger_value(XboxControllerAxis.LeftTrigger, precision),\n        self.get_trigger_value(XboxControllerAxis.RightTrigger, precision),\n    ]\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_left_stick","title":"<code>get_left_stick(precision=3)</code>","text":"<p>Returns the current values of the left stick (x, y).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_left_stick(self, precision: int = 3) -&gt; list[float]:\n    \"\"\"Returns the current values of the left stick (x, y).\"\"\"\n    return [\n        super().get_axis_value(XboxControllerAxis.LeftX, precision),\n        super().get_axis_value(XboxControllerAxis.LeftY, precision),\n    ]\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController.get_right_stick","title":"<code>get_right_stick(precision=3)</code>","text":"<p>Returns the current values of the right stick (x, y).</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def get_right_stick(self, precision: int = 3) -&gt; list[float]:\n    \"\"\"Returns the current values of the right stick (x, y).\"\"\"\n    return [\n        super().get_axis_value(XboxControllerAxis.RightX, precision),\n        super().get_axis_value(XboxControllerAxis.RightY, precision),\n    ]\n</code></pre>"},{"location":"reference/#kevinbotlib.joystick.RemoteXboxController._poll_loop","title":"<code>_poll_loop()</code>","text":"<p>Xbox-specific polling loop that checks for state changes and triggers callbacks.</p> Source code in <code>src/kevinbotlib/joystick.py</code> <pre><code>def _poll_loop(self):\n    \"\"\"Xbox-specific polling loop that checks for state changes and triggers callbacks.\"\"\"\n    while self.running:\n        # Check connection status\n        conn_sendable = self.client.get(f\"{self._client_key}/connected\", BooleanSendable)\n        self.connected = conn_sendable.value if conn_sendable else False\n\n        if self.connected:\n            # Check buttons\n            buttons = self.get_buttons()\n            current_button_states = {btn: True for btn in buttons}\n\n            # Check for button state changes\n            for button in set(self._last_button_states.keys()) | set(current_button_states.keys()):\n                old_state = self._last_button_states.get(button, False)\n                new_state = current_button_states.get(button, False)\n\n                if old_state != new_state and button in self._button_callbacks:\n                    self._button_callbacks[button](new_state)\n\n            self._last_button_states = current_button_states\n\n            # Check POV/D-pad\n            current_pov = self.get_dpad_direction()\n            if current_pov != self._last_pov_state:\n                for callback in self._pov_callbacks:\n                    callback(current_pov)\n            self._last_pov_state = current_pov\n\n            # Check axes (only update states here, specific methods handle formatting)\n            current_axes = super().get_axes()\n            for axis_id in range(len(current_axes)):\n                self._last_axis_states[axis_id] = current_axes[axis_id]\n\n        time.sleep(1 / self.polling_hz)\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.LoggerDirectories","title":"<code>LoggerDirectories</code>","text":"Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>class LoggerDirectories:\n    @staticmethod\n    def get_logger_directory(*, ensure_exists=True) -&gt; str:\n        \"\"\"Returns the log directory path and ensures its existence if needed.\"\"\"\n        log_dir = platformdirs.user_data_dir(\"kevinbotlib/logging\", ensure_exists=ensure_exists)\n        os.makedirs(log_dir, exist_ok=True)\n        return log_dir\n\n    @staticmethod\n    def cleanup_logs(directory: str, max_size_mb: int = 500):\n        \"\"\"Deletes oldest log files if the total log directory exceeds max_size_mb.\"\"\"\n        log_files = sorted(glob.glob(os.path.join(directory, \"*.log\")), key=os.path.getctime)\n\n        while log_files and LoggerDirectories.get_directory_size(directory) &gt; max_size_mb:\n            os.remove(log_files.pop(0))  # Delete oldest file\n\n    @staticmethod\n    def get_directory_size(directory: str) -&gt; float:\n        \"\"\"Returns the size of the directory in MB.\"\"\"\n        return sum(os.path.getsize(f) for f in glob.glob(os.path.join(directory, \"*.log\"))) / (1024 * 1024)\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.LoggerDirectories.get_logger_directory","title":"<code>get_logger_directory(*, ensure_exists=True)</code>  <code>staticmethod</code>","text":"<p>Returns the log directory path and ensures its existence if needed.</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>@staticmethod\ndef get_logger_directory(*, ensure_exists=True) -&gt; str:\n    \"\"\"Returns the log directory path and ensures its existence if needed.\"\"\"\n    log_dir = platformdirs.user_data_dir(\"kevinbotlib/logging\", ensure_exists=ensure_exists)\n    os.makedirs(log_dir, exist_ok=True)\n    return log_dir\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.LoggerDirectories.cleanup_logs","title":"<code>cleanup_logs(directory, max_size_mb=500)</code>  <code>staticmethod</code>","text":"<p>Deletes oldest log files if the total log directory exceeds max_size_mb.</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>@staticmethod\ndef cleanup_logs(directory: str, max_size_mb: int = 500):\n    \"\"\"Deletes oldest log files if the total log directory exceeds max_size_mb.\"\"\"\n    log_files = sorted(glob.glob(os.path.join(directory, \"*.log\")), key=os.path.getctime)\n\n    while log_files and LoggerDirectories.get_directory_size(directory) &gt; max_size_mb:\n        os.remove(log_files.pop(0))  # Delete oldest file\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.LoggerDirectories.get_directory_size","title":"<code>get_directory_size(directory)</code>  <code>staticmethod</code>","text":"<p>Returns the size of the directory in MB.</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>@staticmethod\ndef get_directory_size(directory: str) -&gt; float:\n    \"\"\"Returns the size of the directory in MB.\"\"\"\n    return sum(os.path.getsize(f) for f in glob.glob(os.path.join(directory, \"*.log\"))) / (1024 * 1024)\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.Logger","title":"<code>Logger</code>","text":"Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>class Logger:\n    is_configured = False\n\n    def __init__(self) -&gt; None:\n        self._internal_logger = _internal_logger\n\n    @property\n    def loguru_logger(self):\n        return self._internal_logger\n\n    def configure(self, config: LoggerConfiguration):\n        Logger.is_configured = True\n        \"\"\"Configures file-based logging with rotation and cleanup.\"\"\"\n        self._internal_logger.remove()\n        self._internal_logger.add(sys.stderr, level=config.level.value.no)\n\n        if config.file_logger:\n            timestamp = datetime.now(tz=timezone.utc).strftime(\"%Y-%m-%d_%H-%M-%S-%f\")[:-3]  # Trim to ms\n            log_file = os.path.join(config.file_logger.directory, f\"{timestamp}.log\")\n\n            self._internal_logger.add(\n                log_file,\n                rotation=config.file_logger.rotation_size,\n                enqueue=True,\n                serialize=True,\n                level=config.file_logger.level.value.no if config.file_logger.level else config.level.value.no,\n            )\n            return log_file\n        return None\n\n    def log(self, level: Level, message: str | BaseException, opts: LoggerWriteOpts | None = None):\n        \"\"\"Log a message with a specified level\"\"\"\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        opts = opts or LoggerWriteOpts()\n        self._internal_logger.opt(depth=opts.depth, colors=opts.colors, ansi=opts.ansi, exception=opts.exception).log(\n            level.name, message\n        )\n\n    def trace(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.TRACE.name, message)\n\n    def debug(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.DEBUG.name, message)\n\n    def info(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.INFO.name, message)\n\n    def warning(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.WARNING.name, message)\n\n    def warn(self, message: str):\n        self.warning(message)\n\n    def error(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.ERROR.name, message)\n\n    def security(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.SECURITY.name, message)\n\n    def critical(self, message: str):\n        if not Logger.is_configured:\n            raise LoggerNotConfiguredException\n\n        self._internal_logger.opt(depth=1).log(Level.CRITICAL.name, message)\n</code></pre>"},{"location":"reference/#kevinbotlib.logger.Logger.log","title":"<code>log(level, message, opts=None)</code>","text":"<p>Log a message with a specified level</p> Source code in <code>src/kevinbotlib/logger.py</code> <pre><code>def log(self, level: Level, message: str | BaseException, opts: LoggerWriteOpts | None = None):\n    \"\"\"Log a message with a specified level\"\"\"\n    if not Logger.is_configured:\n        raise LoggerNotConfiguredException\n\n    opts = opts or LoggerWriteOpts()\n    self._internal_logger.opt(depth=opts.depth, colors=opts.colors, ansi=opts.ansi, exception=opts.exception).log(\n        level.name, message\n    )\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver.FileServer","title":"<code>FileServer</code>","text":"<p>Combined FTP and HTTP file server for KevinBot.</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>class FileServer:\n    \"\"\"Combined FTP and HTTP file server for KevinBot.\"\"\"\n\n    def __init__(\n        self, directory=\".\", ftp_port=2121, http_port=8000, host=\"127.0.0.1\", *, enable_ftp_server: bool = False\n    ):\n        self.directory = os.path.abspath(directory)\n        self.ftp_port = ftp_port\n        self._ftp_enabled = enable_ftp_server\n        self.http_port = http_port\n        self.host = host\n        self.ftp_thread = None\n        self.http_thread = None\n\n        self.logger = Logger()\n\n    def start_ftp_server(self):\n        \"\"\"Start the FTP server in a separate thread.\"\"\"\n\n        ftp_logger = logging.getLogger(\"pyftpdlib\")\n        ftp_logger.addHandler(logging.StreamHandler())\n        ftp_logger.setLevel(Level.DEBUG.value.no)\n\n        def logging_redirect(record):\n            log_level = next(key for key, val in logging.getLevelNamesMapping().items() if val == record.levelno)\n            logger_opt = self.logger.loguru_logger.opt(depth=6, exception=record.exc_info)\n            logger_opt.log(log_level, record.getMessage())\n\n            return False\n\n        ftp_logger.addFilter(logging_redirect)\n\n        authorizer = DummyAuthorizer()\n        authorizer.add_anonymous(self.directory, perm=\"elradfmwMT\")\n\n        handler = FTPHandler\n        handler.authorizer = authorizer\n        handler.banner = \"Welcome to KevinbotLib FTP Server\"\n\n        self.ftpserver = FTPServer((self.host, self.ftp_port), handler)\n\n        self.logger.info(f\"FTP server starting on {self.host}:{self.ftp_port}\")\n        self.logger.info(f\"Serving directory: {self.directory}\")\n\n        self.ftpserver.serve_forever()\n\n    def start_http_server(self):\n        \"\"\"Start the HTTP server.\"\"\"\n        os.chdir(self.directory)\n\n        def handler(*args):\n            return FileserverHTTPHandler(*args, directory=self.directory)\n\n        self.httpserver = HTTPServer((self.host, self.http_port), handler)\n\n        self.logger.info(f\"HTTP server starting on {self.host}:{self.http_port}\")\n        self.logger.info(f\"Serving directory: {self.directory}\")\n\n        self.httpserver.serve_forever()\n\n    def start(self, name: str = \"KevinbotLib.FileServer.Serve\"):\n        \"\"\"Start both FTP and HTTP servers.\"\"\"\n        if not os.path.exists(self.directory):\n            msg = f\"Directory does not exist: {self.directory}\"\n            raise ValueError(msg)\n\n        # Start FTP server in a thread\n        if self._ftp_enabled:\n            self.ftp_thread = threading.Thread(target=self.start_ftp_server)\n            self.ftp_thread.daemon = True\n            self.ftp_thread.start()\n            self.logger.security(\n                \"You have the FTP fileserver enabled. The ftp server is a security vunerability that can allow unauthorized access to system files. It is deprecated and will be removed in a future version\"\n            )\n\n        # Start HTTP server in a thread\n        self.http_thread = threading.Thread(target=self.start_http_server, name=name)\n        self.http_thread.daemon = True\n        self.http_thread.start()\n\n    def stop(self):\n        \"\"\"Stop the servers\"\"\"\n        self.ftpserver.close()\n        self.httpserver.shutdown()\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver.FileServer.start_ftp_server","title":"<code>start_ftp_server()</code>","text":"<p>Start the FTP server in a separate thread.</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>def start_ftp_server(self):\n    \"\"\"Start the FTP server in a separate thread.\"\"\"\n\n    ftp_logger = logging.getLogger(\"pyftpdlib\")\n    ftp_logger.addHandler(logging.StreamHandler())\n    ftp_logger.setLevel(Level.DEBUG.value.no)\n\n    def logging_redirect(record):\n        log_level = next(key for key, val in logging.getLevelNamesMapping().items() if val == record.levelno)\n        logger_opt = self.logger.loguru_logger.opt(depth=6, exception=record.exc_info)\n        logger_opt.log(log_level, record.getMessage())\n\n        return False\n\n    ftp_logger.addFilter(logging_redirect)\n\n    authorizer = DummyAuthorizer()\n    authorizer.add_anonymous(self.directory, perm=\"elradfmwMT\")\n\n    handler = FTPHandler\n    handler.authorizer = authorizer\n    handler.banner = \"Welcome to KevinbotLib FTP Server\"\n\n    self.ftpserver = FTPServer((self.host, self.ftp_port), handler)\n\n    self.logger.info(f\"FTP server starting on {self.host}:{self.ftp_port}\")\n    self.logger.info(f\"Serving directory: {self.directory}\")\n\n    self.ftpserver.serve_forever()\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver.FileServer.start_http_server","title":"<code>start_http_server()</code>","text":"<p>Start the HTTP server.</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>def start_http_server(self):\n    \"\"\"Start the HTTP server.\"\"\"\n    os.chdir(self.directory)\n\n    def handler(*args):\n        return FileserverHTTPHandler(*args, directory=self.directory)\n\n    self.httpserver = HTTPServer((self.host, self.http_port), handler)\n\n    self.logger.info(f\"HTTP server starting on {self.host}:{self.http_port}\")\n    self.logger.info(f\"Serving directory: {self.directory}\")\n\n    self.httpserver.serve_forever()\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver.FileServer.start","title":"<code>start(name='KevinbotLib.FileServer.Serve')</code>","text":"<p>Start both FTP and HTTP servers.</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>def start(self, name: str = \"KevinbotLib.FileServer.Serve\"):\n    \"\"\"Start both FTP and HTTP servers.\"\"\"\n    if not os.path.exists(self.directory):\n        msg = f\"Directory does not exist: {self.directory}\"\n        raise ValueError(msg)\n\n    # Start FTP server in a thread\n    if self._ftp_enabled:\n        self.ftp_thread = threading.Thread(target=self.start_ftp_server)\n        self.ftp_thread.daemon = True\n        self.ftp_thread.start()\n        self.logger.security(\n            \"You have the FTP fileserver enabled. The ftp server is a security vunerability that can allow unauthorized access to system files. It is deprecated and will be removed in a future version\"\n        )\n\n    # Start HTTP server in a thread\n    self.http_thread = threading.Thread(target=self.start_http_server, name=name)\n    self.http_thread.daemon = True\n    self.http_thread.start()\n</code></pre>"},{"location":"reference/#kevinbotlib.fileserver.FileServer.stop","title":"<code>stop()</code>","text":"<p>Stop the servers</p> Source code in <code>src/kevinbotlib/fileserver/fileserver.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the servers\"\"\"\n    self.ftpserver.close()\n    self.httpserver.shutdown()\n</code></pre>"},{"location":"reference/#kevinbotlib.util.fullclassname","title":"<code>fullclassname(o)</code>","text":"<p>Get the full name of a class</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>object</code> <p>The class to retrieve the full name of</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the module and class</p> Source code in <code>src/kevinbotlib/util.py</code> <pre><code>def fullclassname(o: object) -&gt; str:\n    \"\"\"Get the full name of a class\n\n    Args:\n        o (object): The class to retrieve the full name of\n\n    Returns:\n        str: The name of the module and class\n    \"\"\"\n    module = o.__module__\n    if module == \"builtins\":\n        return o.__qualname__  # avoid outputs like 'builtins.str'\n    return module + \".\" + o.__qualname__\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.HandshakeTimeoutException","title":"<code>HandshakeTimeoutException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when the server-up wait times out</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class HandshakeTimeoutException(BaseException):\n    \"\"\"Exception that is produced when the server-up wait times out\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.ServerTimeoutException","title":"<code>ServerTimeoutException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when the connection handshake times out</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class ServerTimeoutException(BaseException):\n    \"\"\"Exception that is produced when the connection handshake times out\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.JoystickMissingException","title":"<code>JoystickMissingException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when a requested gamepad is missing</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class JoystickMissingException(BaseException):\n    \"\"\"Exception that is produced when a requested gamepad is missing\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.CommandSchedulerAlreadyExistsException","title":"<code>CommandSchedulerAlreadyExistsException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when an attempt to create more than one command scheduler was made</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class CommandSchedulerAlreadyExistsException(BaseException):\n    \"\"\"Exception that is produced when an attempt to create more than one command scheduler was made\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.CommandSchedulerDoesNotExistException","title":"<code>CommandSchedulerDoesNotExistException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when an attempt to get the current scheduler instance before creating a CommandScheduler</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class CommandSchedulerDoesNotExistException(BaseException):\n    \"\"\"Exception that is produced when an attempt to get the current scheduler instance before creating a CommandScheduler\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.LoggerNotConfiguredException","title":"<code>LoggerNotConfiguredException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when trying to log to a non-configured logger</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class LoggerNotConfiguredException(BaseException):\n    \"\"\"Exception that is produced when trying to log to a non-configured logger\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.RobotStoppedException","title":"<code>RobotStoppedException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Used when a non-urgent robot stop is triggered</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class RobotStoppedException(BaseException):\n    \"\"\"Used when a non-urgent robot stop is triggered\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.RobotEmergencyStoppedException","title":"<code>RobotEmergencyStoppedException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Used when an urgent robot stop is triggered</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class RobotEmergencyStoppedException(BaseException):\n    \"\"\"Used when an urgent robot stop is triggered\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.RobotLockedException","title":"<code>RobotLockedException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when another instance of a robot is running</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class RobotLockedException(BaseException):\n    \"\"\"Exception that is produced when another instance of a robot is running\"\"\"\n</code></pre>"},{"location":"robot/","title":"The Robot Class","text":""}]}