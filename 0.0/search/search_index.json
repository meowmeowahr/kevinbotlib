{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KevinbotLib","text":"<p>KevinbotLib is a robot control system for Kevinbot v3 and the Kevinbot Core. You can easily and safely control Kevinbot's drivebase, servos, lighting, and more. It also continuously polls sensor data. It can operate in two modes: Direct Serial, and MQTT with the Kevinbot Server.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Multiple Control Interfaces</p> <ul> <li>Direct Serial mode</li> <li>MQTT networked mode (with KevinbotLib Server)</li> </ul> </li> <li> <p>Comprehensive Subsystem Control</p> <ul> <li>Drivebase with power and state monitoring</li> <li>Servo control</li> <li>Multi-zone lighting system with effects</li> <li>Continuous sensor polling</li> <li>Battery management and monitoring</li> <li>IMU support (gyroscope and accelerometer)</li> </ul> </li> <li> <p>Developer-Friendly Design</p> <ul> <li>Simple MQTT API</li> <li>Extensive configuration options</li> <li>Real-time state tracking</li> <li>Built-in safety features</li> <li>Detailed logging and debugging</li> <li>Python 3.13 support</li> </ul> </li> <li> <p>Robust Architecture</p> <ul> <li>Thread-safe communication</li> <li>Event-based callback system</li> <li>Auto-reconnection handling</li> <li>Multiple client support via MQTT</li> </ul> </li> </ul> <p>Development</p> <p>This project is in the early stage of development. There are many missing functions that will be supported in the future.</p>"},{"location":"architecture/","title":"Architecture","text":"<pre><code>flowchart TD\n subgraph s1[\"KevinbotLib Server\"]\n        n5[\"KevinbotLib&lt;br&gt;Direct Serial\"]\n  end\n    n3[\"MQTT API Mode\"] &lt;--&gt; n4[\"MQTT Broker\"]\n    n4 &lt;--&gt; s1\n    n5 --&gt; n6[\"Kevinbot&lt;br&gt;Hardware\"]\n    n2[\"Direct Serial\"] --&gt; n6\n    n10[\"OR\"] --&gt; n11[\"Direct Serial Mode&lt;br&gt;\"] &amp; n12[\"MQTT Mode\"]\n    n1[\"KevinbotLib\"] --&gt; n10\n    n11 --&gt; n2\n    n12 --&gt; n3\n    n3@{ shape: rect}\n    n4@{ shape: rect}\n    n6@{ shape: rect}\n    n2@{ shape: rect}\n    n10@{ shape: diam}\n    n11@{ shape: text}\n    n1@{ shape: rect}\n    n12@{ shape: text}</code></pre>"},{"location":"architecture/#serial-vs-mqtt","title":"Serial vs. MQTT","text":""},{"location":"architecture/#direct-serial","title":"Direct Serial","text":"<p>Pros</p> <ul> <li>Very low-latency</li> <li>More reliable</li> <li>Simpler</li> </ul> <p>Cons</p> <ul> <li>Single client access</li> <li>Requires wired connection</li> </ul>"},{"location":"architecture/#mqtt","title":"MQTT","text":"<p>Pros</p> <ul> <li>Multiple client access</li> <li>Networked</li> <li>Potentially easier to debug data</li> </ul> <p>Cons</p> <ul> <li>Higher latency</li> <li>More complex/more to go wrong</li> <li>Requires MQTT Broker</li> </ul>"},{"location":"cli_config/","title":"Configuration","text":"<p>The set of configuration commands makes it easier to set and retrieve configuration options.</p>"},{"location":"cli_config/#echo","title":"echo","text":"<p>The <code>echo</code> tool will output the raw configuration data in the original YAML format.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config echo [OPTIONS]\n</code></pre>"},{"location":"cli_config/#example-usage","title":"Example Usage","text":"<ul> <li>Outputing user configuration     <pre><code>kevinbot config echo\n</code></pre></li> <li>Outputing system configuration     <pre><code>kevinbot config echo --system\n</code></pre></li> </ul>"},{"location":"cli_config/#options","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_config/#get","title":"get","text":"<p>The <code>get</code> tool will return a value or group of values for the configurations. Will return a single value or JSON for a group of values.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config get [OPTIONS] KEYS\n</code></pre>"},{"location":"cli_config/#example-usage_1","title":"Example Usage","text":"<ul> <li>Retrieving MQTT Port     <pre><code>kevinbot config get mqtt.port\n</code></pre></li> <li>Retrieving Full MQTT Config (JSON)     <pre><code>kevinbot config get mqtt\n</code></pre></li> <li>Retrieving Entire Config (JSON)     <pre><code>kevinbot config get .\n</code></pre></li> </ul>"},{"location":"cli_config/#options_1","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_config/#set","title":"set","text":"<p>The <code>set</code> tool will set a single config value.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config set [OPTIONS] KEYS VALUE\n</code></pre>"},{"location":"cli_config/#example-usage_2","title":"Example Usage","text":"<ul> <li>Setting MQTT Port     <pre><code>kevinbot config set mqtt.port 2883 --int\n</code></pre></li> <li>Setting MQTT Host     <pre><code>kevinbot config set mqtt.host \"kevinbotv3.local\" --str\n</code></pre></li> </ul>"},{"location":"cli_config/#options_2","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>--int</code> FLAG Set value as an integer <code>--str</code> FLAG Set value as a string (default) <code>--bool</code> FLAG Set value as a boolean <code>--float</code> FLAG Set value as a floating-point <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_config/#path","title":"path","text":"<p>The <code>path</code> tool will retrieve the configuration file path for user or system-level configurations.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config path [OPTIONS]\n</code></pre>"},{"location":"cli_config/#example-usage_3","title":"Example Usage","text":"<ul> <li>Getting default configuration path     <pre><code>kevinbot config path\n</code></pre></li> <li>Getting user configuration path     <pre><code>kevinbot config path --user\n</code></pre></li> <li>Getting system configuration path     <pre><code>kevinbot config path --system\n</code></pre></li> </ul>"},{"location":"cli_config/#options_3","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_config/#save","title":"save","text":"<p>The <code>save</code> tool will create or update a configuration file.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot config save [OPTIONS]\n</code></pre>"},{"location":"cli_config/#example-usage_4","title":"Example Usage","text":"<ul> <li>Create/update a user configuration file     <pre><code>kevinbot config save --user\n</code></pre></li> <li>Create/update a user configuration file     <pre><code>kevinbot config save --system\n</code></pre></li> <li>Create/update a custom configuration file     <pre><code>kevinbot config save --config ~/path/to/config.yaml\n</code></pre></li> </ul>"},{"location":"cli_config/#options_4","title":"Options","text":"Argument Type Description <code>--config</code> STR Manually defined configuration path <code>--system</code> FLAG Use system configuration path <code>--user</code> FLAG Use user configuration path <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_listener/","title":"MQTT Listener","text":"<p>The MQTT Listener command line tool provides an easy way to subscribe to MQTT topics.  It subscribes to an MQTT topic, and logs messages to the terminal.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot listen [OPTIONS] TOPIC\n</code></pre>"},{"location":"cli_listener/#options","title":"Options","text":"Argument Type Description <code>--qos</code> INT MQTT Quality-of-Service <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"cli_pub/","title":"MQTT Publisher","text":"<p>The MQTT Publisher command line tool provides an easy way to publish to MQTT topics.  It can publish messages once, or at a set interval and count.</p> <p>It can be invoked with the following:</p> <pre><code>kevinbot pub [OPTIONS] TOPIC MESSAGE\n</code></pre>"},{"location":"cli_pub/#options","title":"Options","text":"Argument Type Description <code>--count</code> INT Number of times to publish message <code>--interval</code> FLOAT Interval between publishing messages (seconds) <code>--qos</code> INT MQTT Quality-of-Service <code>--retain</code> FLAG MQTT Retain Message <code>-h</code> or <code>--help</code> FLAG Output help information"},{"location":"examples/","title":"Examples","text":"<p>Most examples include two variants for serial, and MQTT. Source code can be found here</p> <p>For more information, see Serial vs. MQTT</p>"},{"location":"examples/#core","title":"Core","text":""},{"location":"examples/#robot-connection","title":"Robot Connection","text":"SerialMQTT examples/core/connecting_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nwhile True:\n    time.sleep(1)\n</code></pre> examples/core/connecting.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect(\"kevinbot\", \"localhost\", 1883)\n\nwhile True:\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#robot-enabling-and-disabling","title":"Robot Enabling and Disabling","text":"SerialMQTT examples/core/enable_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nrobot.request_enable()  # Ask the core to enable\nwhile not robot.get_state().enabled:  # Wait until the core is enabled\n    time.sleep(0.01)\n\ntime.sleep(3)\n\nrobot.request_disable()  # Ask the core to disable\nwhile robot.get_state().enabled:  # Wait until the core is disabled\n    time.sleep(0.01)\n\ntime.sleep(3)  # Let the user see that the robot is disabled before disconnecting\n</code></pre> examples/core/enable.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nrobot.request_enable()  # Ask the core to enable\nwhile not robot.get_state().enabled:  # Wait until the core is enabled\n    time.sleep(0.01)\n\ntime.sleep(3)\n\nrobot.request_disable()  # Ask the core to disable\nwhile robot.get_state().enabled:  # Wait until the core is disabled\n    time.sleep(0.01)\n\ntime.sleep(3)  # Let the user see that the robot is disabled before disconnecting\n</code></pre>"},{"location":"examples/#robot-emergency-stop","title":"Robot Emergency Stop","text":"SerialMQTT examples/core/estop_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nrobot.e_stop()\n</code></pre> examples/core/estop.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nrobot.e_stop()\n</code></pre>"},{"location":"examples/#robot-state-retrieval","title":"Robot State Retrieval","text":"SerialMQTT examples/core/state_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nwhile True:\n    print(robot.get_state())  # noqa: T201\n    time.sleep(1)\n</code></pre> examples/core/state.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nwhile True:\n    print(robot.get_state())  # noqa: T201\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#robot-timestamp-retrieval-mqtt-only","title":"Robot Timestamp Retrieval <code>MQTT Only</code>","text":"MQTT examples/core/timestamp.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nwhile True:\n    print(robot.ts)  # noqa: T201\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#robot-uptime-retrieval","title":"Robot Uptime Retrieval","text":"SerialMQTT examples/core/uptimes_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nwhile True:\n    print(f\"Uptime (s) : {robot.get_state().uptime}\")  # noqa: T201\n    print(f\"Uptime (ms): {robot.get_state().uptime_ms}\")  # noqa: T201\n    time.sleep(1)\n</code></pre> examples/core/uptimes.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nwhile True:\n    print(f\"Uptime (s) : {robot.get_state().uptime}\")  # noqa: T201\n    print(f\"Uptime (ms): {robot.get_state().uptime_ms}\")  # noqa: T201\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#battery","title":"Battery","text":""},{"location":"examples/#robot-battery-readings","title":"Robot Battery Readings","text":"SerialMQTT examples/battery/readings_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\ntime.sleep(3)  # Wait to get data\n\nprint(f\"Voltages: {robot.get_state().battery.voltages}\")  # noqa: T201\nprint(f\"Raw Voltages: {robot.get_state().battery.raw_voltages}\")  # noqa: T201\nprint(f\"States: {robot.get_state().battery.states}\")  # noqa: T201\n</code></pre> examples/battery/readings.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\ntime.sleep(3)  # Wait to get data\n\nprint(f\"Voltages: {robot.get_state().battery.voltages}\")  # noqa: T201\nprint(f\"Raw Voltages: {robot.get_state().battery.raw_voltages}\")  # noqa: T201\nprint(f\"States: {robot.get_state().battery.states}\")  # noqa: T201\n</code></pre>"},{"location":"examples/#environment","title":"Environment","text":""},{"location":"examples/#bme280","title":"BME280","text":"SerialMQTT examples/environment/bme280_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nwhile True:\n    print(f\"Temp  : {robot.get_state().enviro.temperature} *C\")  # noqa: T201\n    print(f\"Humi  : {robot.get_state().enviro.humidity} %\")  # noqa: T201\n    print(f\"Pres  : {robot.get_state().enviro.pressure} hPa\")  # noqa: T201\n    time.sleep(2)\n</code></pre> examples/environment/bme280.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nwhile True:\n    print(f\"Temp  : {robot.get_state().enviro.temperature} *C\")  # noqa: T201\n    print(f\"Humi  : {robot.get_state().enviro.humidity} %\")  # noqa: T201\n    print(f\"Pres  : {robot.get_state().enviro.pressure} hPa\")  # noqa: T201\n    time.sleep(2)\n</code></pre>"},{"location":"examples/#ds18b20","title":"DS18B20","text":"SerialMQTT examples/environment/ds18b20_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nwhile True:\n    print(f\"Left Motor : {robot.get_state().thermal.left_motor} *C\")  # noqa: T201\n    print(f\"Right Motor: {robot.get_state().thermal.right_motor} *C\")  # noqa: T201\n    print(f\"Internal: {robot.get_state().thermal.internal} *C\")  # noqa: T201\n    time.sleep(2)\n</code></pre> examples/environment/ds18b20.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nwhile True:\n    print(f\"Left Motor : {robot.get_state().thermal.left_motor} *C\")  # noqa: T201\n    print(f\"Right Motor: {robot.get_state().thermal.right_motor} *C\")  # noqa: T201\n    print(f\"Internal: {robot.get_state().thermal.internal} *C\")  # noqa: T201\n    time.sleep(2)\n</code></pre>"},{"location":"examples/#imu","title":"IMU","text":""},{"location":"examples/#periodic-polling","title":"Periodic Polling","text":"SerialMQTT examples/imu/periodic_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\nwhile True:\n    print(f\"Gyro : {robot.get_state().imu.gyro}\")  # noqa: T201\n    print(f\"Accel: {robot.get_state().imu.accel}\")  # noqa: T201\n    time.sleep(1)\n</code></pre> examples/imu/periodic.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\nwhile True:\n    print(f\"Gyro : {robot.get_state().imu.gyro}\")  # noqa: T201\n    print(f\"Accel: {robot.get_state().imu.accel}\")  # noqa: T201\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#plotting-with-matplotlib","title":"Plotting with matplotlib","text":"SerialMQTT <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/imu/plot_serial.py</p> <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/imu/plot.py</p>"},{"location":"examples/#servo","title":"Servo","text":""},{"location":"examples/#sweep-demo","title":"Sweep demo","text":"SerialMQTT <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/servo/sweep_serial.py</p> <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/servo/sweep.py</p>"},{"location":"examples/#drive","title":"Drive","text":""},{"location":"examples/#status","title":"Status","text":"SerialMQTT examples/drive/status_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import Drivebase, SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\ndrive = Drivebase(robot)\n\nrobot.request_enable()  # Ask the core to enable\nwhile not robot.get_state().enabled:  # Wait until the core is enabled\n    time.sleep(0.01)\n\ntime.sleep(1)  # Wait for data to arrive\n\nprint(f\"Speeds: {drive.get_powers()}\")  # noqa: T201\nprint(f\"Watts: {drive.get_watts()}\")  # noqa: T201\nprint(f\"Amps: {drive.get_amps()}\")  # noqa: T201\n</code></pre> examples/drive/status.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import Drivebase, MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\ndrive = Drivebase(robot)\n\nrobot.request_enable()  # Ask the core to enable\nwhile not robot.get_state().enabled:  # Wait until the core is enabled\n    time.sleep(0.01)\n\ntime.sleep(1)  # Wait for data to arrive\n\nprint(f\"Speeds: {drive.get_powers()}\")  # noqa: T201\nprint(f\"Watts: {drive.get_watts()}\")  # noqa: T201\nprint(f\"Amps: {drive.get_amps()}\")  # noqa: T201\n</code></pre>"},{"location":"examples/#drive-at-power","title":"Drive at Power","text":"SerialMQTT examples/drive/drive_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import Drivebase, SerialKevinbot\n\nrobot = SerialKevinbot()\nrobot.connect(\"/dev/ttyAMA2\", 921600, 5, 1)\n\ndrive = Drivebase(robot)\n\ninput(\"LIFT THE WHEELS OFF THE GROUND FOR THIS TEST!!! [Return] to start test\")\n\nrobot.request_enable()  # Ask the core to enable\nwhile not robot.get_state().enabled:  # Wait until the core is enabled\n    time.sleep(0.01)\n\ntime.sleep(1)  # Wait for data to arrive\ndrive.drive_at_power(0.2, 0.2)\ntime.sleep(3)\ndrive.drive_at_power(0.5, 0.2)\ntime.sleep(3)\ndrive.drive_at_power(0.2, 0.5)\ntime.sleep(3)\ndrive.drive_at_power(0.05, 0.05)\ntime.sleep(3)\n# Will auto-stop on disconnect\n# drive.stop()\n</code></pre> examples/drive/drive.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import Drivebase, MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect(\"kevinbot\", \"10.0.0.10\", 1883)\n\ndrive = Drivebase(robot)\n\ninput(\"LIFT THE WHEELS OFF THE GROUND FOR THIS TEST!!! [Return] to start test\")\n\nrobot.request_enable()  # Ask the core to enable\nwhile not robot.get_state().enabled:  # Wait until the core is enabled\n    time.sleep(0.01)\n\ntime.sleep(1)  # Wait for data to arrive\ndrive.drive_at_power(0.2, 0.2)\ntime.sleep(3)\ndrive.drive_at_power(0.5, 0.2)\ntime.sleep(3)\ndrive.drive_at_power(0.2, 0.5)\ntime.sleep(3)\ndrive.drive_at_power(0.05, 0.05)\ntime.sleep(3)\n# Will auto-stop on disconnect\n# drive.stop()\n</code></pre>"},{"location":"examples/#eyes","title":"Eyes","text":""},{"location":"examples/#connecting","title":"Connecting","text":"SerialMQTT examples/eyes/connecting_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialEyes\n\neyes = SerialEyes()\neyes.connect(\"/dev/ttyUSB0\", 115200, 5)\n\nwhile True:\n    time.sleep(1)\n</code></pre> examples/eyes/connecting.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttEyes, MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\neyes = MqttEyes(robot)\n\nwhile True:\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#state","title":"State","text":"SerialMQTT examples/eyes/state_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialEyes\n\neyes = SerialEyes()\neyes.connect(\"/dev/ttyUSB0\", 115200, 5)\n\nprint(eyes.get_state().model_dump_json(indent=4))  # noqa: T201\n\ntime.sleep(1)\n</code></pre> examples/eyes/state.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttEyes, MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\neyes = MqttEyes(robot)\n\nprint(eyes.get_state().model_dump_json(indent=4))  # noqa: T201\n\ntime.sleep(1)\n</code></pre>"},{"location":"examples/#backlight","title":"Backlight","text":"SerialMQTT examples/eyes/backlight_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import SerialEyes\n\neyes = SerialEyes()\neyes.connect(\"/dev/ttyUSB0\", 115200, 5)\n\nfor i in range(100):\n    eyes.set_backlight(i / 100)\n    time.sleep(0.05)\n</code></pre> examples/eyes/backlight.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import MqttKevinbot\nfrom kevinbotlib.eyes import MqttEyes\n\nrobot = MqttKevinbot()\nrobot.connect()\n\neyes = MqttEyes(robot)\n\nfor i in range(100):\n    eyes.set_backlight(i / 100)\n    time.sleep(0.05)\n</code></pre>"},{"location":"examples/#motion-mode-control","title":"Motion Mode Control","text":"SerialMQTT examples/eyes/motions_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import EyeMotion, EyeSkin, SerialEyes\n\neyes = SerialEyes()\neyes.connect(\"/dev/ttyUSB0\", 115200, 5)\n\neyes.set_skin(EyeSkin.SIMPLE)\n\neyes.set_motion(EyeMotion.DISABLE)\ntime.sleep(3)\n\neyes.set_motion(EyeMotion.LEFT_RIGHT)\ntime.sleep(3)\n\neyes.set_motion(EyeMotion.JUMP)\ntime.sleep(3)\n</code></pre> examples/eyes/motions.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import EyeMotion, EyeSkin, MqttEyes, MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\neyes = MqttEyes(robot)\n\neyes.set_skin(EyeSkin.SIMPLE)\n\neyes.set_motion(EyeMotion.DISABLE)\ntime.sleep(3)\n\neyes.set_motion(EyeMotion.LEFT_RIGHT)\ntime.sleep(3)\n\neyes.set_motion(EyeMotion.JUMP)\ntime.sleep(3)\n</code></pre>"},{"location":"examples/#skin-setting-control","title":"Skin Setting Control","text":"SerialMQTT examples/eyes/skins_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import EyeSkin, SerialEyes\n\neyes = SerialEyes()\neyes.connect(\"/dev/ttyUSB0\", 115200, 5)\n\neyes.set_skin(EyeSkin.TV_STATIC)\ntime.sleep(2)\n\neyes.set_skin(EyeSkin.SIMPLE)\ntime.sleep(2)\n\neyes.set_skin(EyeSkin.METAL)\ntime.sleep(2)\n\neyes.set_skin(EyeSkin.NEON)\ntime.sleep(2)\n</code></pre> examples/eyes/skins.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport time\n\nfrom kevinbotlib import EyeSkin, MqttEyes, MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\neyes = MqttEyes(robot)\n\neyes.set_skin(EyeSkin.TV_STATIC)\ntime.sleep(2)\n\neyes.set_skin(EyeSkin.SIMPLE)\ntime.sleep(2)\n\neyes.set_skin(EyeSkin.METAL)\ntime.sleep(2)\n\neyes.set_skin(EyeSkin.NEON)\ntime.sleep(2)\n</code></pre>"},{"location":"examples/#manual-motions-demo","title":"Manual Motions Demo","text":"SerialMQTT examples/eyes/manual_serial.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport random\nimport time\n\nfrom kevinbotlib import EyeMotion, EyeSkin, SerialEyes\n\neyes = SerialEyes()\neyes.connect(\"/dev/ttyUSB0\", 115200, 5)\n\neyes.set_skin(EyeSkin.SIMPLE)\n\neyes.set_motion(EyeMotion.MANUAL)\n\nfor _i in range(10):\n    eyes.set_manual_pos(random.randint(0, 240), random.randint(0, 240))  # noqa: S311\n    time.sleep(1)\n</code></pre> examples/eyes/manual.py<pre><code># SPDX-FileCopyrightText: 2024-present Kevin Ahr &lt;meowmeowahr@gmail.com&gt;\n#\n# SPDX-License-Identifier: GPL-3.0-or-later\n\nimport random\nimport time\n\nfrom kevinbotlib import EyeMotion, EyeSkin, MqttEyes, MqttKevinbot\n\nrobot = MqttKevinbot()\nrobot.connect()\n\neyes = MqttEyes(robot)\n\neyes.set_skin(EyeSkin.SIMPLE)\n\neyes.set_motion(EyeMotion.MANUAL)\n\nfor _i in range(10):\n    eyes.set_manual_pos(random.randint(0, 240), random.randint(0, 240))  # noqa: S311\n    time.sleep(1)\n</code></pre>"},{"location":"examples/#simple-skin-full-options-demo","title":"Simple Skin Full Options Demo","text":"SerialMQTT <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/eyes/simple_skin_serial.py</p> <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/eyes/simple_skin.py</p>"},{"location":"examples/#metal-skin-full-options-demo","title":"Metal Skin Full Options Demo","text":"SerialMQTT <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/eyes/metal_skin_serial.py</p> <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/eyes/metal_skin.py</p>"},{"location":"examples/#neon-skin-full-options-demo","title":"Neon Skin Full Options Demo","text":"SerialMQTT <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/eyes/neon_skin_serial.py</p> <p>https://github.com/meowmeowahr/kevinbotlib/blob/main/examples/eyes/neon_skin.py</p>"},{"location":"installation/","title":"Installation","text":"<p>Info</p> <p>KevinbotLib requires Python 3.10 or newer.</p>"},{"location":"installation/#system-dependencies","title":"System Dependencies","text":"<p>If you want to use the TTS (Text-to-Speech) extra on Linux, you must install PortAudio</p> <ul> <li>Debian/Ubuntu/RpiOS</li> </ul> <pre><code>sudo apt install portaudio19-dev\n</code></pre>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"<p>Run the following in a virtual environment for the base version. <pre><code>pip install kevinbotlib\n</code></pre></p> <p>Run the following if you want to install the TTS (Text-to-Speech) extra. <pre><code>pip install kevinbotlib[tts]\n</code></pre></p>"},{"location":"installation/#install-with-pipx","title":"Install with pipx","text":"<p>Tip</p> <p>pipx installation will only install command-line tools and the KevinbotLib Server. Use the regular pip installation if you want any development tools.</p> <ol> <li>Install pipx here</li> <li> <p>Install KevinbotLib</p> <p>Run the follwoing: <pre><code>pipx install kevinbotlib\n</code></pre></p> </li> </ol>"},{"location":"reference/","title":"Reference","text":"<p>Configuration manager for KevinbotLib</p> <p>KevinbotLib Robot Server Allow accessing KevinbotLib APIs over MQTT</p>"},{"location":"reference/#kevinbotlib.core.BaseKevinbotSubsystem","title":"<code>BaseKevinbotSubsystem</code>","text":"<p>The base subsystem class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class BaseKevinbotSubsystem:\n    \"\"\"The base subsystem class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self, robot: \"SerialKevinbot | MqttKevinbot\") -&gt; None:\n        self.robot = robot\n        self.robot._register_component(self)  # noqa: SLF001\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot","title":"<code>BaseKevinbot</code>","text":"<p>The base robot class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class BaseKevinbot:\n    \"\"\"The base robot class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._state = KevinbotState()\n        self._server_state = KevinbotServerState()\n        self.type = KevinbotConnectionType.BASE\n        self._subsystems: list[BaseKevinbotSubsystem] = []\n\n        self._auto_disconnect = True\n        self._auto_disable = True\n\n    def get_state(self) -&gt; KevinbotState:\n        \"\"\"Gets the current state of the robot\n\n        Returns:\n            KevinbotState: State class\n        \"\"\"\n        return self._state\n\n    @property\n    def server_state(self) -&gt; KevinbotServerState:\n        return self._server_state\n\n    def disconnect(self):\n        \"\"\"Basic robot disconnect\"\"\"\n        self._state.connected = False\n        if self.auto_disable:\n            self.request_disable()\n\n    @property\n    def auto_disconnect(self) -&gt; bool:\n        \"\"\"Getter for auto disconnect state.\n\n        Returns:\n            bool: Whether to disconnect on application exit\n        \"\"\"\n        return self._auto_disconnect\n\n    @auto_disconnect.setter\n    def auto_disconnect(self, value: bool):\n        \"\"\"Setter for auto disconnect.\n\n        Args:\n            value (bool): Whether to disconnect on application exit\n        \"\"\"\n        self._auto_disconnect = value\n        if value:\n            atexit.register(self.disconnect)\n        else:\n            atexit.unregister(self.disconnect)\n\n    @property\n    def auto_disable(self) -&gt; bool:\n        \"\"\"Getter for auto disable state.\n\n        Returns:\n            bool: Whether to disconnect on application exit\n        \"\"\"\n        return self._auto_disable\n\n    @auto_disable.setter\n    def auto_disable(self, value: bool):\n        \"\"\"Setter for auto disable.\n\n        Args:\n            value (bool): Whether to disconnect on application exit\n        \"\"\"\n        self._auto_disable = value\n\n    def send(self, data: str):\n        \"\"\"Null implementation of the send method\n\n        Args:\n            data (str): Data to send nowhere\n\n        Raises:\n            NotImplementedError: Always raised\n        \"\"\"\n        msg = f\"Function not implemented, attempting to send {data}\"\n        raise NotImplementedError(msg)\n\n    def request_enable(self) -&gt; int:\n        \"\"\"Request the core to enable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.send(\"kevinbot.tryenable=1\")\n        return 1\n\n    def request_disable(self) -&gt; int:\n        \"\"\"Request the core to disable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.send(\"kevinbot.tryenable=0\")\n        return 1\n\n    def e_stop(self):\n        \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n        self.send(\"system.estop\")\n        self._state.estop = True\n\n    def _register_component(self, component: BaseKevinbotSubsystem):\n        self._subsystems.append(component)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.auto_disconnect","title":"<code>auto_disconnect</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for auto disconnect state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to disconnect on application exit</p>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.auto_disable","title":"<code>auto_disable</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for auto disable state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to disconnect on application exit</p>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.get_state","title":"<code>get_state()</code>","text":"<p>Gets the current state of the robot</p> <p>Returns:</p> Name Type Description <code>KevinbotState</code> <code>KevinbotState</code> <p>State class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_state(self) -&gt; KevinbotState:\n    \"\"\"Gets the current state of the robot\n\n    Returns:\n        KevinbotState: State class\n    \"\"\"\n    return self._state\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Basic robot disconnect</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Basic robot disconnect\"\"\"\n    self._state.connected = False\n    if self.auto_disable:\n        self.request_disable()\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.send","title":"<code>send(data)</code>","text":"<p>Null implementation of the send method</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send nowhere</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Null implementation of the send method\n\n    Args:\n        data (str): Data to send nowhere\n\n    Raises:\n        NotImplementedError: Always raised\n    \"\"\"\n    msg = f\"Function not implemented, attempting to send {data}\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.request_enable","title":"<code>request_enable()</code>","text":"<p>Request the core to enable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_enable(self) -&gt; int:\n    \"\"\"Request the core to enable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.send(\"kevinbot.tryenable=1\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.request_disable","title":"<code>request_disable()</code>","text":"<p>Request the core to disable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_disable(self) -&gt; int:\n    \"\"\"Request the core to disable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.send(\"kevinbot.tryenable=0\")\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.BaseKevinbot.e_stop","title":"<code>e_stop()</code>","text":"<p>Attempt to send and E-Stop signal to the Core</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def e_stop(self):\n    \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n    self.send(\"system.estop\")\n    self._state.estop = True\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot","title":"<code>SerialKevinbot</code>","text":"<p>               Bases: <code>BaseKevinbot</code></p> <p>The main serial robot class</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class SerialKevinbot(BaseKevinbot):\n    \"\"\"The main serial robot class\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.type = KevinbotConnectionType.SERIAL\n\n        self.serial: Serial | None = None\n        self.rx_thread: Thread | None = None\n\n        self._callback: Callable[[str, str | None], Any] | None = None\n\n        atexit.register(self.disconnect)\n\n    def connect(\n        self,\n        port: str,\n        baud: int,\n        timeout: float,\n        tick_interval: float,\n        ser_timeout: float = 0.5,\n        *,\n        tick_thread: bool = True,\n    ):\n        \"\"\"Start a connection with Kevinbot Core\n\n        Args:\n            port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n            baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n            timeout (float): Timeout for handshake\n            tick_interval (float): How often a heartbeat should be produced\n            ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n            tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n        Raises:\n            HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n        \"\"\"\n        serial = self._setup_serial(port, baud, ser_timeout)\n\n        start_time = time.monotonic()\n        while True:\n            serial.write(b\"connection.isready=0\\n\")\n\n            line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n            if line == \"ready\":\n                serial.write(b\"connection.start\\n\")\n                serial.write(b\"core.errors.clear\\n\")\n                serial.write(b\"connection.ok\\n\")\n                break\n\n            if time.monotonic() - start_time &gt; timeout:\n                msg = \"Handshake timed out\"\n                raise HandshakeTimeoutException(msg)\n\n            time.sleep(0.1)  # Avoid spamming the connection\n\n        # Data rx thread\n        self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n        self.rx_thread.name = \"KevinbotLib.Rx\"\n        self.rx_thread.start()\n\n        if tick_thread:\n            thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n            thread.start()\n            thread.name = \"KevinbotLib.Tick\"\n\n        self._state.connected = True\n\n    def disconnect(self):\n        \"\"\"Disconnect core gracefully\"\"\"\n        super().disconnect()\n        if self.serial and self.serial.is_open:\n            self.send(\"core.link.unlink\")\n            self.serial.flush()\n            self.serial.close()\n        else:\n            logger.warning(\"Already disconnected\")\n\n    @property\n    def on_data(self) -&gt; Callable[[str, str | None], Any] | None:\n        \"\"\"Return the data recieved callback function\n\n        Returns:\n            Callable[[str, str | None], Any] | None: Callback function\n        \"\"\"\n        return self._callback\n\n    @on_data.setter\n    def on_data(self, callback: Callable[[str, str | None], Any]) -&gt; None:\n        \"\"\"Set the data recieved callback function\n\n        Args:\n            callback (Callable[[str, str  |  None], Any]): Callback function\n        \"\"\"\n        self._callback = callback\n\n    def tick_loop(self, interval: float = 1):\n        \"\"\"Send ticks indefinetely\n\n        Args:\n            interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n        \"\"\"\n        while True:\n            self._tick()\n            time.sleep(interval)\n\n    def send(self, data: str):\n        \"\"\"Send a string through serial.\n\n        Automatically adds a newline.\n\n        Args:\n            data (str): Data to send\n        \"\"\"\n        self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n\n    def raw_tx(self, data: bytes):\n        \"\"\"Send raw bytes over serial.\n\n        Args:\n            data (bytes): Raw data\n        \"\"\"\n        if self.serial:\n            self.serial.write(data)\n        else:\n            logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n\n    def _rx_loop(self, serial: Serial, delimeter: str = \"=\"):\n        while True:\n            try:\n                raw: bytes = serial.readline()\n            except TypeError:\n                # serial has been stopped\n                return\n\n            cmd: str = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[0].strip()\n            if not cmd:\n                continue\n\n            val: str | None = None\n            if len(raw.decode(\"utf-8\").split(delimeter)) &gt; 1:\n                val = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[1].strip(\"\\r\\n\")\n\n            match cmd:\n                case \"ready\":\n                    pass\n                case \"core.enabled\":\n                    if not val:\n                        logger.warning(\"No value recieved for 'core.enabled'\")\n                        continue\n                    if val.lower() in [\"true\", \"t\", \"1\"]:\n                        self._state.enabled = True\n                    else:\n                        self._state.enabled = False\n                case \"core.uptime\":\n                    if val:\n                        self._state.uptime = int(val)\n                case \"core.uptime_ms\":\n                    if val:\n                        self._state.uptime_ms = int(val)\n                case \"connection.requesthandshake\":\n                    serial.write(b\"connection.start\\n\")\n                    serial.write(b\"core.errors.clear\\n\")\n                    serial.write(b\"connection.ok\\n\")\n                    logger.warning(\"A handshake was re-requested. This could indicate a core power fault or reset\")\n                case \"motors.amps\":\n                    if not val:\n                        logger.error(\"No value given for motors.amps\")\n                        continue\n\n                    try:\n                        [int(sv) for sv in val.split(\",\")]\n                    except ValueError:\n                        logger.error(f\"Values of motion.amps are not ints: {val}\")\n                        continue\n\n                    self._state.motion.amps = list(map(float, val.split(\",\")))\n                case \"motors.watts\":\n                    if not val:\n                        logger.error(\"No value given for motors.watts\")\n                        continue\n\n                    try:\n                        [int(sv) for sv in val.split(\",\")]\n                    except ValueError:\n                        logger.error(f\"Values of motion.watts are not ints: {val}\")\n                        continue\n\n                    self._state.motion.watts = list(map(float, val.split(\",\")))\n                case \"motors.status\":\n                    if not val:\n                        logger.error(\"No value given for motors.status\")\n                        continue\n\n                    try:\n                        [int(sv) for sv in val.split(\",\")]\n                    except ValueError:\n                        logger.error(f\"Values of motion.status are not ints: {val}\")\n                        continue\n\n                    self._state.motion.status = [MotorDriveStatus(int(x)) for x in val.split(\",\")]\n                case \"motors.powers\":\n                    if not val:\n                        logger.error(\"No value given for motors.powers\")\n                        continue\n\n                    try:\n                        [int(sv) for sv in val.split(\",\")]\n                    except ValueError:\n                        logger.error(f\"Values of motion.powers are not ints: {val}\")\n                        continue\n\n                    self._state.motion.powers = [int(x)/100 for x in val.split(\",\")]\n                case \"bms.voltages\":\n                    if not val:\n                        logger.error(\"No value given for bms.voltages\")\n                        continue\n\n                    try:\n                        [int(sv) for sv in val.split(\",\")]\n                    except ValueError:\n                        logger.error(f\"Values of bms.voltages are not ints: {val}\")\n                        continue\n\n                    self._state.battery.voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.raw_voltages\":\n                    if val:\n                        self._state.battery.raw_voltages = [float(x) / 10 for x in val.split(\",\")]\n                case \"bms.status\":\n                    if val:\n                        self._state.battery.states = [BmsBatteryStatus(int(x)) for x in val.split(\",\")]\n                case \"sensors.gyro\":\n                    if not val:\n                        logger.error(\"No value given for sensors.gyro\")\n                        continue\n\n                    try:\n                        [int(sv) for sv in val.split(\",\")]\n                    except ValueError:\n                        logger.error(f\"Values of sensors.gyro are not ints: {val}\")\n                        continue\n\n                    self._state.imu.gyro = [int(x) for x in val.split(\",\")]\n                case \"sensors.accel\":\n                    if not val:\n                        logger.error(\"No value given for sensors.accel\")\n                        continue\n\n                    try:\n                        [int(sv) for sv in val.split(\",\")]\n                    except ValueError:\n                        logger.error(f\"Values of sensors.accel are not ints: {val}\")\n                        continue\n\n                    self._state.imu.accel = [int(x) for x in val.split(\",\")]\n                case \"sensors.temps\":\n                    if val:\n                        temps = val.split(\",\")\n                        valid = True\n\n                        if len(temps) != 3:\n                            logger.error(f\"Found {len(temps)} values in temps, expected 3\")\n                            valid = False\n                            continue\n\n                        for temp in temps:\n                            if not re.match(\"^[-+]?[0-9]+$\", temp):\n                                logger.error(f\"Found non-integer value in temps, {temps}\")\n                                valid = False\n                                continue\n                        if valid:\n                            self._state.thermal.left_motor = int(temps[0]) / 100\n                            self._state.thermal.right_motor = int(temps[1]) / 100\n                            self._state.thermal.internal = int(temps[2]) / 100\n                case \"sensors.bme\":\n                    if val:\n                        vals = val.split(\",\")\n                        for value in vals:\n                            if not re.match(\"^[-+]?[0-9]+$\", value):\n                                logger.error(f\"Found non-integer value in bme values, {temps}\")\n                                continue\n\n                        self._state.enviro.temperature = int(vals[0])\n                        self._state.enviro.humidity = int(vals[2])\n                        self._state.enviro.pressure = int(vals[3])\n                case _:\n                    logger.warning(f\"Got a command that isn't supported yet: {cmd} with value {val}\")\n\n            if self.on_data:\n                self.on_data(cmd, val)\n\n    def _setup_serial(self, port: str, baud: int, timeout: float = 1):\n        self.serial = Serial(port, baud, timeout=timeout)\n        return self.serial\n\n    def _tick(self):\n        if self.serial and self.serial.is_open:\n            self.serial.write(b\"core.tick\\n\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.on_data","title":"<code>on_data</code>  <code>property</code> <code>writable</code>","text":"<p>Return the data recieved callback function</p> <p>Returns:</p> Type Description <code>Callable[[str, str | None], Any] | None</code> <p>Callable[[str, str | None], Any] | None: Callback function</p>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.connect","title":"<code>connect(port, baud, timeout, tick_interval, ser_timeout=0.5, *, tick_thread=True)</code>","text":"<p>Start a connection with Kevinbot Core</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port to use (<code>/dev/ttyAMA2</code> is standard with the typical Kevinbot Hardware)</p> required <code>baud</code> <code>int</code> <p>Baud rate to use (<code>921600</code> is typical for the defualt Core configs)</p> required <code>timeout</code> <code>float</code> <p>Timeout for handshake</p> required <code>tick_interval</code> <code>float</code> <p>How often a heartbeat should be produced</p> required <code>ser_timeout</code> <code>float</code> <p>Readline timeout, should be lower than <code>timeout</code>. Defaults to 0.5.</p> <code>0.5</code> <code>tick_thread</code> <code>bool</code> <p>Whether a tick thread should be started. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>HandshakeTimeoutException</code> <p>Core didn't respond to the connection handshake before the timeout</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def connect(\n    self,\n    port: str,\n    baud: int,\n    timeout: float,\n    tick_interval: float,\n    ser_timeout: float = 0.5,\n    *,\n    tick_thread: bool = True,\n):\n    \"\"\"Start a connection with Kevinbot Core\n\n    Args:\n        port (str): Serial port to use (`/dev/ttyAMA2` is standard with the typical Kevinbot Hardware)\n        baud (int): Baud rate to use (`921600` is typical for the defualt Core configs)\n        timeout (float): Timeout for handshake\n        tick_interval (float): How often a heartbeat should be produced\n        ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n        tick_thread (bool, optional): Whether a tick thread should be started. Defaults to True.\n\n    Raises:\n        HandshakeTimeoutException: Core didn't respond to the connection handshake before the timeout\n    \"\"\"\n    serial = self._setup_serial(port, baud, ser_timeout)\n\n    start_time = time.monotonic()\n    while True:\n        serial.write(b\"connection.isready=0\\n\")\n\n        line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n        if line == \"ready\":\n            serial.write(b\"connection.start\\n\")\n            serial.write(b\"core.errors.clear\\n\")\n            serial.write(b\"connection.ok\\n\")\n            break\n\n        if time.monotonic() - start_time &gt; timeout:\n            msg = \"Handshake timed out\"\n            raise HandshakeTimeoutException(msg)\n\n        time.sleep(0.1)  # Avoid spamming the connection\n\n    # Data rx thread\n    self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n    self.rx_thread.name = \"KevinbotLib.Rx\"\n    self.rx_thread.start()\n\n    if tick_thread:\n        thread = Thread(target=self.tick_loop, args=(tick_interval,), daemon=True)\n        thread.start()\n        thread.name = \"KevinbotLib.Tick\"\n\n    self._state.connected = True\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect core gracefully</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect core gracefully\"\"\"\n    super().disconnect()\n    if self.serial and self.serial.is_open:\n        self.send(\"core.link.unlink\")\n        self.serial.flush()\n        self.serial.close()\n    else:\n        logger.warning(\"Already disconnected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.tick_loop","title":"<code>tick_loop(interval=1)</code>","text":"<p>Send ticks indefinetely</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>Interval between ticks in seconds. Defaults to 1.</p> <code>1</code> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def tick_loop(self, interval: float = 1):\n    \"\"\"Send ticks indefinetely\n\n    Args:\n        interval (float, optional): Interval between ticks in seconds. Defaults to 1.\n    \"\"\"\n    while True:\n        self._tick()\n        time.sleep(interval)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.send","title":"<code>send(data)</code>","text":"<p>Send a string through serial.</p> <p>Automatically adds a newline.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Send a string through serial.\n\n    Automatically adds a newline.\n\n    Args:\n        data (str): Data to send\n    \"\"\"\n    self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/#kevinbotlib.core.SerialKevinbot.raw_tx","title":"<code>raw_tx(data)</code>","text":"<p>Send raw bytes over serial.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw data</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def raw_tx(self, data: bytes):\n    \"\"\"Send raw bytes over serial.\n\n    Args:\n        data (bytes): Raw data\n    \"\"\"\n    if self.serial:\n        self.serial.write(data)\n    else:\n        logger.warning(f\"Couldn't transmit data: {data!r}, Core isn't connected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot","title":"<code>MqttKevinbot</code>","text":"<p>               Bases: <code>BaseKevinbot</code></p> <p>KevinbotLib interface over MQTT</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class MqttKevinbot(BaseKevinbot):\n    \"\"\"KevinbotLib interface over MQTT\"\"\"\n\n    def __init__(self, cid: str | None = None) -&gt; None:\n        \"\"\"Instansiate a new KevinbotLib interface over MQTT\n\n        Args:\n            cid (str | None, optional): MQTT Client id. Defaults to an auto-generated uuid.\n        \"\"\"\n        super().__init__()\n        self.type = KevinbotConnectionType.MQTT\n\n        self.root_topic = \"kevinbot\"\n        self.host = \"localhost\"\n        self.port = 1883\n        self.keepalive = 60\n        self.connected = False\n\n        self._hb_thread: Thread | None = None  # thread to produce client's heartbeat\n        self._server_hb_thread: Thread | None = None  # thread to check in server heartbeat is slow/stopped\n\n        self._callback: Callable[[list[str], str], Any] | None = None  # message callback\n        self._on_server_startup: Callable[[], Any] | None = None\n        self._on_server_disconnect: Callable[[], Any] | None = None\n\n        self._eyes: MqttEyes | None = None\n\n        self.cid = cid if cid else f\"kevinbotlib-{shortuuid.random()}\"  # client id\n        self.client = Client(CallbackAPIVersion.VERSION2, self.cid)\n        self.client.on_message = self._on_message\n\n        atexit.register(self.disconnect)\n\n    @property\n    def callback(self) -&gt; Callable[[list[str], str], Any] | None:\n        return self._callback\n\n    @callback.setter\n    def callback(self, callback: Callable[[list[str], str], Any] | None) -&gt; None:\n        self._callback = callback\n\n    @property\n    def on_server_startup(self) -&gt; Callable[[], Any] | None:\n        return self._on_server_startup\n\n    @on_server_startup.setter\n    def on_server_startup(self, callback: Callable[[], Any] | None) -&gt; None:\n        self._on_server_startup = callback\n\n    @property\n    def on_server_disconnect(self) -&gt; Callable[[], Any] | None:\n        return self._on_server_disconnect\n\n    @on_server_disconnect.setter\n    def on_server_disconnect(self, callback: Callable[[], Any] | None) -&gt; None:\n        self._on_server_disconnect = callback\n\n    @property\n    def mqtt_connected(self) -&gt; bool:\n        return self.client.is_connected()\n\n    def connect(\n        self,\n        root_topic: str = \"kevinbot\",\n        host: str = \"localhost\",\n        port: int = 1883,\n        timeout: float = 5.0,\n        keepalive: int = 60,\n        heartbeat: float = 1.0,\n    ) -&gt; MQTTErrorCode:\n        \"\"\"Connect to MQTT Broker\n\n        Args:\n            root_topic (str, optional): Root communication topic. Defaults to \"kevinbot\".\n            host (str, optional): KevinbotLib server host. Defaults to \"localhost\".\n            port (int, optional): Kevinbot MQTT Broker port. Defaults to 1883.\n            timeout (float, optional): KevinbotLib connection timeout in seconds. Defaults to 5.\n            keepalive (int, optional): Maximum period in seconds between communications with the broker. Defaults to 60.\n            heartbeat (float, optional): Heartbeat interval in seconds. Defaults to 1.0.\n\n        Returns:\n            MQTTErrorCode: Connection error\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.keepalive = keepalive\n        self.root_topic = root_topic\n        self.connected = False\n\n        self._last_ts_update = datetime.fromtimestamp(0, timezone.utc)\n        self._last_server_hb = datetime.fromtimestamp(0, timezone.utc)\n\n        rc = self.client.connect(self.host, self.port, self.keepalive)\n        self.client.subscribe(f\"{self.root_topic}/state\", 0)\n        self.client.subscribe(f\"{self.root_topic}/eyes/state\", 0)\n        self.client.subscribe(f\"{self.root_topic}/serverstate\", 0)\n        self.client.subscribe(f\"{self.root_topic}/server/startup\", 0)\n        self.client.subscribe(f\"{self.root_topic}/server/shutdown\", 0)\n        self.client.subscribe(f\"{self.root_topic}/clients/connect/ack\", 0)\n        self.client.loop_start()\n\n        connect_time = time.time()\n        while (not self.server_state.mqtt_connected) or (self.server_state.heartbeat_freq == -1):\n            time.sleep(0.01)\n            if connect_time &lt; time.time() - timeout:\n                msg = \"KevinbotLib over MQTT handhsake timed out.\"\n                self.client.loop_stop()\n                self.client.disconnect()\n                raise HandshakeTimeoutException(msg)\n\n        self.connected = True\n\n        self.client.publish(f\"{self.root_topic}/clients/connect\", self.cid, 0)\n\n        self._hb_thread = Thread(target=self._hb_loop, args=(heartbeat,), daemon=True)\n        self._hb_thread.name = f\"KevinbotLib.Mqtt.Heartbeat:{self.cid}\"\n        self._hb_thread.start()\n\n        self._server_hb_thread = Thread(target=self._server_hb_loop, daemon=True)\n        self._server_hb_thread.name = f\"KevinbotLib.Mqtt.ServerHeartbeat:{self.cid}\"\n        self._server_hb_thread.start()\n\n        return rc\n\n    def _server_hb_loop(self):\n        while True:\n            if not self.connected:\n                break\n\n            if self.server_state.heartbeat_freq == -1:\n                time.sleep(1)\n                continue\n\n            if self._last_server_hb &lt; datetime.fromtimestamp(0, timezone.utc) - timedelta(\n                seconds=self.server_state.heartbeat_freq\n            ):\n                # server heartbeat is slow or stopped\n                self.connected = False\n                if self.on_server_disconnect:\n                    self.on_server_disconnect()\n\n            time.sleep(self.server_state.heartbeat_freq)\n\n    def _hb_loop(self, heartbeat: float):\n        while True:\n            if not self.connected:\n                break\n\n            self.client.publish(f\"{self.root_topic}/clients/heartbeat\", f\"{self.cid}:{self.ts.timestamp()}\", 0)\n            time.sleep(heartbeat)\n\n    def send(self, data: str):\n        \"\"\"Determine topic and publish data. Compatible with send of `SerialKevinbot`\n\n        Args:\n            data (str): Data to parse and publish\n        \"\"\"\n        if len(data.split(\"=\", 2)) &gt; 1:\n            cmd, val = data.split(\"=\", 2)\n        else:\n            cmd = data\n            val = None\n\n        self.client.publish(f\"{self.root_topic}/{cmd.replace('.', '/')}\", val, 0)\n\n    def disconnect(self):\n        \"\"\"Disconnect from server\"\"\"\n        super().disconnect()\n\n        if self.mqtt_connected:\n            self.client.publish(f\"{self.root_topic}/clients/disconnect\", self.cid, 0).wait_for_publish(1)\n            self.client.loop_stop()\n            self.client.disconnect()\n        self.connected = False\n\n    def request_enable(self) -&gt; int:\n        \"\"\"Request the core to enable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.client.publish(f\"{self.root_topic}/main/state_request\", \"enable\", 1)\n        return 1\n\n    def request_disable(self) -&gt; int:\n        \"\"\"Request the core to disable\n\n        Returns:\n            int: Always 1\n        \"\"\"\n        self.client.publish(f\"{self.root_topic}/main/state_request\", \"disable\", 1)\n        return 1\n\n    def e_stop(self):\n        \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n        self.client.publish(f\"{self.root_topic}/main/estop\", 1)\n\n    @property\n    def ts(self) -&gt; datetime:\n        \"\"\"\n        Get a semi-accurate timestamp from the server. Used for drivebase timeouts.\n\n        Returns:\n            datetime: Server time or UNIX timestamp 0 if server hasn't broadcasted a timestamp yet\n        \"\"\"\n        ts = self.server_state.timestamp\n        if ts:\n            ts += datetime.now(timezone.utc) - self._last_ts_update\n            return ts\n        return datetime.fromtimestamp(0, timezone.utc)\n\n    def _on_message(self, _, __, msg: MQTTMessage):\n        logger.trace(f\"Got MQTT message at: {msg.topic} payload={msg.payload!r} with qos={msg.qos}\")\n\n        if msg.topic[0] == \"/\" or msg.topic[-1] == \"/\":\n            logger.warning(f\"MQTT topic: {msg.topic} has a leading/trailing slash. Removing it.\")\n            topic = msg.topic.strip(\"/\")\n        else:\n            topic = msg.topic\n\n        value = msg.payload.decode(\"utf-8\")\n\n        subtopics = topic.split(\"/\")[1:]\n        match subtopics:\n            case [\"state\"]:\n                self._state = KevinbotState(**json.loads(value))\n            case [\"eyes\", \"state\"]:\n                if self._eyes:\n                    self._eyes._load_data(value)  # noqa: SLF001\n            case [\"serverstate\"]:\n                new_state = KevinbotServerState(**json.loads(value))\n\n                if self._server_state.timestamp != new_state.timestamp:\n                    self._last_ts_update = datetime.now(timezone.utc)\n\n                self._server_state = new_state\n            case [\"server\", \"startup\"]:\n                # we must reconnect\n                self.client.publish(f\"{self.root_topic}/clients/connect\", self.cid, 0)\n                self.connected = True\n\n                if self.on_server_startup:\n                    self.on_server_startup()\n            case [\"server\", \"shutdown\"]:\n                self.connected = False\n                if self.on_server_disconnect:\n                    self.on_server_disconnect()\n            case [\"clients\", \"connect\", \"ack\"]:\n                if value == f\"ack:{self.cid}\":\n                    self.connected = True\n\n        if self.callback:\n            self.callback(subtopics, value)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.ts","title":"<code>ts</code>  <code>property</code>","text":"<p>Get a semi-accurate timestamp from the server. Used for drivebase timeouts.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Server time or UNIX timestamp 0 if server hasn't broadcasted a timestamp yet</p>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.__init__","title":"<code>__init__(cid=None)</code>","text":"<p>Instansiate a new KevinbotLib interface over MQTT</p> <p>Parameters:</p> Name Type Description Default <code>cid</code> <code>str | None</code> <p>MQTT Client id. Defaults to an auto-generated uuid.</p> <code>None</code> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def __init__(self, cid: str | None = None) -&gt; None:\n    \"\"\"Instansiate a new KevinbotLib interface over MQTT\n\n    Args:\n        cid (str | None, optional): MQTT Client id. Defaults to an auto-generated uuid.\n    \"\"\"\n    super().__init__()\n    self.type = KevinbotConnectionType.MQTT\n\n    self.root_topic = \"kevinbot\"\n    self.host = \"localhost\"\n    self.port = 1883\n    self.keepalive = 60\n    self.connected = False\n\n    self._hb_thread: Thread | None = None  # thread to produce client's heartbeat\n    self._server_hb_thread: Thread | None = None  # thread to check in server heartbeat is slow/stopped\n\n    self._callback: Callable[[list[str], str], Any] | None = None  # message callback\n    self._on_server_startup: Callable[[], Any] | None = None\n    self._on_server_disconnect: Callable[[], Any] | None = None\n\n    self._eyes: MqttEyes | None = None\n\n    self.cid = cid if cid else f\"kevinbotlib-{shortuuid.random()}\"  # client id\n    self.client = Client(CallbackAPIVersion.VERSION2, self.cid)\n    self.client.on_message = self._on_message\n\n    atexit.register(self.disconnect)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.connect","title":"<code>connect(root_topic='kevinbot', host='localhost', port=1883, timeout=5.0, keepalive=60, heartbeat=1.0)</code>","text":"<p>Connect to MQTT Broker</p> <p>Parameters:</p> Name Type Description Default <code>root_topic</code> <code>str</code> <p>Root communication topic. Defaults to \"kevinbot\".</p> <code>'kevinbot'</code> <code>host</code> <code>str</code> <p>KevinbotLib server host. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Kevinbot MQTT Broker port. Defaults to 1883.</p> <code>1883</code> <code>timeout</code> <code>float</code> <p>KevinbotLib connection timeout in seconds. Defaults to 5.</p> <code>5.0</code> <code>keepalive</code> <code>int</code> <p>Maximum period in seconds between communications with the broker. Defaults to 60.</p> <code>60</code> <code>heartbeat</code> <code>float</code> <p>Heartbeat interval in seconds. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>MQTTErrorCode</code> <code>MQTTErrorCode</code> <p>Connection error</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def connect(\n    self,\n    root_topic: str = \"kevinbot\",\n    host: str = \"localhost\",\n    port: int = 1883,\n    timeout: float = 5.0,\n    keepalive: int = 60,\n    heartbeat: float = 1.0,\n) -&gt; MQTTErrorCode:\n    \"\"\"Connect to MQTT Broker\n\n    Args:\n        root_topic (str, optional): Root communication topic. Defaults to \"kevinbot\".\n        host (str, optional): KevinbotLib server host. Defaults to \"localhost\".\n        port (int, optional): Kevinbot MQTT Broker port. Defaults to 1883.\n        timeout (float, optional): KevinbotLib connection timeout in seconds. Defaults to 5.\n        keepalive (int, optional): Maximum period in seconds between communications with the broker. Defaults to 60.\n        heartbeat (float, optional): Heartbeat interval in seconds. Defaults to 1.0.\n\n    Returns:\n        MQTTErrorCode: Connection error\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.keepalive = keepalive\n    self.root_topic = root_topic\n    self.connected = False\n\n    self._last_ts_update = datetime.fromtimestamp(0, timezone.utc)\n    self._last_server_hb = datetime.fromtimestamp(0, timezone.utc)\n\n    rc = self.client.connect(self.host, self.port, self.keepalive)\n    self.client.subscribe(f\"{self.root_topic}/state\", 0)\n    self.client.subscribe(f\"{self.root_topic}/eyes/state\", 0)\n    self.client.subscribe(f\"{self.root_topic}/serverstate\", 0)\n    self.client.subscribe(f\"{self.root_topic}/server/startup\", 0)\n    self.client.subscribe(f\"{self.root_topic}/server/shutdown\", 0)\n    self.client.subscribe(f\"{self.root_topic}/clients/connect/ack\", 0)\n    self.client.loop_start()\n\n    connect_time = time.time()\n    while (not self.server_state.mqtt_connected) or (self.server_state.heartbeat_freq == -1):\n        time.sleep(0.01)\n        if connect_time &lt; time.time() - timeout:\n            msg = \"KevinbotLib over MQTT handhsake timed out.\"\n            self.client.loop_stop()\n            self.client.disconnect()\n            raise HandshakeTimeoutException(msg)\n\n    self.connected = True\n\n    self.client.publish(f\"{self.root_topic}/clients/connect\", self.cid, 0)\n\n    self._hb_thread = Thread(target=self._hb_loop, args=(heartbeat,), daemon=True)\n    self._hb_thread.name = f\"KevinbotLib.Mqtt.Heartbeat:{self.cid}\"\n    self._hb_thread.start()\n\n    self._server_hb_thread = Thread(target=self._server_hb_loop, daemon=True)\n    self._server_hb_thread.name = f\"KevinbotLib.Mqtt.ServerHeartbeat:{self.cid}\"\n    self._server_hb_thread.start()\n\n    return rc\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.send","title":"<code>send(data)</code>","text":"<p>Determine topic and publish data. Compatible with send of <code>SerialKevinbot</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to parse and publish</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Determine topic and publish data. Compatible with send of `SerialKevinbot`\n\n    Args:\n        data (str): Data to parse and publish\n    \"\"\"\n    if len(data.split(\"=\", 2)) &gt; 1:\n        cmd, val = data.split(\"=\", 2)\n    else:\n        cmd = data\n        val = None\n\n    self.client.publish(f\"{self.root_topic}/{cmd.replace('.', '/')}\", val, 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from server</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect from server\"\"\"\n    super().disconnect()\n\n    if self.mqtt_connected:\n        self.client.publish(f\"{self.root_topic}/clients/disconnect\", self.cid, 0).wait_for_publish(1)\n        self.client.loop_stop()\n        self.client.disconnect()\n    self.connected = False\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.request_enable","title":"<code>request_enable()</code>","text":"<p>Request the core to enable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_enable(self) -&gt; int:\n    \"\"\"Request the core to enable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.client.publish(f\"{self.root_topic}/main/state_request\", \"enable\", 1)\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.request_disable","title":"<code>request_disable()</code>","text":"<p>Request the core to disable</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def request_disable(self) -&gt; int:\n    \"\"\"Request the core to disable\n\n    Returns:\n        int: Always 1\n    \"\"\"\n    self.client.publish(f\"{self.root_topic}/main/state_request\", \"disable\", 1)\n    return 1\n</code></pre>"},{"location":"reference/#kevinbotlib.core.MqttKevinbot.e_stop","title":"<code>e_stop()</code>","text":"<p>Attempt to send and E-Stop signal to the Core</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def e_stop(self):\n    \"\"\"Attempt to send and E-Stop signal to the Core\"\"\"\n    self.client.publish(f\"{self.root_topic}/main/estop\", 1)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase","title":"<code>Drivebase</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Drivebase subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Drivebase(BaseKevinbotSubsystem):\n    \"\"\"Drivebase subsystem for Kevinbot\"\"\"\n\n    def get_amps(self) -&gt; list[float]:\n        \"\"\"Get the amps being used by the drivebase\n\n        Returns:\n            list[float]: Amps\n        \"\"\"\n        return self.robot.get_state().motion.amps\n\n    def get_watts(self) -&gt; list[float]:\n        \"\"\"Get the watts being used by the drivebase\n\n        Returns:\n            list[float]: Watts\n        \"\"\"\n        return self.robot.get_state().motion.watts\n\n    def get_powers(self) -&gt; list[float]:\n        \"\"\"Get the currently set wheel speeds in percent\n\n        Returns:\n            tuple[int, int]: Percent values from 0 to 1\n        \"\"\"\n        return self.robot.get_state().motion.powers\n\n    def get_states(self) -&gt; list[MotorDriveStatus]:\n        \"\"\"Get the wheels states\n\n        Returns:\n            list[MotorDriveStatus]: States\n        \"\"\"\n        return self.robot.get_state().motion.status\n\n    def drive_at_power(self, left: float, right: float):\n        \"\"\"Set the drive power for wheels. 0 to 1\n\n        Args:\n            left (float): Left motor power\n            right (float): Right motor power\n        \"\"\"\n        if isinstance(self.robot, SerialKevinbot):\n            self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n        elif isinstance(self.robot, MqttKevinbot):\n            self.robot.client.publish(\n                f\"{self.robot.root_topic}/drive/power\",\n                f\"{int(left*100)},{int(right*100)},{self.robot.cid},{self.robot.ts}\",\n                1,\n            )\n\n    def stop(self):\n        \"\"\"Set all wheel powers to 0\"\"\"\n        self.drive_at_power(0, 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_amps","title":"<code>get_amps()</code>","text":"<p>Get the amps being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Amps</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_amps(self) -&gt; list[float]:\n    \"\"\"Get the amps being used by the drivebase\n\n    Returns:\n        list[float]: Amps\n    \"\"\"\n    return self.robot.get_state().motion.amps\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_watts","title":"<code>get_watts()</code>","text":"<p>Get the watts being used by the drivebase</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Watts</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_watts(self) -&gt; list[float]:\n    \"\"\"Get the watts being used by the drivebase\n\n    Returns:\n        list[float]: Watts\n    \"\"\"\n    return self.robot.get_state().motion.watts\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_powers","title":"<code>get_powers()</code>","text":"<p>Get the currently set wheel speeds in percent</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>tuple[int, int]: Percent values from 0 to 1</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_powers(self) -&gt; list[float]:\n    \"\"\"Get the currently set wheel speeds in percent\n\n    Returns:\n        tuple[int, int]: Percent values from 0 to 1\n    \"\"\"\n    return self.robot.get_state().motion.powers\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.get_states","title":"<code>get_states()</code>","text":"<p>Get the wheels states</p> <p>Returns:</p> Type Description <code>list[MotorDriveStatus]</code> <p>list[MotorDriveStatus]: States</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_states(self) -&gt; list[MotorDriveStatus]:\n    \"\"\"Get the wheels states\n\n    Returns:\n        list[MotorDriveStatus]: States\n    \"\"\"\n    return self.robot.get_state().motion.status\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.drive_at_power","title":"<code>drive_at_power(left, right)</code>","text":"<p>Set the drive power for wheels. 0 to 1</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>float</code> <p>Left motor power</p> required <code>right</code> <code>float</code> <p>Right motor power</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def drive_at_power(self, left: float, right: float):\n    \"\"\"Set the drive power for wheels. 0 to 1\n\n    Args:\n        left (float): Left motor power\n        right (float): Right motor power\n    \"\"\"\n    if isinstance(self.robot, SerialKevinbot):\n        self.robot.send(f\"drive.power={int(left*100)},{int(right*100)}\")\n    elif isinstance(self.robot, MqttKevinbot):\n        self.robot.client.publish(\n            f\"{self.robot.root_topic}/drive/power\",\n            f\"{int(left*100)},{int(right*100)},{self.robot.cid},{self.robot.ts}\",\n            1,\n        )\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Drivebase.stop","title":"<code>stop()</code>","text":"<p>Set all wheel powers to 0</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def stop(self):\n    \"\"\"Set all wheel powers to 0\"\"\"\n    self.drive_at_power(0, 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servo","title":"<code>Servo</code>","text":"<p>Individually controllable servo</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Servo:\n    \"\"\"Individually controllable servo\"\"\"\n\n    def __init__(self, robot: SerialKevinbot | MqttKevinbot, index: int) -&gt; None:\n        self.robot = robot\n        self.index = index\n\n    @property\n    def bank(self) -&gt; int:\n        \"\"\"Get the bank the servo is in\n\n        Returns:\n            int: Bank number\n        \"\"\"\n        return self.index // 16\n\n    @property\n    def angle(self) -&gt; int:\n        \"\"\"Get the optimistic current servo angle\n\n        Returns:\n            int: Angle in degrees\n        \"\"\"\n        return self.robot.get_state().servos.angles[self.index]\n\n    @angle.setter\n    def angle(self, angle: int):\n        \"\"\"Set the optimistic servo angle\n\n        Args:\n            angle (int): Angle in degrees\n        \"\"\"\n        if isinstance(self.robot, SerialKevinbot):\n            self.robot.send(f\"s={self.index},{angle}\")\n        elif isinstance(self.robot, MqttKevinbot):\n            self.robot.client.publish(f\"{self.robot.root_topic}/servo/set\", f\"{self.index},{angle}\", 0)\n        else:\n            return\n\n        self.robot.get_state().servos.angles[self.index] = angle\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servo.bank","title":"<code>bank</code>  <code>property</code>","text":"<p>Get the bank the servo is in</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Bank number</p>"},{"location":"reference/#kevinbotlib.core.Servo.angle","title":"<code>angle</code>  <code>property</code> <code>writable</code>","text":"<p>Get the optimistic current servo angle</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Angle in degrees</p>"},{"location":"reference/#kevinbotlib.core.Servos","title":"<code>Servos</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Servo subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Servos(BaseKevinbotSubsystem):\n    \"\"\"Servo subsystem for Kevinbot\"\"\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"Length will always be 32 since the P2 Kevinbot Board can only control 32\n\n        Returns:\n            int: Number of servos in the subsystem\n        \"\"\"\n        return 32\n\n    def __iter__(self):\n        for i in range(self.__len__()):\n            yield Servo(self.robot, i)\n\n    def __getitem__(self, index: int):\n        if index &gt; self.__len__():\n            msg = f\"Servo index {index} &gt; {self.__len__()}\"\n            raise IndexError(msg)\n        if index &lt; 0:\n            msg = f\"Servo index {index} &lt; 0\"\n            raise IndexError(msg)\n        return Servo(self.robot, index)\n\n    def get_servo(self, channel: int) -&gt; Servo:\n        \"\"\"Get an individual servo in the subsystem\n\n        Args:\n            channel (int): PWM Port\n\n        Returns:\n            Servo: Individual servo\n        \"\"\"\n        if channel &gt; self.__len__() or channel &lt; 0:\n            msg = f\"Servo channel {channel} is out of bounds.\"\n            raise IndexError(msg)\n        return Servo(self.robot, channel)\n\n    @property\n    def all(self) -&gt; int:\n        if all(i == self.robot.get_state().servos.angles[0] for i in self.robot.get_state().servos.angles):\n            return self.robot.get_state().servos.angles[0]\n        return -1\n\n    @all.setter\n    def all(self, angle: int):\n        self.robot.send(f\"servo.all={angle}\")\n        self.robot.get_state().servos.angles = [angle] * self.__len__()\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servos.__len__","title":"<code>__len__()</code>","text":"<p>Length will always be 32 since the P2 Kevinbot Board can only control 32</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of servos in the subsystem</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Length will always be 32 since the P2 Kevinbot Board can only control 32\n\n    Returns:\n        int: Number of servos in the subsystem\n    \"\"\"\n    return 32\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Servos.get_servo","title":"<code>get_servo(channel)</code>","text":"<p>Get an individual servo in the subsystem</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>PWM Port</p> required <p>Returns:</p> Name Type Description <code>Servo</code> <code>Servo</code> <p>Individual servo</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_servo(self, channel: int) -&gt; Servo:\n    \"\"\"Get an individual servo in the subsystem\n\n    Args:\n        channel (int): PWM Port\n\n    Returns:\n        Servo: Individual servo\n    \"\"\"\n    if channel &gt; self.__len__() or channel &lt; 0:\n        msg = f\"Servo channel {channel} is out of bounds.\"\n        raise IndexError(msg)\n    return Servo(self.robot, channel)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting","title":"<code>Lighting</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> <p>Lighting subsystem for Kevinbot</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Lighting(BaseKevinbotSubsystem):\n    \"\"\"Lighting subsystem for Kevinbot\"\"\"\n\n    class Channel(Enum):\n        \"\"\"Lighting segment identifier\"\"\"\n\n        Head = \"head\"\n        Body = \"body\"\n        Base = \"base\"\n\n    def get_state(self) -&gt; LightingState:\n        \"\"\"Get the state of the robot's light segments\n\n        Returns:\n            LightingState: State\n        \"\"\"\n        return self.robot.get_state().lighting\n\n    def set_cam_brightness(self, brightness: int):\n        \"\"\"Set brightness of camera illumination\n\n        Args:\n            brightness (int): Brightness from 0 to 255\n        \"\"\"\n        self.robot.send(f\"lighting.cam.bright={brightness}\")\n        self.robot.get_state().lighting.camera = brightness\n\n    def set_brightness(self, channel: Channel, brightness: int):\n        \"\"\"Set the brightness of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            brightness (int): Brightness from 0 to 255\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.bright={brightness}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_bright = brightness\n            case self.Channel.Body:\n                self.robot.get_state().lighting.body_bright = brightness\n            case self.Channel.Head:\n                self.robot.get_state().lighting.head_bright = brightness\n\n    def set_color1(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n        \"\"\"Set the Color 1 of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            color (Iterable[int]): RGB Color values. Must have a length of 3\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.color1={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_color1 = list(color)\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_color1 = list(color)\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_color1 = list(color)\n\n    def set_color2(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n        \"\"\"Set the Color 2 of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            color (Iterable[int]): RGB Color values. Must have a length of 3\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.color2={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_color2 = list(color)\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_color2 = list(color)\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_color2 = list(color)\n\n    def set_effect(self, channel: Channel, effect: str):\n        \"\"\"Set the animation of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            effect (str): Animation ID\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.effect={effect}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_effect = effect\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_effect = effect\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_effect = effect\n\n    def set_update(self, channel: Channel, update: int):\n        \"\"\"Set the animation of a lighting segment\n\n        Args:\n            channel (Channel): Base, Body, or Head\n            update (int): Update rate (no fixed unit)\n        \"\"\"\n        self.robot.send(f\"lighting.{channel.value}.update={update}\")\n        match channel:\n            case self.Channel.Base:\n                self.robot.get_state().lighting.base_update = update\n            case self.Channel.Body:\n                self.robot.get_state().lighting.base_update = update\n            case self.Channel.Head:\n                self.robot.get_state().lighting.base_update = update\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Lighting segment identifier</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>class Channel(Enum):\n    \"\"\"Lighting segment identifier\"\"\"\n\n    Head = \"head\"\n    Body = \"body\"\n    Base = \"base\"\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.get_state","title":"<code>get_state()</code>","text":"<p>Get the state of the robot's light segments</p> <p>Returns:</p> Name Type Description <code>LightingState</code> <code>LightingState</code> <p>State</p> Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def get_state(self) -&gt; LightingState:\n    \"\"\"Get the state of the robot's light segments\n\n    Returns:\n        LightingState: State\n    \"\"\"\n    return self.robot.get_state().lighting\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_cam_brightness","title":"<code>set_cam_brightness(brightness)</code>","text":"<p>Set brightness of camera illumination</p> <p>Parameters:</p> Name Type Description Default <code>brightness</code> <code>int</code> <p>Brightness from 0 to 255</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_cam_brightness(self, brightness: int):\n    \"\"\"Set brightness of camera illumination\n\n    Args:\n        brightness (int): Brightness from 0 to 255\n    \"\"\"\n    self.robot.send(f\"lighting.cam.bright={brightness}\")\n    self.robot.get_state().lighting.camera = brightness\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_brightness","title":"<code>set_brightness(channel, brightness)</code>","text":"<p>Set the brightness of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>brightness</code> <code>int</code> <p>Brightness from 0 to 255</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_brightness(self, channel: Channel, brightness: int):\n    \"\"\"Set the brightness of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        brightness (int): Brightness from 0 to 255\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.bright={brightness}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_bright = brightness\n        case self.Channel.Body:\n            self.robot.get_state().lighting.body_bright = brightness\n        case self.Channel.Head:\n            self.robot.get_state().lighting.head_bright = brightness\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_color1","title":"<code>set_color1(channel, color)</code>","text":"<p>Set the Color 1 of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>color</code> <code>Iterable[int]</code> <p>RGB Color values. Must have a length of 3</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_color1(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n    \"\"\"Set the Color 1 of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        color (Iterable[int]): RGB Color values. Must have a length of 3\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.color1={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_color1 = list(color)\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_color1 = list(color)\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_color1 = list(color)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_color2","title":"<code>set_color2(channel, color)</code>","text":"<p>Set the Color 2 of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>color</code> <code>Iterable[int]</code> <p>RGB Color values. Must have a length of 3</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_color2(self, channel: Channel, color: list[int] | tuple[int, int, int]):\n    \"\"\"Set the Color 2 of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        color (Iterable[int]): RGB Color values. Must have a length of 3\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.color2={color[0]:02x}{color[1]:02x}{color[2]:02x}00\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_color2 = list(color)\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_color2 = list(color)\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_color2 = list(color)\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_effect","title":"<code>set_effect(channel, effect)</code>","text":"<p>Set the animation of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>effect</code> <code>str</code> <p>Animation ID</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_effect(self, channel: Channel, effect: str):\n    \"\"\"Set the animation of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        effect (str): Animation ID\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.effect={effect}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_effect = effect\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_effect = effect\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_effect = effect\n</code></pre>"},{"location":"reference/#kevinbotlib.core.Lighting.set_update","title":"<code>set_update(channel, update)</code>","text":"<p>Set the animation of a lighting segment</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Base, Body, or Head</p> required <code>update</code> <code>int</code> <p>Update rate (no fixed unit)</p> required Source code in <code>src/kevinbotlib/core.py</code> <pre><code>def set_update(self, channel: Channel, update: int):\n    \"\"\"Set the animation of a lighting segment\n\n    Args:\n        channel (Channel): Base, Body, or Head\n        update (int): Update rate (no fixed unit)\n    \"\"\"\n    self.robot.send(f\"lighting.{channel.value}.update={update}\")\n    match channel:\n        case self.Channel.Base:\n            self.robot.get_state().lighting.base_update = update\n        case self.Channel.Body:\n            self.robot.get_state().lighting.base_update = update\n        case self.Channel.Head:\n            self.robot.get_state().lighting.base_update = update\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes._Simple","title":"<code>_Simple</code>","text":"Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>class _Simple:\n    def __init__(self, skinmgr: \"_EyeSkinManager\") -&gt; None:\n        self.skinmgr = skinmgr\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get internal name of skin\n\n        Returns:\n            str: Internal name\n        \"\"\"\n        return \"simple\"\n\n    @property\n    def bg_color(self) -&gt; str:\n        \"\"\"Get background color of skin\n\n        Returns:\n            str: Hex-formatted color code\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.simple.bg_color\n\n    @bg_color.setter\n    def bg_color(self, value: str):\n        self.skinmgr.eyes.set_skin_option([self.name, \"bg_color\", value])\n\n    @property\n    def iris_color(self) -&gt; str:\n        \"\"\"Get iris color of skin\n\n        Returns:\n            str: Hex-formatted color code\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.simple.iris_color\n\n    @iris_color.setter\n    def iris_color(self, value: str):\n        self.skinmgr.eyes.set_skin_option([self.name, \"iris_color\", value])\n\n    @property\n    def pupil_color(self) -&gt; str:\n        \"\"\"Get pupil color of skin\n\n        Returns:\n            str: Hex-formatted color code\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.simple.pupil_color\n\n    @pupil_color.setter\n    def pupil_color(self, value: str):\n        self.skinmgr.eyes.set_skin_option([self.name, \"pupil_color\", value])\n\n    @property\n    def iris_size(self) -&gt; int:\n        \"\"\"Get iris size of skin\n\n        Returns:\n            int: Iris size in pixels\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.simple.iris_size\n\n    @iris_size.setter\n    def iris_size(self, value: int):\n        self.skinmgr.eyes.set_skin_option([self.name, \"iris_size\", value])\n\n    @property\n    def pupil_size(self) -&gt; int:\n        \"\"\"Get pupil size of skin\n\n        Returns:\n            int: Pupil size in pixels\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.simple.pupil_size\n\n    @pupil_size.setter\n    def pupil_size(self, value: int):\n        self.skinmgr.eyes.set_skin_option([self.name, \"pupil_size\", value])\n\n    def restore(self):\n        \"\"\"Restore simple skin settings to their defaults\"\"\"\n\n        self.bg_color = SimpleSkin().bg_color\n        self.iris_color = SimpleSkin().iris_color\n        self.pupil_color = SimpleSkin().pupil_color\n        self.iris_size = SimpleSkin().iris_size\n        self.pupil_size = SimpleSkin().pupil_size\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes._Simple.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get internal name of skin</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Internal name</p>"},{"location":"reference/#kevinbotlib.eyes._Simple.bg_color","title":"<code>bg_color</code>  <code>property</code> <code>writable</code>","text":"<p>Get background color of skin</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hex-formatted color code</p>"},{"location":"reference/#kevinbotlib.eyes._Simple.iris_color","title":"<code>iris_color</code>  <code>property</code> <code>writable</code>","text":"<p>Get iris color of skin</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hex-formatted color code</p>"},{"location":"reference/#kevinbotlib.eyes._Simple.pupil_color","title":"<code>pupil_color</code>  <code>property</code> <code>writable</code>","text":"<p>Get pupil color of skin</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hex-formatted color code</p>"},{"location":"reference/#kevinbotlib.eyes._Simple.iris_size","title":"<code>iris_size</code>  <code>property</code> <code>writable</code>","text":"<p>Get iris size of skin</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Iris size in pixels</p>"},{"location":"reference/#kevinbotlib.eyes._Simple.pupil_size","title":"<code>pupil_size</code>  <code>property</code> <code>writable</code>","text":"<p>Get pupil size of skin</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Pupil size in pixels</p>"},{"location":"reference/#kevinbotlib.eyes._Simple.restore","title":"<code>restore()</code>","text":"<p>Restore simple skin settings to their defaults</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def restore(self):\n    \"\"\"Restore simple skin settings to their defaults\"\"\"\n\n    self.bg_color = SimpleSkin().bg_color\n    self.iris_color = SimpleSkin().iris_color\n    self.pupil_color = SimpleSkin().pupil_color\n    self.iris_size = SimpleSkin().iris_size\n    self.pupil_size = SimpleSkin().pupil_size\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes._Metal","title":"<code>_Metal</code>","text":"Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>class _Metal:\n    def __init__(self, skinmgr: \"_EyeSkinManager\") -&gt; None:\n        self.skinmgr = skinmgr\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get internal name of skin\n        Returns:\n        str: Internal name\n        \"\"\"\n        return \"metal\"\n\n    @property\n    def bg_color(self) -&gt; str:\n        \"\"\"Get background color of skin\n        Returns:\n        str: Hex-formatted color code\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.metal.bg_color\n\n    @bg_color.setter\n    def bg_color(self, value: str):\n        self.skinmgr.eyes.set_skin_option([self.name, \"bg_color\", value])\n\n    @property\n    def iris_size(self) -&gt; int:\n        \"\"\"Get iris size of skin\n        Returns:\n        int: Iris size in pixels\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.metal.iris_size\n\n    @iris_size.setter\n    def iris_size(self, value: int):\n        self.skinmgr.eyes.set_skin_option([self.name, \"iris_size\", value])\n\n    @property\n    def tint(self) -&gt; int:\n        \"\"\"Get tint value of metal skin\n        Returns:\n        int: Tint value\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.metal.tint\n\n    @tint.setter\n    def tint(self, value: int):\n        self.skinmgr.eyes.set_skin_option([self.name, \"tint\", value])\n\n    def restore(self):\n        \"\"\"Restore metal skin settings to their defaults\"\"\"\n        self.bg_color = MetalSkin().bg_color\n        self.iris_size = MetalSkin().iris_size\n        self.tint = MetalSkin().tint\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes._Metal.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get internal name of skin Returns: str: Internal name</p>"},{"location":"reference/#kevinbotlib.eyes._Metal.bg_color","title":"<code>bg_color</code>  <code>property</code> <code>writable</code>","text":"<p>Get background color of skin Returns: str: Hex-formatted color code</p>"},{"location":"reference/#kevinbotlib.eyes._Metal.iris_size","title":"<code>iris_size</code>  <code>property</code> <code>writable</code>","text":"<p>Get iris size of skin Returns: int: Iris size in pixels</p>"},{"location":"reference/#kevinbotlib.eyes._Metal.tint","title":"<code>tint</code>  <code>property</code> <code>writable</code>","text":"<p>Get tint value of metal skin Returns: int: Tint value</p>"},{"location":"reference/#kevinbotlib.eyes._Metal.restore","title":"<code>restore()</code>","text":"<p>Restore metal skin settings to their defaults</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def restore(self):\n    \"\"\"Restore metal skin settings to their defaults\"\"\"\n    self.bg_color = MetalSkin().bg_color\n    self.iris_size = MetalSkin().iris_size\n    self.tint = MetalSkin().tint\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes._Neon","title":"<code>_Neon</code>","text":"Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>class _Neon:\n    def __init__(self, skinmgr: \"_EyeSkinManager\") -&gt; None:\n        self.skinmgr = skinmgr\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get internal name of skin\n        Returns:\n        str: Internal name\n        \"\"\"\n        return \"neon\"\n\n    @property\n    def bg_color(self) -&gt; str:\n        \"\"\"Get background color of skin\n        Returns:\n        str: Hex-formatted color code\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.neon.bg_color\n\n    @bg_color.setter\n    def bg_color(self, value: str):\n        self.skinmgr.eyes.set_skin_option([self.name, \"bg_color\", value])\n\n    @property\n    def iris_size(self) -&gt; int:\n        \"\"\"Get iris size of skin\n        Returns:\n        int: Iris size in pixels\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.neon.iris_size\n\n    @iris_size.setter\n    def iris_size(self, value: int):\n        self.skinmgr.eyes.set_skin_option([self.name, \"iris_size\", value])\n\n    @property\n    def fg_color_start(self) -&gt; str:\n        \"\"\"Get foreground start color of neon skin\n        Returns:\n        str: Hex-formatted color code\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.neon.fg_color_start\n\n    @fg_color_start.setter\n    def fg_color_start(self, value: str):\n        self.skinmgr.eyes.set_skin_option([self.name, \"fg_color_start\", value])\n\n    @property\n    def fg_color_end(self) -&gt; str:\n        \"\"\"Get foreground end color of neon skin\n        Returns:\n        str: Hex-formatted color code\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.neon.fg_color_end\n\n    @fg_color_end.setter\n    def fg_color_end(self, value: str):\n        self.skinmgr.eyes.set_skin_option([self.name, \"fg_color_end\", value])\n\n    @property\n    def style(self) -&gt; str:\n        \"\"\"Get style of neon skin\n        Returns:\n        str: Filename of internal iris/pupil image\n        \"\"\"\n        return self.skinmgr.eyes.get_state().settings.skins.neon.style\n\n    @style.setter\n    def style(self, value: str):\n        self.skinmgr.eyes.set_skin_option([self.name, \"style\", value])\n\n    def restore(self):\n        \"\"\"Restore neon skin settings to their defaults\"\"\"\n        self.bg_color = NeonSkin().bg_color\n        self.iris_size = NeonSkin().iris_size\n        self.fg_color_start = NeonSkin().fg_color_start\n        self.fg_color_end = NeonSkin().fg_color_end\n        self.style = NeonSkin().style\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes._Neon.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get internal name of skin Returns: str: Internal name</p>"},{"location":"reference/#kevinbotlib.eyes._Neon.bg_color","title":"<code>bg_color</code>  <code>property</code> <code>writable</code>","text":"<p>Get background color of skin Returns: str: Hex-formatted color code</p>"},{"location":"reference/#kevinbotlib.eyes._Neon.iris_size","title":"<code>iris_size</code>  <code>property</code> <code>writable</code>","text":"<p>Get iris size of skin Returns: int: Iris size in pixels</p>"},{"location":"reference/#kevinbotlib.eyes._Neon.fg_color_start","title":"<code>fg_color_start</code>  <code>property</code> <code>writable</code>","text":"<p>Get foreground start color of neon skin Returns: str: Hex-formatted color code</p>"},{"location":"reference/#kevinbotlib.eyes._Neon.fg_color_end","title":"<code>fg_color_end</code>  <code>property</code> <code>writable</code>","text":"<p>Get foreground end color of neon skin Returns: str: Hex-formatted color code</p>"},{"location":"reference/#kevinbotlib.eyes._Neon.style","title":"<code>style</code>  <code>property</code> <code>writable</code>","text":"<p>Get style of neon skin Returns: str: Filename of internal iris/pupil image</p>"},{"location":"reference/#kevinbotlib.eyes._Neon.restore","title":"<code>restore()</code>","text":"<p>Restore neon skin settings to their defaults</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def restore(self):\n    \"\"\"Restore neon skin settings to their defaults\"\"\"\n    self.bg_color = NeonSkin().bg_color\n    self.iris_size = NeonSkin().iris_size\n    self.fg_color_start = NeonSkin().fg_color_start\n    self.fg_color_end = NeonSkin().fg_color_end\n    self.style = NeonSkin().style\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes._EyeSkinManager","title":"<code>_EyeSkinManager</code>","text":"Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>class _EyeSkinManager:\n    def __init__(self, eyes: \"BaseKevinbotEyes\") -&gt; None:\n        self.eyes = eyes\n\n    @property\n    def simple(self) -&gt; _Simple:\n        \"\"\"Get settings for simple eye skin\n\n        Returns:\n            _Simple: Settings manager\n        \"\"\"\n        return _Simple(self)\n\n    @property\n    def metal(self) -&gt; _Metal:\n        \"\"\"Get settings for metal eye skin\n\n        Returns:\n            _Metal: Settings manager\n        \"\"\"\n        return _Metal(self)\n\n    @property\n    def neon(self) -&gt; _Neon:\n        \"\"\"Get settings for neon eye skin\n\n        Returns:\n            _Neon: Settings manager\n        \"\"\"\n        return _Neon(self)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes._EyeSkinManager.simple","title":"<code>simple</code>  <code>property</code>","text":"<p>Get settings for simple eye skin</p> <p>Returns:</p> Name Type Description <code>_Simple</code> <code>_Simple</code> <p>Settings manager</p>"},{"location":"reference/#kevinbotlib.eyes._EyeSkinManager.metal","title":"<code>metal</code>  <code>property</code>","text":"<p>Get settings for metal eye skin</p> <p>Returns:</p> Name Type Description <code>_Metal</code> <code>_Metal</code> <p>Settings manager</p>"},{"location":"reference/#kevinbotlib.eyes._EyeSkinManager.neon","title":"<code>neon</code>  <code>property</code>","text":"<p>Get settings for neon eye skin</p> <p>Returns:</p> Name Type Description <code>_Neon</code> <code>_Neon</code> <p>Settings manager</p>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes","title":"<code>BaseKevinbotEyes</code>","text":"<p>The base Kevinbot Eyes class.</p> <p>Not to be used directly</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>class BaseKevinbotEyes:\n    \"\"\"The base Kevinbot Eyes class.\n\n    Not to be used directly\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._state = KevinbotEyesState()\n        self.type = KevinbotConnectionType.BASE\n\n        self._skin_manager = _EyeSkinManager(self)\n\n        self._auto_disconnect = True\n\n        self._callbacks = {}\n\n        self._robot: MqttKevinbot = MqttKevinbot()\n\n    def get_state(self) -&gt; KevinbotEyesState:\n        \"\"\"Gets the current state of the eyes\n\n        Returns:\n            KevinbotEyesState: State class\n        \"\"\"\n        return self._state\n\n    def disconnect(self):\n        \"\"\"Basic disconnect\"\"\"\n        self._state.connected = False\n\n    def register_callback(self, callback_type: EyeCallbackType, callback: Callable[[Any], Any]):\n        \"\"\"Register a callback for a specific property.\"\"\"\n        if callback_type not in self._callbacks:\n            self._callbacks[callback_type] = []\n        self._callbacks[callback_type].append(callback)\n\n    def unregister_callback(self, callback_type: EyeCallbackType, callback: Callable):\n        \"\"\"Unregister a callback for a specific property.\"\"\"\n        if callback_type in self._callbacks:\n            try:\n                self._callbacks[callback_type].remove(callback)\n                # Clean up the property if no callbacks remain\n                if not self._callbacks[callback_type]:\n                    del self._callbacks[callback_type]\n            except ValueError:\n                logger.warning(f\"Callback not found for property: {callback_type}\")\n\n    def unregister_callbacks(self, callback_type: EyeCallbackType):\n        \"\"\"Unregister all callbacks for a specific property.\"\"\"\n        if callback_type in self._callbacks:\n            try:\n                self._callbacks[callback_type].clear()\n                # Clean up the property if no callbacks remain\n                if not self._callbacks[callback_type]:\n                    del self._callbacks[callback_type]\n            except ValueError:\n                logger.warning(f\"Callback not found for property: {callback_type}\")\n\n    def _trigger_callback(self, callback_type: EyeCallbackType, value: Any):\n        \"\"\"Trigger all registered callbacks for a property.\"\"\"\n        if callback_type in self._callbacks:\n            for callback in self._callbacks[callback_type]:\n                callback(value)\n\n    @property\n    def auto_disconnect(self) -&gt; bool:\n        \"\"\"Getter for auto disconnect state.\n\n        Returns:\n            bool: Whether to disconnect on application exit\n        \"\"\"\n        return self._auto_disconnect\n\n    @auto_disconnect.setter\n    def auto_disconnect(self, value: bool):\n        \"\"\"Setter for auto disconnect.\n\n        Args:\n            value (bool): Whether to disconnect on application exit\n        \"\"\"\n        self._auto_disconnect = value\n        if value:\n            atexit.register(self.disconnect)\n        else:\n            atexit.unregister(self.disconnect)\n\n    def send(self, data: str):\n        \"\"\"Null implementation of the send method\n\n        Args:\n            data (str): Data to send nowhere\n\n        Raises:\n            NotImplementedError: Always raised\n        \"\"\"\n        msg = f\"Function not implemented, attempting to send {data}\"\n        raise NotImplementedError(msg)\n\n    def set_skin(self, skin: EyeSkin):\n        \"\"\"Set the current skin\n\n        Args:\n            skin (EyeSkin): Skin index\n        \"\"\"\n        if isinstance(self, SerialEyes):\n            self._state.settings.states.page = skin\n            if self._state.settings.states.page != skin:\n                self._trigger_callback(EyeCallbackType(\"states.page\"), skin)\n            self.send(f\"setState={skin.value}\")\n        elif isinstance(self, MqttEyes):\n            self._robot.client.publish(f\"{self._robot.root_topic}/eyes/skin\", skin.value, 0)\n\n    def set_backlight(self, bl: float):\n        \"\"\"Set the current backlight brightness\n\n        Args:\n            bl (float): Brightness from 0 to 1\n        \"\"\"\n        if isinstance(self, SerialEyes):\n            self._state.settings.display.backlight = min(int(bl * 100), 100)\n            self.send(f\"setBacklight={self._state.settings.display.backlight}\")\n            if self._state.settings.display.backlight != bl:\n                self._trigger_callback(EyeCallbackType(\"settings.display.backlight\"), bl)\n        elif isinstance(self, MqttEyes):\n            self._robot.client.publish(f\"{self._robot.root_topic}/eyes/backlight\", int(255 * bl), 0)\n\n    def get_backlight(self) -&gt; float:\n        \"\"\"Get the current backlight setting\n\n        Returns:\n            float: Value from 0 to 1\n        \"\"\"\n        return self._state.settings.display.backlight / 255\n\n    def set_motion(self, motion: EyeMotion):\n        \"\"\"Set the current backlight brightness\n\n        Args:\n            motion (EyeMotion): Motion mode\n        \"\"\"\n        if isinstance(self, SerialEyes):\n            if self._state.settings.states.motion != motion:\n                self._trigger_callback(EyeCallbackType(\"states.motion\"), motion)\n            self._state.settings.states.motion = motion\n            self.send(f\"setMotion={motion.value}\")\n        elif isinstance(self, MqttEyes):\n            self._robot.client.publish(f\"{self._robot.root_topic}/eyes/motion\", motion.value, 0)\n\n    def set_manual_pos(self, x: int, y: int):\n        \"\"\"Set the on-screen position of pupil\n\n        Args:\n            x (int): X Position of pupil\n            y (int): Y Position of pupil\n        \"\"\"\n        if isinstance(self, SerialEyes):\n            if self._state.settings.motions.pos != (x, y):\n                self._trigger_callback(EyeCallbackType(\"motions.pos\"), (x, y))\n            self._state.settings.motions.pos = x, y\n            self.send(f\"setPosition={x},{y}\")\n        elif isinstance(self, MqttEyes):\n            self._robot.client.publish(f\"{self._robot.root_topic}/eyes/pos\", f\"{x},{y}\", 0)\n\n    def set_skin_option(self, data: list):\n        \"\"\"Set a raw skin option.\n\n        Args:\n            data (list): list of keys, last item is the value\n        \"\"\"\n        if len(data) &lt; 3:  # noqa: PLR2004\n            logger.error(\"Data must have at least 2 keys and one value.\")\n            return\n\n        keys = data[:-1]\n        value = data[-1]\n\n        skin_key = keys[0]\n        if skin_key not in self._state.settings.skins.model_dump():\n            logger.error(f\"Invalid skin key: {skin_key}\")\n            return\n\n        skin = getattr(self._state.settings.skins, skin_key)\n        for key in keys[1:]:\n            if not hasattr(skin, key):\n                logger.error(f\"Invalid key '{key}' for skin '{skin_key}'\")\n                return\n            if keys.index(key) == len(keys[1:]) - 1:  # Final attribute to set\n                setattr(skin, key, value)\n            else:\n                skin = getattr(skin, key)\n\n        if isinstance(self, SerialEyes):\n            self.send(f\"setSkinOption={':'.join(map(str, data))}\")\n            prop_path = \".\".join(keys[1:])\n            current_value = getattr(getattr(self._state.settings.skins, skin_key), prop_path, None)\n            if current_value != value:\n                self._trigger_callback(EyeCallbackType(f\"skins.{skin_key}.{prop_path}\"), value)\n\n        elif isinstance(self, MqttEyes):\n            self._robot.client.publish(f\"{self._robot.root_topic}/eyes/skinopt\", \":\".join(map(str, data)), 0)\n\n    @property\n    def skins(self) -&gt; _EyeSkinManager:\n        return self._skin_manager\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.auto_disconnect","title":"<code>auto_disconnect</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for auto disconnect state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to disconnect on application exit</p>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.get_state","title":"<code>get_state()</code>","text":"<p>Gets the current state of the eyes</p> <p>Returns:</p> Name Type Description <code>KevinbotEyesState</code> <code>KevinbotEyesState</code> <p>State class</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def get_state(self) -&gt; KevinbotEyesState:\n    \"\"\"Gets the current state of the eyes\n\n    Returns:\n        KevinbotEyesState: State class\n    \"\"\"\n    return self._state\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.disconnect","title":"<code>disconnect()</code>","text":"<p>Basic disconnect</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def disconnect(self):\n    \"\"\"Basic disconnect\"\"\"\n    self._state.connected = False\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.register_callback","title":"<code>register_callback(callback_type, callback)</code>","text":"<p>Register a callback for a specific property.</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def register_callback(self, callback_type: EyeCallbackType, callback: Callable[[Any], Any]):\n    \"\"\"Register a callback for a specific property.\"\"\"\n    if callback_type not in self._callbacks:\n        self._callbacks[callback_type] = []\n    self._callbacks[callback_type].append(callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.unregister_callback","title":"<code>unregister_callback(callback_type, callback)</code>","text":"<p>Unregister a callback for a specific property.</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def unregister_callback(self, callback_type: EyeCallbackType, callback: Callable):\n    \"\"\"Unregister a callback for a specific property.\"\"\"\n    if callback_type in self._callbacks:\n        try:\n            self._callbacks[callback_type].remove(callback)\n            # Clean up the property if no callbacks remain\n            if not self._callbacks[callback_type]:\n                del self._callbacks[callback_type]\n        except ValueError:\n            logger.warning(f\"Callback not found for property: {callback_type}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.unregister_callbacks","title":"<code>unregister_callbacks(callback_type)</code>","text":"<p>Unregister all callbacks for a specific property.</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def unregister_callbacks(self, callback_type: EyeCallbackType):\n    \"\"\"Unregister all callbacks for a specific property.\"\"\"\n    if callback_type in self._callbacks:\n        try:\n            self._callbacks[callback_type].clear()\n            # Clean up the property if no callbacks remain\n            if not self._callbacks[callback_type]:\n                del self._callbacks[callback_type]\n        except ValueError:\n            logger.warning(f\"Callback not found for property: {callback_type}\")\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes._trigger_callback","title":"<code>_trigger_callback(callback_type, value)</code>","text":"<p>Trigger all registered callbacks for a property.</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def _trigger_callback(self, callback_type: EyeCallbackType, value: Any):\n    \"\"\"Trigger all registered callbacks for a property.\"\"\"\n    if callback_type in self._callbacks:\n        for callback in self._callbacks[callback_type]:\n            callback(value)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.send","title":"<code>send(data)</code>","text":"<p>Null implementation of the send method</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send nowhere</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Null implementation of the send method\n\n    Args:\n        data (str): Data to send nowhere\n\n    Raises:\n        NotImplementedError: Always raised\n    \"\"\"\n    msg = f\"Function not implemented, attempting to send {data}\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.set_skin","title":"<code>set_skin(skin)</code>","text":"<p>Set the current skin</p> <p>Parameters:</p> Name Type Description Default <code>skin</code> <code>EyeSkin</code> <p>Skin index</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def set_skin(self, skin: EyeSkin):\n    \"\"\"Set the current skin\n\n    Args:\n        skin (EyeSkin): Skin index\n    \"\"\"\n    if isinstance(self, SerialEyes):\n        self._state.settings.states.page = skin\n        if self._state.settings.states.page != skin:\n            self._trigger_callback(EyeCallbackType(\"states.page\"), skin)\n        self.send(f\"setState={skin.value}\")\n    elif isinstance(self, MqttEyes):\n        self._robot.client.publish(f\"{self._robot.root_topic}/eyes/skin\", skin.value, 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.set_backlight","title":"<code>set_backlight(bl)</code>","text":"<p>Set the current backlight brightness</p> <p>Parameters:</p> Name Type Description Default <code>bl</code> <code>float</code> <p>Brightness from 0 to 1</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def set_backlight(self, bl: float):\n    \"\"\"Set the current backlight brightness\n\n    Args:\n        bl (float): Brightness from 0 to 1\n    \"\"\"\n    if isinstance(self, SerialEyes):\n        self._state.settings.display.backlight = min(int(bl * 100), 100)\n        self.send(f\"setBacklight={self._state.settings.display.backlight}\")\n        if self._state.settings.display.backlight != bl:\n            self._trigger_callback(EyeCallbackType(\"settings.display.backlight\"), bl)\n    elif isinstance(self, MqttEyes):\n        self._robot.client.publish(f\"{self._robot.root_topic}/eyes/backlight\", int(255 * bl), 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.get_backlight","title":"<code>get_backlight()</code>","text":"<p>Get the current backlight setting</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Value from 0 to 1</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def get_backlight(self) -&gt; float:\n    \"\"\"Get the current backlight setting\n\n    Returns:\n        float: Value from 0 to 1\n    \"\"\"\n    return self._state.settings.display.backlight / 255\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.set_motion","title":"<code>set_motion(motion)</code>","text":"<p>Set the current backlight brightness</p> <p>Parameters:</p> Name Type Description Default <code>motion</code> <code>EyeMotion</code> <p>Motion mode</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def set_motion(self, motion: EyeMotion):\n    \"\"\"Set the current backlight brightness\n\n    Args:\n        motion (EyeMotion): Motion mode\n    \"\"\"\n    if isinstance(self, SerialEyes):\n        if self._state.settings.states.motion != motion:\n            self._trigger_callback(EyeCallbackType(\"states.motion\"), motion)\n        self._state.settings.states.motion = motion\n        self.send(f\"setMotion={motion.value}\")\n    elif isinstance(self, MqttEyes):\n        self._robot.client.publish(f\"{self._robot.root_topic}/eyes/motion\", motion.value, 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.set_manual_pos","title":"<code>set_manual_pos(x, y)</code>","text":"<p>Set the on-screen position of pupil</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X Position of pupil</p> required <code>y</code> <code>int</code> <p>Y Position of pupil</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def set_manual_pos(self, x: int, y: int):\n    \"\"\"Set the on-screen position of pupil\n\n    Args:\n        x (int): X Position of pupil\n        y (int): Y Position of pupil\n    \"\"\"\n    if isinstance(self, SerialEyes):\n        if self._state.settings.motions.pos != (x, y):\n            self._trigger_callback(EyeCallbackType(\"motions.pos\"), (x, y))\n        self._state.settings.motions.pos = x, y\n        self.send(f\"setPosition={x},{y}\")\n    elif isinstance(self, MqttEyes):\n        self._robot.client.publish(f\"{self._robot.root_topic}/eyes/pos\", f\"{x},{y}\", 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.BaseKevinbotEyes.set_skin_option","title":"<code>set_skin_option(data)</code>","text":"<p>Set a raw skin option.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list</code> <p>list of keys, last item is the value</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def set_skin_option(self, data: list):\n    \"\"\"Set a raw skin option.\n\n    Args:\n        data (list): list of keys, last item is the value\n    \"\"\"\n    if len(data) &lt; 3:  # noqa: PLR2004\n        logger.error(\"Data must have at least 2 keys and one value.\")\n        return\n\n    keys = data[:-1]\n    value = data[-1]\n\n    skin_key = keys[0]\n    if skin_key not in self._state.settings.skins.model_dump():\n        logger.error(f\"Invalid skin key: {skin_key}\")\n        return\n\n    skin = getattr(self._state.settings.skins, skin_key)\n    for key in keys[1:]:\n        if not hasattr(skin, key):\n            logger.error(f\"Invalid key '{key}' for skin '{skin_key}'\")\n            return\n        if keys.index(key) == len(keys[1:]) - 1:  # Final attribute to set\n            setattr(skin, key, value)\n        else:\n            skin = getattr(skin, key)\n\n    if isinstance(self, SerialEyes):\n        self.send(f\"setSkinOption={':'.join(map(str, data))}\")\n        prop_path = \".\".join(keys[1:])\n        current_value = getattr(getattr(self._state.settings.skins, skin_key), prop_path, None)\n        if current_value != value:\n            self._trigger_callback(EyeCallbackType(f\"skins.{skin_key}.{prop_path}\"), value)\n\n    elif isinstance(self, MqttEyes):\n        self._robot.client.publish(f\"{self._robot.root_topic}/eyes/skinopt\", \":\".join(map(str, data)), 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes","title":"<code>SerialEyes</code>","text":"<p>               Bases: <code>BaseKevinbotEyes</code></p> <p>The main serial Kevinbot Eyes class</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>class SerialEyes(BaseKevinbotEyes):\n    \"\"\"The main serial Kevinbot Eyes class\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.type = KevinbotConnectionType.SERIAL\n\n        self.serial: Serial | None = None\n        self.rx_thread: Thread | None = None\n\n        self._callback: Callable[[str, str | None], Any] | None = None\n        self._state_callback: Callable[[KevinbotEyesState], Any] | None = None\n\n        atexit.register(self.disconnect)\n\n    def connect(\n        self,\n        port: str,\n        baud: int,\n        timeout: float,\n        ser_timeout: float = 0.5,\n    ):\n        \"\"\"Start a connection with Kevinbot Eyes\n\n        Args:\n            port (str): Serial port to use (`/dev/ttyUSB0` is standard with the typical Kevinbot Hardware)\n            baud (int): Baud rate to use (`115200` is typical for the defualt eye configs)\n            timeout (float): Timeout for handshake\n            ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n\n        Raises:\n            HandshakeTimeoutException: Eyes didn't respond to the connection handshake before the timeout\n        \"\"\"\n        serial = self._setup_serial(port, baud, ser_timeout)\n\n        start_time = time.monotonic()\n        hs_started = False\n        while True:\n            if not hs_started:\n                serial.write(b\"connectionReady\\n\")\n\n            line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n            if line == \"handshake.request\":\n                hs_started = True\n                serial.write(b\"getSettings=true\\n\")\n\n            if line == \"settTx.done\":\n                serial.write(b\"handshake.complete\\n\")\n                break\n\n            data = line.split(\"=\", 2)\n            cmd = line.split(\"=\", 2)[0]\n            val = line.split(\"=\", 2)[1] if len(data) &gt; 1 else None\n\n            if cmd.startswith(\"eyeSettings.\"):\n                # Remove prefix and split into path and value\n                setting = cmd[len(\"eyeSettings.\") :]\n\n                path = setting.split(\".\")\n\n                if not val:\n                    logger.error(f\"Got eyeSettings command without a value: {cmd} :: {val}\")\n                    continue\n\n                # Handle array values [x, y]\n                if val.startswith(\"[\") and val.endswith(\"]\"):\n                    value_str = val.strip(\"[]\")\n                    value = tuple(int(x.strip()) for x in value_str.split(\",\"))\n                # Handle hex colors\n                elif val.startswith(\"#\"):\n                    value = val\n                # Handle quoted strings\n                elif val.startswith('\"') and val.endswith('\"'):\n                    value = val.strip('\"')\n                # Handle numbers\n                else:\n                    try:\n                        value = int(val)\n                    except ValueError:\n                        value = val\n\n                # Create a dict representation of the settings\n                settings_dict = self._state.settings.model_dump()\n\n                # Navigate to the correct nested dictionary\n                current_dict = settings_dict\n                for i, key in enumerate(path[:-1]):\n                    if key not in current_dict:\n                        logger.error(f\"Invalid path: {'.'.join(path[:i+1])}\")\n                        continue\n                    if not isinstance(current_dict[key], dict):\n                        logger.error(f\"Cannot navigate through non-dict value at {'.'.join(path[:i+1])}\")\n                        continue\n                    current_dict = current_dict[key]\n\n                # Update the value\n                if path[-1] not in current_dict:\n                    logger.error(f\"Invalid setting: {'.'.join(path)}\")\n                    continue\n                current_dict[path[-1]] = value\n\n                # Create new settings instance with updated values\n                self._state.settings = EyeSettings.model_validate(settings_dict)\n\n            if time.monotonic() - start_time &gt; timeout:\n                msg = \"Handshake timed out\"\n                raise HandshakeTimeoutException(msg)\n\n            time.sleep(0.1)  # Avoid spamming the connection\n\n        # Data rx thread\n        self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n        self.rx_thread.name = \"KevinbotLib.Eyes.Rx\"\n        self.rx_thread.start()\n\n        self._state.connected = True\n\n    def disconnect(self):\n        super().disconnect()\n        if self.serial and self.serial.is_open:\n            self.send(\"resetConnection\")\n            self.serial.flush()\n            self.serial.close()\n        else:\n            logger.warning(\"Already disconnected\")\n\n    def update(self):\n        \"\"\"Retrive updated settings from eyes\"\"\"\n\n        self.send(\"getSettings=true\")\n\n    @property\n    def on_state_updated(self) -&gt; Callable[[KevinbotEyesState], Any] | None:\n        return self._state_callback\n\n    @on_state_updated.setter\n    def on_state_updated(self, callback: Callable[[KevinbotEyesState], Any] | None):\n        self._state_callback = callback\n\n    def send(self, data: str):\n        \"\"\"Send a string through serial.\n\n        Automatically adds a newline.\n\n        Args:\n            data (str): Data to send\n        \"\"\"\n        self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n\n    def raw_tx(self, data: bytes):\n        \"\"\"Send raw bytes over serial.\n\n        Args:\n            data (bytes): Raw data\n        \"\"\"\n        if self.serial:\n            self.serial.write(data)\n        else:\n            logger.warning(f\"Couldn't transmit data: {data!r}, Eyes aren't connected\")\n\n    @property\n    def callback(self) -&gt; Callable[[str, str | None], Any] | None:\n        return self._callback\n\n    @callback.setter\n    def callback(self, callback: Callable[[str, str | None], Any]) -&gt; None:\n        self._callback = callback\n\n    def _setup_serial(self, port: str, baud: int, timeout: float = 1):\n        self.serial = Serial(port, baud, timeout=timeout)\n        return self.serial\n\n    def _rx_loop(self, serial: Serial, delimeter: str = \"=\"):\n        while True:\n            try:\n                raw: bytes = serial.readline()\n            except TypeError:\n                # serial has been stopped\n                return\n\n            cmd: str = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[0].strip().replace(\"\\00\", \"\")\n            if not cmd:\n                continue\n\n            val: str | None = None\n            if len(raw.decode(\"utf-8\").split(delimeter)) &gt; 1:\n                val = raw.decode(\"utf-8\").split(delimeter, maxsplit=1)[1].strip(\"\\r\\n\").replace(\"\\00\", \"\")\n\n            if cmd.startswith(\"eyeSettings.\"):\n                # Remove prefix and split into path and value\n                setting = cmd[len(\"eyeSettings.\") :]\n\n                path = setting.split(\".\")\n\n                if not val:\n                    logger.error(f\"Got eyeSettings command without a value: {cmd} :: {val}\")\n                    continue\n\n                # Handle array values [x, y]\n                if val.startswith(\"[\") and val.endswith(\"]\"):\n                    value_str = val.strip(\"[]\")\n                    value = tuple(int(x.strip()) for x in value_str.split(\",\"))\n                # Handle hex colors\n                elif val.startswith(\"#\"):\n                    value = val\n                # Handle quoted strings\n                elif val.startswith('\"') and val.endswith('\"'):\n                    value = val.strip('\"')\n                # Handle numbers\n                else:\n                    try:\n                        value = int(val)\n                    except ValueError:\n                        value = val\n\n                # Create a dict representation of the settings\n                settings_dict = self._state.settings.model_dump()\n\n                # Navigate to the correct nested dictionary\n                current_dict = settings_dict\n                for i, key in enumerate(path[:-1]):\n                    if key not in current_dict:\n                        logger.error(f\"Invalid path: {'.'.join(path[:i+1])}\")\n                        continue\n                    if not isinstance(current_dict[key], dict):\n                        logger.error(f\"Cannot navigate through non-dict value at {'.'.join(path[:i+1])}\")\n                        continue\n                    current_dict = current_dict[key]\n\n                # Update the value\n                if path[-1] not in current_dict:\n                    logger.error(f\"Invalid setting: {'.'.join(path)}\")\n                    continue\n                current_dict[path[-1]] = value\n\n                # Create new settings instance with updated values\n                self._state.settings = EyeSettings.model_validate(settings_dict)\n            else:\n                match cmd:\n                    case \"settTx.done\":\n                        if self.on_state_updated:\n                            self.on_state_updated(self._state)\n\n            if self.callback:\n                self.callback(cmd, val)\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes.connect","title":"<code>connect(port, baud, timeout, ser_timeout=0.5)</code>","text":"<p>Start a connection with Kevinbot Eyes</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port to use (<code>/dev/ttyUSB0</code> is standard with the typical Kevinbot Hardware)</p> required <code>baud</code> <code>int</code> <p>Baud rate to use (<code>115200</code> is typical for the defualt eye configs)</p> required <code>timeout</code> <code>float</code> <p>Timeout for handshake</p> required <code>ser_timeout</code> <code>float</code> <p>Readline timeout, should be lower than <code>timeout</code>. Defaults to 0.5.</p> <code>0.5</code> <p>Raises:</p> Type Description <code>HandshakeTimeoutException</code> <p>Eyes didn't respond to the connection handshake before the timeout</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def connect(\n    self,\n    port: str,\n    baud: int,\n    timeout: float,\n    ser_timeout: float = 0.5,\n):\n    \"\"\"Start a connection with Kevinbot Eyes\n\n    Args:\n        port (str): Serial port to use (`/dev/ttyUSB0` is standard with the typical Kevinbot Hardware)\n        baud (int): Baud rate to use (`115200` is typical for the defualt eye configs)\n        timeout (float): Timeout for handshake\n        ser_timeout (float, optional): Readline timeout, should be lower than `timeout`. Defaults to 0.5.\n\n    Raises:\n        HandshakeTimeoutException: Eyes didn't respond to the connection handshake before the timeout\n    \"\"\"\n    serial = self._setup_serial(port, baud, ser_timeout)\n\n    start_time = time.monotonic()\n    hs_started = False\n    while True:\n        if not hs_started:\n            serial.write(b\"connectionReady\\n\")\n\n        line = serial.readline().decode(\"utf-8\", errors=\"ignore\").strip(\"\\n\")\n\n        if line == \"handshake.request\":\n            hs_started = True\n            serial.write(b\"getSettings=true\\n\")\n\n        if line == \"settTx.done\":\n            serial.write(b\"handshake.complete\\n\")\n            break\n\n        data = line.split(\"=\", 2)\n        cmd = line.split(\"=\", 2)[0]\n        val = line.split(\"=\", 2)[1] if len(data) &gt; 1 else None\n\n        if cmd.startswith(\"eyeSettings.\"):\n            # Remove prefix and split into path and value\n            setting = cmd[len(\"eyeSettings.\") :]\n\n            path = setting.split(\".\")\n\n            if not val:\n                logger.error(f\"Got eyeSettings command without a value: {cmd} :: {val}\")\n                continue\n\n            # Handle array values [x, y]\n            if val.startswith(\"[\") and val.endswith(\"]\"):\n                value_str = val.strip(\"[]\")\n                value = tuple(int(x.strip()) for x in value_str.split(\",\"))\n            # Handle hex colors\n            elif val.startswith(\"#\"):\n                value = val\n            # Handle quoted strings\n            elif val.startswith('\"') and val.endswith('\"'):\n                value = val.strip('\"')\n            # Handle numbers\n            else:\n                try:\n                    value = int(val)\n                except ValueError:\n                    value = val\n\n            # Create a dict representation of the settings\n            settings_dict = self._state.settings.model_dump()\n\n            # Navigate to the correct nested dictionary\n            current_dict = settings_dict\n            for i, key in enumerate(path[:-1]):\n                if key not in current_dict:\n                    logger.error(f\"Invalid path: {'.'.join(path[:i+1])}\")\n                    continue\n                if not isinstance(current_dict[key], dict):\n                    logger.error(f\"Cannot navigate through non-dict value at {'.'.join(path[:i+1])}\")\n                    continue\n                current_dict = current_dict[key]\n\n            # Update the value\n            if path[-1] not in current_dict:\n                logger.error(f\"Invalid setting: {'.'.join(path)}\")\n                continue\n            current_dict[path[-1]] = value\n\n            # Create new settings instance with updated values\n            self._state.settings = EyeSettings.model_validate(settings_dict)\n\n        if time.monotonic() - start_time &gt; timeout:\n            msg = \"Handshake timed out\"\n            raise HandshakeTimeoutException(msg)\n\n        time.sleep(0.1)  # Avoid spamming the connection\n\n    # Data rx thread\n    self.rx_thread = Thread(target=self._rx_loop, args=(serial, \"=\"), daemon=True)\n    self.rx_thread.name = \"KevinbotLib.Eyes.Rx\"\n    self.rx_thread.start()\n\n    self._state.connected = True\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes.update","title":"<code>update()</code>","text":"<p>Retrive updated settings from eyes</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def update(self):\n    \"\"\"Retrive updated settings from eyes\"\"\"\n\n    self.send(\"getSettings=true\")\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes.send","title":"<code>send(data)</code>","text":"<p>Send a string through serial.</p> <p>Automatically adds a newline.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data to send</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def send(self, data: str):\n    \"\"\"Send a string through serial.\n\n    Automatically adds a newline.\n\n    Args:\n        data (str): Data to send\n    \"\"\"\n    self.raw_tx((data + \"\\n\").encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.SerialEyes.raw_tx","title":"<code>raw_tx(data)</code>","text":"<p>Send raw bytes over serial.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Raw data</p> required Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def raw_tx(self, data: bytes):\n    \"\"\"Send raw bytes over serial.\n\n    Args:\n        data (bytes): Raw data\n    \"\"\"\n    if self.serial:\n        self.serial.write(data)\n    else:\n        logger.warning(f\"Couldn't transmit data: {data!r}, Eyes aren't connected\")\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.MqttEyes","title":"<code>MqttEyes</code>","text":"<p>               Bases: <code>BaseKevinbotEyes</code></p> <p>The main serial Kevinbot Eyes class</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>class MqttEyes(BaseKevinbotEyes):\n    \"\"\"The main serial Kevinbot Eyes class\"\"\"\n\n    def __init__(self, robot: MqttKevinbot) -&gt; None:\n        super().__init__()\n        self.type = KevinbotConnectionType.MQTT\n\n        self.serial: Serial | None = None\n        self.rx_thread: Thread | None = None\n\n        self._callback: Callable[[str, str | None], Any] | None = None\n\n        self._robot: MqttKevinbot = robot\n        self._robot._eyes = self  # noqa: SLF001\n\n        self._state_loaded = False\n        robot.client.publish(f\"{robot.root_topic}/eyes/get\", \"request_settings\", 0)\n        self._robot.client.subscribe(f\"{self._robot.root_topic}/eyes/skinopt\")\n        self._robot.client.subscribe(f\"{self._robot.root_topic}/eyes/backlight\")\n        self._robot.client.subscribe(f\"{self._robot.root_topic}/eyes/motion\")\n        self._robot.client.subscribe(f\"{self._robot.root_topic}/eyes/skin\")\n        self._robot.client.message_callback_add(f\"{self._robot.root_topic}/eyes/skinopt\", self._process_skinopt_update)\n        self._robot.client.message_callback_add(\n            f\"{self._robot.root_topic}/eyes/backlight\", self._process_backlight_update\n        )\n        self._robot.client.message_callback_add(f\"{self._robot.root_topic}/eyes/motion\", self._process_motion_update)\n        self._robot.client.message_callback_add(f\"{self._robot.root_topic}/eyes/skin\", self._process_skin_update)\n\n        while not self._state_loaded:\n            time.sleep(0.01)\n\n        atexit.register(self.disconnect)\n\n    def update(self):\n        \"\"\"Retrive updated settings from eyes\"\"\"\n        self._robot.client.publish(f\"{self._robot.root_topic}/eyes/get\", \"request_settings\", 0)\n\n    def _process_skinopt_update(self, _client: Client, _obj, msg: MQTTMessage):\n        keys = msg.payload.decode(\"utf-8\").split(\":\")\n        value = keys.pop()\n        skin_name = keys[0]\n        prop_path = \".\".join(keys[1:])\n        old_value = getattr(getattr(self._state.settings.skins, skin_name), prop_path, None)\n\n        if old_value != value:\n            setattr(getattr(self._state.settings.skins, skin_name), prop_path, _safe_cast(old_value, value))\n            self._trigger_callback(EyeCallbackType(f\"skins.{skin_name}.{prop_path}\"), value)\n\n    def _process_backlight_update(self, _client: Client, _obj, msg: MQTTMessage):\n        new_value = int(msg.payload.decode(\"utf-8\"))\n        if new_value != self._state.settings.display.backlight:\n            self._state.settings.display.backlight = new_value\n            self._trigger_callback(EyeCallbackType.Backlight, new_value / 255)\n\n    def _process_motion_update(self, _client: Client, _obj, msg: MQTTMessage):\n        new_value = EyeMotion(int(msg.payload.decode(\"utf-8\")))\n        if new_value != self._state.settings.states.motion:\n            self._state.settings.states.motion = new_value\n            self._trigger_callback(EyeCallbackType.Motion, new_value)\n\n    def _process_skin_update(self, _client: Client, _obj, msg: MQTTMessage):\n        new_value = EyeSkin(int(msg.payload.decode(\"utf-8\")))\n        if new_value != self._state.settings.states.page:\n            self._state.settings.states.page = new_value\n            self._trigger_callback(EyeCallbackType.Skin, new_value)\n\n    def _load_data(self, data: str):\n        new_state = KevinbotEyesState(**json.loads(data))\n        for skin_name, skin_data in vars(new_state.settings.skins).items():\n            for prop, new_value in vars(skin_data).items():\n                old_value = getattr(getattr(self._state.settings.skins, skin_name), prop, None)\n                if old_value != new_value:\n                    self._trigger_callback(EyeCallbackType(f\"skins.{skin_name}.{prop}\"), new_value)\n        self._state = new_state\n        self._state_loaded = True\n</code></pre>"},{"location":"reference/#kevinbotlib.eyes.MqttEyes.update","title":"<code>update()</code>","text":"<p>Retrive updated settings from eyes</p> Source code in <code>src/kevinbotlib/eyes.py</code> <pre><code>def update(self):\n    \"\"\"Retrive updated settings from eyes\"\"\"\n    self._robot.client.publish(f\"{self._robot.root_topic}/eyes/get\", \"request_settings\", 0)\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio","title":"<code>WirelessRadio</code>","text":"<p>               Bases: <code>BaseKevinbotSubsystem</code></p> Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>@deprecated(\n    \"XBee radio support is deprecated. Please use WiFi or use a custom implementation. It will be removed in a future version\"\n)\nclass WirelessRadio(BaseKevinbotSubsystem):\n    def __init__(self, robot: SerialKevinbot, port: str, baud: int, api: int, timeout: float) -&gt; None:\n        \"\"\"Initialize Kevinbot Wireless Radio (XBee)\n\n        Args:\n            robot (Kevinbot): The main robot class\n            port (str): Serial port to connect to `/dev/ttyAMA0` for typical Kevinbot hardware\n            baud (int): Baud rate for serial interface `921600` for typical Kevinbot configs\n            api (int): API mode for xbee interface `2` for typical Kevinbot configs (`0` isn't supported yet)\n            timeout (float): Timeout for serial operations\n        \"\"\"\n        super().__init__(robot)\n\n        if api not in [1, 2]:\n            logger.error(f\"XBee API Mode {api} isn't supported. Assuming API escaped (2)\")\n            api = 2\n\n        self.callback: Callable | None = None\n\n        self.serial = Serial(port, baud, timeout=timeout)\n        self.xbee = xbee.XBee(self.serial, callback=self.callback)\n\n    def get(self) -&gt; dict:\n        \"\"\"Get the latest packet (blocking)\n\n        Returns:\n            dict: Data packet\n        \"\"\"\n        return self.xbee.wait_read_frame()\n\n    def disconnect(self):\n        \"\"\"Disconnect robot radio, and halt processing\"\"\"\n        self.xbee.halt()\n        self.serial.close()\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio.__init__","title":"<code>__init__(robot, port, baud, api, timeout)</code>","text":"<p>Initialize Kevinbot Wireless Radio (XBee)</p> <p>Parameters:</p> Name Type Description Default <code>robot</code> <code>Kevinbot</code> <p>The main robot class</p> required <code>port</code> <code>str</code> <p>Serial port to connect to <code>/dev/ttyAMA0</code> for typical Kevinbot hardware</p> required <code>baud</code> <code>int</code> <p>Baud rate for serial interface <code>921600</code> for typical Kevinbot configs</p> required <code>api</code> <code>int</code> <p>API mode for xbee interface <code>2</code> for typical Kevinbot configs (<code>0</code> isn't supported yet)</p> required <code>timeout</code> <code>float</code> <p>Timeout for serial operations</p> required Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>def __init__(self, robot: SerialKevinbot, port: str, baud: int, api: int, timeout: float) -&gt; None:\n    \"\"\"Initialize Kevinbot Wireless Radio (XBee)\n\n    Args:\n        robot (Kevinbot): The main robot class\n        port (str): Serial port to connect to `/dev/ttyAMA0` for typical Kevinbot hardware\n        baud (int): Baud rate for serial interface `921600` for typical Kevinbot configs\n        api (int): API mode for xbee interface `2` for typical Kevinbot configs (`0` isn't supported yet)\n        timeout (float): Timeout for serial operations\n    \"\"\"\n    super().__init__(robot)\n\n    if api not in [1, 2]:\n        logger.error(f\"XBee API Mode {api} isn't supported. Assuming API escaped (2)\")\n        api = 2\n\n    self.callback: Callable | None = None\n\n    self.serial = Serial(port, baud, timeout=timeout)\n    self.xbee = xbee.XBee(self.serial, callback=self.callback)\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio.get","title":"<code>get()</code>","text":"<p>Get the latest packet (blocking)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Data packet</p> Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>def get(self) -&gt; dict:\n    \"\"\"Get the latest packet (blocking)\n\n    Returns:\n        dict: Data packet\n    \"\"\"\n    return self.xbee.wait_read_frame()\n</code></pre>"},{"location":"reference/#kevinbotlib.xbee.WirelessRadio.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect robot radio, and halt processing</p> Source code in <code>src/kevinbotlib/xbee.py</code> <pre><code>def disconnect(self):\n    \"\"\"Disconnect robot radio, and halt processing\"\"\"\n    self.xbee.halt()\n    self.serial.close()\n</code></pre>"},{"location":"reference/#kevinbotlib.enums.CoreErrors","title":"<code>CoreErrors</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Kevinbot Core Error States</p> Source code in <code>src/kevinbotlib/enums.py</code> <pre><code>class CoreErrors(Enum):\n    \"\"\"\n    Kevinbot Core Error States\n    \"\"\"\n\n    OK = 0\n    \"\"\"No errors are present\"\"\"\n    UNKNOWN = 1\n    \"\"\"Error state unknown\"\"\"\n    OW_SHORT = 2\n    \"\"\"One-Wire bus is shorted\"\"\"\n    OW_ERROR = 3\n    \"\"\"One-Wire bus error\"\"\"\n    OW_DNF = 4\n    \"\"\"One-Wire device not found\"\"\"\n    LCD_INIT_FAIL = 5\n    \"\"\"LCD Init failed\"\"\"\n    PCA_INIT_FAIL = 6\n    \"\"\"PCA9685 (servos) init fail\"\"\"\n    TICK_FAIL = 7\n    \"\"\"Failure to recieve core tick\"\"\"\n    QUEUE_OVERRUN = 8\n    \"\"\"Serial queue overrun\"\"\"\n    ESTOP = 9\n    \"\"\"Core is in E-Stop state\"\"\"\n    BME_CHIP_ID = 10\n    \"\"\"Error getting environment sensor chip id\"\"\"\n    BME_CALIB_NVM = 11\n    \"\"\"Error with environment sensor calibration\"\"\"\n    BME_CALIB_TP = 12\n    \"\"\"Error with environment sensor calibration\"\"\"\n    BME_CALIB_HUM = 13\n    \"\"\"Error with environment sensor calibration\"\"\"\n    BME_THP = 14\n    \"\"\"Error with environment sensor\"\"\"\n    BME_MEAS_TIMEOUT = 15\n    \"\"\"Timeout with environment sensor measurement\"\"\"\n    BME_NOT_NORMAL_MODE = 16\n    \"\"\"Environemnt sensor is not in normal mode\"\"\"\n    BATT1_UV = 17\n    \"\"\"Battery #1 Undervoltage\"\"\"\n    BATT1_OV = 18\n    \"\"\"Battery #1 Overvoltage\"\"\"\n    BATT2_UV = 19\n    \"\"\"Battery #2 Undervoltage\"\"\"\n    BATT2_OV = 20\n    \"\"\"Battery #2 Overvoltage\"\"\"\n    BATT_UV = 21\n    \"\"\"Battery Undervoltage (single battery mode)\"\"\"\n    BATT_OV = 22\n    \"\"\"Battery Overvoltage (single battery mode)\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No errors are present</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error state unknown</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.OW_SHORT","title":"<code>OW_SHORT = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire bus is shorted</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.OW_ERROR","title":"<code>OW_ERROR = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire bus error</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.OW_DNF","title":"<code>OW_DNF = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>One-Wire device not found</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.LCD_INIT_FAIL","title":"<code>LCD_INIT_FAIL = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>LCD Init failed</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.PCA_INIT_FAIL","title":"<code>PCA_INIT_FAIL = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PCA9685 (servos) init fail</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.TICK_FAIL","title":"<code>TICK_FAIL = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Failure to recieve core tick</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.QUEUE_OVERRUN","title":"<code>QUEUE_OVERRUN = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Serial queue overrun</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.ESTOP","title":"<code>ESTOP = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Core is in E-Stop state</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BME_CHIP_ID","title":"<code>BME_CHIP_ID = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error getting environment sensor chip id</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BME_CALIB_NVM","title":"<code>BME_CALIB_NVM = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error with environment sensor calibration</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BME_CALIB_TP","title":"<code>BME_CALIB_TP = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error with environment sensor calibration</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BME_CALIB_HUM","title":"<code>BME_CALIB_HUM = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error with environment sensor calibration</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BME_THP","title":"<code>BME_THP = 14</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error with environment sensor</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BME_MEAS_TIMEOUT","title":"<code>BME_MEAS_TIMEOUT = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Timeout with environment sensor measurement</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BME_NOT_NORMAL_MODE","title":"<code>BME_NOT_NORMAL_MODE = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Environemnt sensor is not in normal mode</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BATT1_UV","title":"<code>BATT1_UV = 17</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery #1 Undervoltage</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BATT1_OV","title":"<code>BATT1_OV = 18</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery #1 Overvoltage</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BATT2_UV","title":"<code>BATT2_UV = 19</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery #2 Undervoltage</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BATT2_OV","title":"<code>BATT2_OV = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery #2 Overvoltage</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BATT_UV","title":"<code>BATT_UV = 21</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery Undervoltage (single battery mode)</p>"},{"location":"reference/#kevinbotlib.enums.CoreErrors.BATT_OV","title":"<code>BATT_OV = 22</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery Overvoltage (single battery mode)</p>"},{"location":"reference/#kevinbotlib.enums.MotorDriveStatus","title":"<code>MotorDriveStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of each motor in the drivebase</p> Source code in <code>src/kevinbotlib/enums.py</code> <pre><code>class MotorDriveStatus(Enum):\n    \"\"\"\n    The status of each motor in the drivebase\n    \"\"\"\n\n    UNKNOWN = 10\n    \"\"\"Motor status is unknown\"\"\"\n    MOVING = 11\n    \"\"\"Motor is rotating\"\"\"\n    HOLDING = 12\n    \"\"\"Motor is holding at position\"\"\"\n    OFF = 13\n    \"\"\"Motor is off\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.enums.MotorDriveStatus.UNKNOWN","title":"<code>UNKNOWN = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Motor status is unknown</p>"},{"location":"reference/#kevinbotlib.enums.MotorDriveStatus.MOVING","title":"<code>MOVING = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Motor is rotating</p>"},{"location":"reference/#kevinbotlib.enums.MotorDriveStatus.HOLDING","title":"<code>HOLDING = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Motor is holding at position</p>"},{"location":"reference/#kevinbotlib.enums.MotorDriveStatus.OFF","title":"<code>OFF = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Motor is off</p>"},{"location":"reference/#kevinbotlib.enums.BmsBatteryStatus","title":"<code>BmsBatteryStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The status of a single battery attached to the BMS</p> Source code in <code>src/kevinbotlib/enums.py</code> <pre><code>class BmsBatteryStatus(Enum):\n    \"\"\"\n    The status of a single battery attached to the BMS\n    \"\"\"\n\n    UNKNOWN = 0\n    \"\"\"State is unknown (usually at bootup)\"\"\"\n    NORMAL = 1\n    \"\"\"Battery is normal\"\"\"\n    UNDER = 2\n    \"\"\"Battery is undervoltage\"\"\"\n    OVER = 3\n    \"\"\"Battery is overvoltage\"\"\"\n    STOPPED = 4  # Stopped state if BMS driver crashed\n    \"\"\"BMS has crashed or stopped\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.enums.BmsBatteryStatus.UNKNOWN","title":"<code>UNKNOWN = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>State is unknown (usually at bootup)</p>"},{"location":"reference/#kevinbotlib.enums.BmsBatteryStatus.NORMAL","title":"<code>NORMAL = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery is normal</p>"},{"location":"reference/#kevinbotlib.enums.BmsBatteryStatus.UNDER","title":"<code>UNDER = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery is undervoltage</p>"},{"location":"reference/#kevinbotlib.enums.BmsBatteryStatus.OVER","title":"<code>OVER = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery is overvoltage</p>"},{"location":"reference/#kevinbotlib.enums.BmsBatteryStatus.STOPPED","title":"<code>STOPPED = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>BMS has crashed or stopped</p>"},{"location":"reference/#kevinbotlib.enums.EyeSkin","title":"<code>EyeSkin</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Eye Skins for the eye system</p> Source code in <code>src/kevinbotlib/enums.py</code> <pre><code>class EyeSkin(Enum):\n    \"\"\"\n    Eye Skins for the eye system\n    \"\"\"\n\n    TV_STATIC = 0\n    \"\"\"TV Static-style random colors\"\"\"\n    SIMPLE = 1\n    \"\"\"Simple skin with variable pupil, iris, and background\"\"\"\n    METAL = 2\n    \"\"\"Skin with fancy pupil and iris over an aluminum background\"\"\"\n    NEON = 3\n    \"\"\"Neon skin\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.enums.EyeSkin.TV_STATIC","title":"<code>TV_STATIC = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TV Static-style random colors</p>"},{"location":"reference/#kevinbotlib.enums.EyeSkin.SIMPLE","title":"<code>SIMPLE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Simple skin with variable pupil, iris, and background</p>"},{"location":"reference/#kevinbotlib.enums.EyeSkin.METAL","title":"<code>METAL = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Skin with fancy pupil and iris over an aluminum background</p>"},{"location":"reference/#kevinbotlib.enums.EyeSkin.NEON","title":"<code>NEON = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Neon skin</p>"},{"location":"reference/#kevinbotlib.enums.EyeMotion","title":"<code>EyeMotion</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Motion modes for the eye system</p> Source code in <code>src/kevinbotlib/enums.py</code> <pre><code>class EyeMotion(Enum):\n    \"\"\"\n    Motion modes for the eye system\n    \"\"\"\n\n    DISABLE = 0\n    \"\"\"No motion\"\"\"\n    LEFT_RIGHT = 1\n    \"\"\"Smooth left to right and back\"\"\"\n    JUMP = 2\n    \"\"\"Jumpy left to right and back\"\"\"\n    MANUAL = 3\n    \"\"\"Allow manual control of pupil position\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.enums.EyeMotion.DISABLE","title":"<code>DISABLE = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No motion</p>"},{"location":"reference/#kevinbotlib.enums.EyeMotion.LEFT_RIGHT","title":"<code>LEFT_RIGHT = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Smooth left to right and back</p>"},{"location":"reference/#kevinbotlib.enums.EyeMotion.JUMP","title":"<code>JUMP = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jumpy left to right and back</p>"},{"location":"reference/#kevinbotlib.enums.EyeMotion.MANUAL","title":"<code>MANUAL = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Allow manual control of pupil position</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType","title":"<code>EyeCallbackType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Callback triggers for eye data changes</p> Source code in <code>src/kevinbotlib/enums.py</code> <pre><code>class EyeCallbackType(Enum):\n    \"\"\"\n    Callback triggers for eye data changes\n    \"\"\"\n\n    \"\"\"Simple Skin Background Color\"\"\"\n    SimpleBgColor = \"skins.simple.bg_color\"\n    \"\"\"Simple Skin Iris Color\"\"\"\n    SimpleIrisColor = \"skins.simple.iris_color\"\n    \"\"\"Simple Skin Pupil Color\"\"\"\n    SimplePupilColor = \"skins.simple.pupil_color\"\n    \"\"\"Simple Skin Iris Size\"\"\"\n    SimpleIrisSize = \"skins.simple.iris_size\"\n    \"\"\"Simple Skin Pupil Size\"\"\"\n    SimplePupilSize = \"skins.simple.pupil_size\"\n\n    \"\"\"Metal Skin Background Color\"\"\"\n    MetalBgColor = \"skins.metal.bg_color\"\n    \"\"\"Metal Skin Tint\"\"\"\n    MetalTint = \"skins.metal.tint\"\n    \"\"\"Metal Skin Iris Size\"\"\"\n    MetalIrisSize = \"skins.metal.iris_size\"\n\n    \"\"\"Neon Skin Background Color\"\"\"\n    NeonBgColor = \"skins.neon.bg_color\"\n    \"\"\"Neon Skin Iris Size\"\"\"\n    NeonIrisSize = \"skins.neon.iris_size\"\n    \"\"\"Neon Skin Pupil Start Color\"\"\"\n    NeonPupilStartColor = \"skins.neon.fg_color_start\"\n    \"\"\"Neon Skin Pupil End Color\"\"\"\n    NeonPupilEndColor = \"skins.neon.fg_color_end\"\n    \"\"\"Neon Skin Style\"\"\"\n    NeonStyle = \"skins.neon.style\"\n\n    \"\"\"Skin\"\"\"\n    Skin = \"states.page\"\n    \"\"\"Backlight\"\"\"\n    Backlight = \"settings.display.backlight\"\n    \"\"\"Motion\"\"\"\n    Motion = \"states.motion\"\n    \"\"\"Manual Position\"\"\"\n    ManualPosition = \"motions.pos\"\n</code></pre>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.SimpleBgColor","title":"<code>SimpleBgColor = 'skins.simple.bg_color'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Simple Skin Iris Color</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.SimpleIrisColor","title":"<code>SimpleIrisColor = 'skins.simple.iris_color'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Simple Skin Pupil Color</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.SimplePupilColor","title":"<code>SimplePupilColor = 'skins.simple.pupil_color'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Simple Skin Iris Size</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.SimpleIrisSize","title":"<code>SimpleIrisSize = 'skins.simple.iris_size'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Simple Skin Pupil Size</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.SimplePupilSize","title":"<code>SimplePupilSize = 'skins.simple.pupil_size'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Metal Skin Background Color</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.MetalBgColor","title":"<code>MetalBgColor = 'skins.metal.bg_color'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Metal Skin Tint</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.MetalTint","title":"<code>MetalTint = 'skins.metal.tint'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Metal Skin Iris Size</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.MetalIrisSize","title":"<code>MetalIrisSize = 'skins.metal.iris_size'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Neon Skin Background Color</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.NeonBgColor","title":"<code>NeonBgColor = 'skins.neon.bg_color'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Neon Skin Iris Size</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.NeonIrisSize","title":"<code>NeonIrisSize = 'skins.neon.iris_size'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Neon Skin Pupil Start Color</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.NeonPupilStartColor","title":"<code>NeonPupilStartColor = 'skins.neon.fg_color_start'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Neon Skin Pupil End Color</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.NeonPupilEndColor","title":"<code>NeonPupilEndColor = 'skins.neon.fg_color_end'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Neon Skin Style</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.NeonStyle","title":"<code>NeonStyle = 'skins.neon.style'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Skin</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.Skin","title":"<code>Skin = 'states.page'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Backlight</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.Backlight","title":"<code>Backlight = 'settings.display.backlight'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Motion</p>"},{"location":"reference/#kevinbotlib.enums.EyeCallbackType.Motion","title":"<code>Motion = 'states.motion'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Manual Position</p>"},{"location":"reference/#kevinbotlib.models.DrivebaseState","title":"<code>DrivebaseState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the drivebase as a whole</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class DrivebaseState(BaseModel):\n    \"\"\"The state of the drivebase as a whole\"\"\"\n\n    powers: list[float] = Field(default_factory=lambda: [0.0, 0.0])\n    \"\"\"Current power of the motors\"\"\"\n    amps: list[float] = Field(default_factory=lambda: [0, 0])\n    \"\"\"Current amps for both motors\"\"\"\n    watts: list[float] = Field(default_factory=lambda: [0, 0])\n    \"\"\"Current watts for both motors\"\"\"\n    status: list[MotorDriveStatus] = Field(default_factory=lambda: [MotorDriveStatus.UNKNOWN, MotorDriveStatus.UNKNOWN])\n    \"\"\"Current status for both motors\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.models.DrivebaseState.powers","title":"<code>powers = Field(default_factory=lambda: [0.0, 0.0])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current power of the motors</p>"},{"location":"reference/#kevinbotlib.models.DrivebaseState.amps","title":"<code>amps = Field(default_factory=lambda: [0, 0])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current amps for both motors</p>"},{"location":"reference/#kevinbotlib.models.DrivebaseState.watts","title":"<code>watts = Field(default_factory=lambda: [0, 0])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current watts for both motors</p>"},{"location":"reference/#kevinbotlib.models.DrivebaseState.status","title":"<code>status = Field(default_factory=lambda: [MotorDriveStatus.UNKNOWN, MotorDriveStatus.UNKNOWN])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current status for both motors</p>"},{"location":"reference/#kevinbotlib.models.ServoState","title":"<code>ServoState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the servo subsystem</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class ServoState(BaseModel):\n    \"\"\"The state of the servo subsystem\"\"\"\n\n    angles: list[int] = Field(default_factory=lambda: [-1] * 32)\n    \"\"\"Servo angles\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.models.ServoState.angles","title":"<code>angles = Field(default_factory=lambda: [-1] * 32)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Servo angles</p>"},{"location":"reference/#kevinbotlib.models.BMState","title":"<code>BMState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the BMS (Battery Management System)</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class BMState(BaseModel):\n    \"\"\"The state of the BMS (Battery Management System)\"\"\"\n\n    voltages: list[float] = Field(default_factory=lambda: [0.0, 0.0])\n    raw_voltages: list[float] = Field(default_factory=lambda: [0.0, 0.0])\n    states: list[BmsBatteryStatus] = Field(default_factory=lambda: [BmsBatteryStatus.UNKNOWN, BmsBatteryStatus.UNKNOWN])\n</code></pre>"},{"location":"reference/#kevinbotlib.models.IMUState","title":"<code>IMUState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the IMU (Inertial Measurement System)</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class IMUState(BaseModel):\n    \"\"\"The state of the IMU (Inertial Measurement System)\"\"\"\n\n    accel: list[int] = Field(default_factory=lambda: [-1] * 3)  # X Y Z\n    gyro: list[int] = Field(default_factory=lambda: [-1] * 3)  # R P Y\n</code></pre>"},{"location":"reference/#kevinbotlib.models.ThermometerState","title":"<code>ThermometerState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the DS18B20 Thermometers (does not include BME280)</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class ThermometerState(BaseModel):\n    \"\"\"The state of the DS18B20 Thermometers (does not include BME280)\"\"\"\n\n    left_motor: float = -1\n    right_motor: float = -1\n    internal: float = -1\n</code></pre>"},{"location":"reference/#kevinbotlib.models.EnviroState","title":"<code>EnviroState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the BME280 Envoronmental sensor</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class EnviroState(BaseModel):\n    \"\"\"The state of the BME280 Envoronmental sensor\"\"\"\n\n    temperature: float = -1\n    humidity: float = 0\n    pressure: int = 0\n</code></pre>"},{"location":"reference/#kevinbotlib.models.LightingState","title":"<code>LightingState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of Kevinbot's led segments</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class LightingState(BaseModel):\n    \"\"\"The state of Kevinbot's led segments\"\"\"\n\n    camera: int = 0\n    head_effect: str = \"unknown\"\n    head_bright: int = 0\n    head_update: int = -1\n    head_color1: list[int] = Field(default=[0, 0, 0], min_length=3)\n    head_color2: list[int] = Field(default=[0, 0, 0], min_length=3)\n    body_effect: str = \"unknown\"\n    body_bright: int = 0\n    body_update: int = -1\n    body_color1: list[int] = Field(default=[0, 0, 0], min_length=3)\n    body_color2: list[int] = Field(default=[0, 0, 0], min_length=3)\n    base_effect: str = \"unknown\"\n    base_bright: int = 0\n    base_update: int = -1\n    base_color1: list[int] = Field(default=[0, 0, 0], min_length=3)\n    base_color2: list[int] = Field(default=[0, 0, 0], min_length=3)\n</code></pre>"},{"location":"reference/#kevinbotlib.models.KevinbotState","title":"<code>KevinbotState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the robot as a whole</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class KevinbotState(BaseModel):\n    \"\"\"The state of the robot as a whole\"\"\"\n\n    connected: bool = False\n    enabled: bool = False\n    error: CoreErrors = CoreErrors.OK\n    estop: bool = False\n    uptime: int = 0\n    uptime_ms: int = 0\n    motion: DrivebaseState = Field(default_factory=DrivebaseState)\n    servos: ServoState = Field(default_factory=ServoState)\n    battery: BMState = Field(default_factory=BMState)\n    imu: IMUState = Field(default_factory=IMUState)\n    thermal: ThermometerState = Field(default_factory=ThermometerState)\n    enviro: EnviroState = Field(default_factory=EnviroState)\n    lighting: LightingState = Field(default_factory=LightingState)\n</code></pre>"},{"location":"reference/#kevinbotlib.models.KevinbotEyesState","title":"<code>KevinbotEyesState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of the eye system</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class KevinbotEyesState(BaseModel):\n    \"\"\"The state of the eye system\"\"\"\n\n    connected: bool = False\n    settings: EyeSettings = EyeSettings()\n</code></pre>"},{"location":"reference/#kevinbotlib.models.KevinbotServerState","title":"<code>KevinbotServerState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state system used internally in the Kevinbot Server</p> Source code in <code>src/kevinbotlib/models.py</code> <pre><code>class KevinbotServerState(BaseModel):\n    \"\"\"The state system used internally in the Kevinbot Server\"\"\"\n\n    mqtt_connected: bool = False\n    clients: int = 0\n    heartbeat_freq: float = -1\n    connected_cids: list[str] = []\n    dead_cids: list[str] = []\n    cid_heartbeats: dict[str, float] = {}\n    last_driver_cid: str | None = None\n    driver_cid: str | None = None\n    last_drive_command_time: datetime | None = None\n    timestamp: datetime | None = None\n</code></pre>"},{"location":"reference/#kevinbotlib.exceptions.HandshakeTimeoutException","title":"<code>HandshakeTimeoutException</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception that is produced when the connection handshake times out</p> Source code in <code>src/kevinbotlib/exceptions.py</code> <pre><code>class HandshakeTimeoutException(BaseException):\n    \"\"\"Exception that is produced when the connection handshake times out\"\"\"\n</code></pre>"},{"location":"reference/#kevinbotlib.config.ConfigLocation","title":"<code>ConfigLocation</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum to represent the location of the config file</p> Source code in <code>src/kevinbotlib/config.py</code> <pre><code>class ConfigLocation(Enum):\n    \"\"\"Enum to represent the location of the config file\"\"\"\n\n    USER = \"user\"\n    SYSTEM = \"system\"\n    AUTO = \"auto\"\n    NONE = \"none\"\n    MANUAL = \"manual\"\n</code></pre>"},{"location":"reference/#kevinbotlib.config.KevinbotConfig","title":"<code>KevinbotConfig</code>","text":"Source code in <code>src/kevinbotlib/config.py</code> <pre><code>class KevinbotConfig:\n    def __init__(self, location: ConfigLocation = ConfigLocation.AUTO, path: str | Path | None = None):\n        self.config_location = location\n\n        self.user_config_path = Path(user_config_dir(\"kevinbotlib\")) / \"settings.yaml\"\n        self.system_config_path = Path(site_config_dir(\"kevinbotlib\")) / \"settings.yaml\"\n\n        self.manual_path: Path | None = None\n        if path:\n            self.manual_path = Path(path)\n\n        self.config_path = self._get_config_path()\n\n        self.config: dict = {}\n\n        self.mqtt: _MQTT = _MQTT({}, self)\n        self.core: _Core = _Core({}, self)\n        self.server: _Server = _Server({}, self)\n        self.eyes: _Eyes = _Eyes({}, self)\n        self.piper_tts: _PiperTTS = _PiperTTS({}, self)\n\n        self.load()\n\n    def _get_config_path(self) -&gt; Path | None:\n        \"\"\"Get the optimal configuration path\n\n        Returns:\n            Path | None: File location\n        \"\"\"\n        if self.config_location == ConfigLocation.NONE:\n            return None\n        if self.config_location == ConfigLocation.MANUAL:\n            if self.manual_path:\n                return Path(self.manual_path)\n            logger.warning(\"ConfigLocation.MANUAL set without config path, defaulting to ConfigLocation.NONE\")\n            return None  # should never happen\n        if self.config_location == ConfigLocation.USER:\n            return self.user_config_path\n        if self.config_location == ConfigLocation.SYSTEM:\n            return self.system_config_path\n        # AUTO: Prefer user, else system, if none, return user\n        if self.user_config_path.exists():\n            return self.user_config_path\n        if self.system_config_path.exists():\n            return self.system_config_path\n        return self.user_config_path\n\n    def load(self) -&gt; None:\n        if self.config_path and self.config_path.exists():\n            with open(self.config_path) as file:\n                self.config = yaml.safe_load(file) or {}\n\n        self.mqtt = _MQTT(self.config.get(\"mqtt\", {}), self)\n        self.core = _Core(self.config.get(\"core\", {}), self)\n        self.server = _Server(self.config.get(\"server\", {}), self)\n        self.eyes = _Eyes(self.config.get(\"eyes\", {}), self)\n        self.piper_tts = _PiperTTS(self.config.get(\"piper_tts\", {}), self)\n\n    def save(self) -&gt; None:\n        if self.config_path:\n            if not self.config_path.parent.exists():\n                self.config_path.parent.mkdir(parents=True)\n            with open(self.config_path, \"w\") as file:\n                yaml.dump(self._get_data(), file, default_flow_style=False)\n        else:\n            logger.error(\"Couldn't save configuration to empty path\")\n\n    def dump(self) -&gt; str:\n        \"\"\"Dump configuration\n\n        Returns:\n            str: YAML\n        \"\"\"\n        return yaml.dump(self._get_data(), default_flow_style=False)\n\n    def _get_data(self):\n        return {\n            \"mqtt\": self.mqtt.data,\n            \"core\": self.core.data,\n            \"eyes\": self.eyes.data,\n            \"server\": self.server.data,\n            \"piper_tts\": self.piper_tts.data,\n        }\n\n    def __repr__(self):\n        return f\"{super().__repr__()}\\n\\n{yaml.dump(self._get_data(), default_flow_style=False)}\"\n</code></pre>"},{"location":"reference/#kevinbotlib.config.KevinbotConfig._get_config_path","title":"<code>_get_config_path()</code>","text":"<p>Get the optimal configuration path</p> <p>Returns:</p> Type Description <code>Path | None</code> <p>Path | None: File location</p> Source code in <code>src/kevinbotlib/config.py</code> <pre><code>def _get_config_path(self) -&gt; Path | None:\n    \"\"\"Get the optimal configuration path\n\n    Returns:\n        Path | None: File location\n    \"\"\"\n    if self.config_location == ConfigLocation.NONE:\n        return None\n    if self.config_location == ConfigLocation.MANUAL:\n        if self.manual_path:\n            return Path(self.manual_path)\n        logger.warning(\"ConfigLocation.MANUAL set without config path, defaulting to ConfigLocation.NONE\")\n        return None  # should never happen\n    if self.config_location == ConfigLocation.USER:\n        return self.user_config_path\n    if self.config_location == ConfigLocation.SYSTEM:\n        return self.system_config_path\n    # AUTO: Prefer user, else system, if none, return user\n    if self.user_config_path.exists():\n        return self.user_config_path\n    if self.system_config_path.exists():\n        return self.system_config_path\n    return self.user_config_path\n</code></pre>"},{"location":"reference/#kevinbotlib.config.KevinbotConfig.dump","title":"<code>dump()</code>","text":"<p>Dump configuration</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>YAML</p> Source code in <code>src/kevinbotlib/config.py</code> <pre><code>def dump(self) -&gt; str:\n    \"\"\"Dump configuration\n\n    Returns:\n        str: YAML\n    \"\"\"\n    return yaml.dump(self._get_data(), default_flow_style=False)\n</code></pre>"},{"location":"subsystems/","title":"Subsystems","text":""},{"location":"subsystems/#what-is-a-subsystem","title":"What is a Subsystem?","text":"<p>A subsystem is a child component of a system</p> <p>All connection and state logic is handled in it's root system.</p>"},{"location":"subsystems/drivebase/","title":"Drivebase","text":""},{"location":"subsystems/lighting/","title":"Lighting","text":""},{"location":"subsystems/servos/","title":"Servos","text":""},{"location":"systems/","title":"Systems","text":""},{"location":"systems/#what-is-a-system","title":"What is a System?","text":"<p>A system is a root component that is used in KevinbotLib. </p> <p>In the case of serial communication, KevinbotLib will have to connect to it separately from another system.</p> <p>When using MQTT communication, you will need to pass in the Kevinbot system (with a non-Kevinbot system), or spin up an MQTT client (with a Kevinbot system).</p> <p>A system will contain it's own state management, connection system, and subsystems.</p>"},{"location":"systems/eyes/","title":"Eyes (System)","text":"<p>The eyes system is designed to interface with Kevinbot v3's Eyes.</p> <p>It can use a serial link, or be used with the KevinbotLib Server over MQTT (reusing the same client as the Kevinbot system).</p> <p>It does not contain any subsystems.</p>"},{"location":"systems/kevinbot/","title":"Kevinbot (System)","text":"<p>The Kevinbot system is the main system and controller. It is designed to use the Kevinbot Core.</p> <p>It supports serial communication and MQTT communication using SerialKevinbot and MqttKevinbot respectively.</p>"}]}